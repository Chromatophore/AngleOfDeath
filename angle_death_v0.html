<!-- Standalone Generated By Octo (octo-ide.com) -->
<script>data={"program":"############################################\n#                                          #\n#    #####          ANGLE                  #\n#   #########                              #\n#   ##\t\t\t\t\t\tOF             #\n#   #  #####                               #\n#   # ### # #\t\t\t\t\t   DEATH   #\n#   #  #####\t\t\t\t\t\t\t   #\n############################################\n\n\n:alias Tx  vD\t# target X\n:alias Ty  vC\t# target Y\n:alias Tr  vB   # Rotation\n:alias TrZ vA   # Rotation Zone\n:alias frame_stepper v9\n:alias next_crosshair v8\n# v7\n\n\n# Non critical frame to frame\n:alias on_axis v3\n:alias off_axis v4\n# Convinience\n:alias cross_x v0\n:alias cross_y v1\n\n:alias subpx_step v5\n\n## Calculate gameplay dimensions:\n\n:calc zone { 7 * 8 }\n\n:calc UL_X { -1 + ( 128 - zone ) / 2 }\n:calc UL_Y { -1 + ( 64 -  zone ) / 2 }\n:calc UL_X_plus1 { UL_X + 1 }\n:calc UL_Y_plus1 { UL_Y + 1 }\n\n:calc LL_Y { 0 + ( 64 +  zone ) / 2 }\n\n:calc UR_X { 0 + ( 128 + zone ) / 2 }\n\n:calc UR_Max8 { UL_X + zone }\n:calc LL_Max8 { UL_Y_plus1 + zone }\n\n:calc player_LEFT_LIMIT { UL_X + 3 }\n:calc player_RIGHT_LIMIT { UR_X - 3 }\n\n:calc player_TOP_LIMIT { UL_Y + 3 }\n:calc player_LOW_LIMIT { LL_Y - 3 }\n\n#########\n#\n# The big redo\n#\n#########\n# Positive Axes:\n#\n#      x--->  @ = 0\n#      |\n#      V\n#\n# The signs on the axes reflect a typical 'I'm a graph' sort of layout\n# with 0 pointing down the X axis\n# We can set a flag based on if the effect of the angle is inverted\n# We can set a flag based on if the axes are flipped\n# We can set a flag on if we are the 'opposite' of the regular line\n# But these flags don't help us really... pick stuff on their own\n# The main axis maximum is a combation of two flags\n# The off axis maximum is again, a combination\n# When we flip the axes, this is an X = Y mirror\n# But we could still identify the regions\n#\n#   -    110 | 111    -\n#      -     |     -\n#   100   -  |  -   001\n#  --------- X ----------  0 \n#   101   -  |  -   000\n#      -     |     -\n#   -    011 | 010    -\n#\n# But these don't increment naturally at all\n# Unless we pick a diagonal as 0, we run into a lot of problems when\n# incrementing the zones in a circle in terms of if inidividual flags mean things to us\n#                          \n#   -    100 | 101    -  \n#      -     |     -\n#   011   -  |  -   110\n#  --------- X ----------\n#   010   -  |  -   111\n#      -     |     -\n#   -    001 | 000    -\n#                        0\n# But this kind of works\n# Bit 1 always reflects a mirroring around the on axis line\n# Bit 2 always corresponds with the on axis being horizontal vs vertical\n# Bit 3 always corresponds with mirroring both the off axis line and on axis, or, adding 180 degrees\n# By picking which diagonal 0 is, we can pick things to line up with 'positive' axes\n# And treat the first bit being 0 as being our 'backwards' tan\n# Plus, we can use these in a jump table to correctly \n# If we wanted to do this\n# jump [address] is a 2 byte instrunction\n\n# We can pick the order of +ve on axis values, if we accept clockwise, so, let's go ahead and do this:\n#                        0 \n#   -   1100 | 1110   -  \n#      -     |     -\n#   1010  -  |  -   0000\n#  --------- X ----------\n#   1000  -  |  -   0010\n#      -     |     -\n#   -   0110 | 0100   -\n#                        \n\n# We need to position our crosshairs on the border of our boundry square now\n# We have the current angle in Tr and the current zone in jumpable format in TrZ\n\n# We will already have the rotation table set correctly, so, we don't need to worry about that\n\n:alias enemy_data_size v7\n:alias enemy_data_simple_save v2\n\n: main\n\t\n\t# pick a random start point\n\tv0 := random 0b01111110\n\ti := long random_mob_position\n\tsave v0\n\n\t# Generate quick off_axis table\n\tgenerate_tan_table\n\tgenerate_offaxis_max_table\n\n\thires\n\n: game_restart\n\n\n\ti := long enemy_fast_wipe\n\tload v7\n\tv8 := 8\n\ti := long enemy_fast_redraw\n\tloop\n\t\tsave v7\n\t\tv8 -= 1\n\t\tif v8 != 0 then\n\tagain\n\n\ti := long enemy_list_wipe\n\tload v7\n\tv8 := 8\n\ti := long enemy_list\n\tloop\n\t\tsave v7\n\t\tv8 -= 1\n\t\tif v8 != 0 then\n\tagain\t\n\n\tlevel_select_mode\n\n\ti := load_level_number\n\tsave v0\n\n\tplane 3\n\tclear\n\tplane 1\n\thires\n\n\ti := wipey_wipe\n\tload vF\n\n\tdraw_game_box\n\n\tvF := 16\n\tf_delay\n\n\ti := long sweeper_walk_broom\n\tv0 := 8\n\tv1 := 8\n\tsprite v0 v1 0\n\n\ti := long sweeper_platform_a\n\tv0 := 0\n\tv1 += 16\n\tsprite v0 v1 1\n\ti := long line_h\n\tv0 += 8\n\tsprite v0 v1 1\n\tv0 += 8\n\tsprite v0 v1 1\n\tv0 += 8\n\tsprite v0 v1 1\n\n\t# Reset sweeps for this level:\n\treset_sweeps\n\n\t:next load_level_number\n\tv0 := 0\n\tload_level\n\t\n\n\t\n\tTx := 64\n\tTy := 32\n\tTr := 0\n\tTrZ := 0b0010\n\n\tdraw_crosshairs_from_memory\n\n\tupdate_trz_code\n\n\tv0 := TrZ\n\tv2 := Tr\n\n\t:macro calc_next_crosshair {\n\t\tnext_crosshair := random 0b00001111\n\t\tnext_crosshair += 4\n\t}\n\tcalc_next_crosshair\n\tjump0 update_rotation_code\n\n\tloop\n\n\t\tv0 := 0 if v0 key begin\n\t\t\t:breakpoint q\n\t\t\tv0 += 1\n\t\tend\n\n\t\t# Let's handle input:\n\t\t# It would be handy to know if the player has not pushed any input\n\n\t\t:alias detect_rot v5\n\t\t:alias player_input v6\n\n\t\tplayer_input := 0\n\t\t\n\t\tv0 := 0xE if v0 key then jump trigger_pull\n\n\t\t: cross_return\n\n\t\tdetect_rot := Tx\n\t\tv0 := 7   if v0 key then Tx += -1 # keyboard A\n\t\tv0 := 9   if v0 key then Tx +=  1 # keyboard D\n\t\tif Tx != detect_rot then player_input += 1\n\n\t\tdetect_rot := Ty\n\t\tv0 := 5   if v0 key then Ty += -1 # keyboard W\n\t\tv0 := 8   if v0 key then Ty +=  1 # keyboard S\n\t\tif Ty != detect_rot then player_input += 1\n\n\t\t# We only have to run this code if they push a button:\n\t\tif player_input == 0 then jump service_rot\n\n\t\t# Gate player\n\t\tif Tx == player_LEFT_LIMIT then Tx += 1 # ie, go right\n\t\tif Tx == player_RIGHT_LIMIT then Tx += -1\n\t\tif Ty == player_TOP_LIMIT then Ty += 1\n\t\tif Ty == player_LOW_LIMIT then Ty += -1\n\n\t\t# We will use v5 to indicate we're trying to change rotation:\n\n\t\t: service_rot\n\t\tdetect_rot := Tr\n\t\tv0 := 4   if v0 key then Tr += -1 # keyboard Q\n\t\tv0 := 6   if v0 key then Tr +=  1 # keyboard E\n\t\t# Skip rotation update if rotation is unchanged:\n\t\tif detect_rot == Tr then jump update_rotation_code_return\n\n\t\t# Here, if detect_rot is 0 and player_input is 0 then we\n\t\t# don't need to update our positions\n\n\t\t# if player_input is 1 but detect_rot is 0 then we don't need\n\t\t# to update rot\n\n\t\t# if player_input is 0 but detect_rot is 1, then we still\n\t\t# need to update stuff\n\n\t\t# 0 0 nothing\n\t\t# 1 0 pos only\n\t\t# ? 1 both\n\n\t\t# begin\n\t\t\t# This code runs only on r change\n\t\t\tplayer_input += 1\n\n\t\t\tif Tr == 45 begin\n\t\t\t\tTr := 0\n\t\t\t\tTrZ += 0b010\n\t\t\t\tif TrZ == 0b010000 then TrZ := 0\n\t\t\t\tupdate_trz_code\n\t\t\tend\n\t\t\tif Tr == -1 begin\n\t\t\t\tTr := 44\n\t\t\t\tTrZ -= 0b010 # mm sugar\n\t\t\t\tif TrZ == 0b11111110 then TrZ := 0b001110\n\t\t\t\tupdate_trz_code\n\t\t\tend\n\t\t\t# Rotation must have changed for us to be here:\n\t\t\t# if __1_, then Tr can be used to index into the tan table normally\n\t\t\t# if __0_, then the correct value is 45 - Tr\n\n\t\t\t# Here's a mad solution:\n\t\t\tv0 := TrZ\n\t\t\tv2 := Tr\n\t\t\tjump0 update_rotation_code\n\t\t# end\n\t\t: update_rotation_code_return\n\t\t\t# Here, we KNOW that the player pushed something\n\t\t\t# Can we all directly into the update code?\n\n\t\t# Undraw the existing cursors:\n\t\tdraw_crosshairs_from_memory\n\n\t\t# Perform duty cycle\n\t\ti := frame_cycle_count\n\t\tload v0\n\t\tv0 += 8\n\t\tif v0 == 64 begin\n\n\t\t\t# calculate small offset to player crosshair\n\t\t\ti := player_crosshair_adjust\n\t\t\tv0 := random 0b00000011\n\t\t\tv0 -= 4\n\t\t\tif v0 == -1 then v0 := -3\n\t\t\tv1 := random 0b00000011\n\t\t\tv1 -= 4\n\t\t\tif v1 == -1 then v1 := -3\n\t\t\tsave v1\n\n\t\t\tv0 := 0\n\t\t\tframe_stepper += 0x80\n\n\t\tend\n\t\ti := frame_cycle_count\n\t\tsave v0\n\n\t\t# If player_input is true then we must redraw\n\t\t# if it is 0 then we can use saved values\n\t\tif player_input == 0 begin\n\t\t\t# DONT UPDATE STUFF:\n\t\t\tdraw_crosshairs_from_memory\n\t\t\tjump bypass_crosshair_update\n\t\tend\n\n\t\tif next_crosshair != 0 then next_crosshair += -1\n\n\t\t############ UPDATE STUFF\n\t\t# Calculate first:\n\t\tDoFirstCrosshair\n\t\t: apply_on_axis_main_memory\n\t\tapply_on_axis_main\n\t\t# cross_x and y are v0 and v1\n\n\t\t# it is INCREDIBLY helpful to retain the original axis values\n\t\t: address_crosshair_1_data_memory\n\t\ti := crosshair_1_data\n\t\tsave off_axis\n\n\t\ti := crosshair_b\n\t\tif frame_stepper != 0 then i := crosshair_a\n\t\tsprite cross_x cross_y 3\n\n\t\tDoSecondCrosshair\n\t\t: apply_on_axis_flipped_memory\n\t\tapply_on_axis_flipped\n\n\t\t: address_crosshair_2_data_memory\n\t\ti := crosshair_2_data\n\t\tsave off_axis\n\n\t\ti := crosshair_a\n\t\tif frame_stepper != 0 then i := crosshair_b\n\t\tsprite cross_x cross_y 3\n\n\t\t: bypass_crosshair_update\n\n\t\t# Let's service enemies in the field\n\t\t# We don't need to process them all\n\t\t# But we do need to process them at all\n\n\t\t## v0 is our current frame cycle value\n\n\t\tservice_enemy\n\n\t\t: trigger_return\n\n\n\t\tif next_crosshair == 1 then jump draw_player_crosshair\n\n\t\tif next_crosshair == 0 begin\n\t\t\t: draw_player_crosshair\n\t\t\t# Draw crosshair\n\n\t\t\ti := player_crosshair_adjust\n\t\t\tload v1\n\n\t\t\ti := long player_crosshair\n\t\t\tv0 += Tx\n\t\t\tv1 += Ty\n\t\t\t#v0 -= 3\n\t\t\t#v1 -= 3\n\n\t\t\tsprite v0 v1 8\n\t\tend\n\n\t\t# Try to delay only one 60 fps frame most of the time:\n\t\tvf := 1\n\t\tf_delay\n\n\t\tif next_crosshair == 1 then jump undraw_player_crosshair\n\t\tif next_crosshair == 0 begin\n\t\t\tcalc_next_crosshair\n\t\t\t: undraw_player_crosshair\n\t\t\t# Undraw crosshair\n\t\t\tsprite v0 v1 8\n\t\tend\n\t\tnext_crosshair += -1\n\n\t\ti := long register_dump\n\t\tsave vF\n\n\n\n\n\tagain\n\n\n\n\n\tjump main\n\n: frame_cycle_count\n  0\n\n: player_crosshair_adjust\n 0 0\n\n\n: draw_crosshairs_from_memory\n\ti := crosshair_1_data\n\tload cross_y\n\ti := crosshair_b\n\tif frame_stepper != 0 then i := crosshair_a\n\tsprite cross_x cross_y 3\n\n\ti := crosshair_2_data\n\tload cross_y\n\ti := crosshair_a\n\tif frame_stepper != 0 then i := crosshair_b\n\tsprite cross_x cross_y 3\n;\n\n: crosshair_1_data\n 0x5b 0x1F \n \t\t\t: crosshair_1_subpixels\n \t\t\t0x1C \n \t\t\t\t: crosshair_1_onaxis\n \t\t\t\t0 0\n: crosshair_2_data\n 0x22 0x1F\n \t\t\t: crosshair_2_subpixels\n \t\t\t0x1D\n \t\t\t\t: crosshair_2_onaxis\n \t\t\t\t0 0\n\n\n# These are determined by our current rotation\n: apply_on_axis_main\n\t: simple_axis_apply_target_A\n\tvF := vF\n\tvF := vF\n;\n\n: apply_on_axis_flipped\n\t: simple_axis_apply_target_B\n\tvF := vF\n\tvF := vF\n;\n\n: DoSecondCrosshair\n\tv0 := TrZ\n\tvF := 0b1000\n\tv0 ^= vF\n\tjump0 SetupOnAxis\t# Note shared return path\n\n: DoFirstCrosshair\n\tv0 := TrZ\n\tjump0 SetupOnAxis\n\t############ ->>>>>>>>>>>>\n\n\t: AxesReturnPoint\n\t# Store the final subpixel value into v2:\n\tv2 := v1\n\n\t# This is going to nuke v0 and v1\n\tcross_x := Tx\n\tcross_x -= 1\n\tcross_y := Ty\n\tcross_y -= 1\n;\n\n: SetupOnAxis\n# 0000 # On axis: +X, off axis -Y\njump SetupOnPosX\n# 0010 # On axis: +X, off axis +Y\njump SetupOnPosX\n# 0100 # On axis: +Y, off axis +X\njump SetupOnPosY\n# 0110 # On axis: +Y, off axis -X\njump SetupOnPosY\n# 1000 # On axis: -X, off axis +Y\njump SetupOnNegX\n# 1010 # On axis: -X, off axis -Y\njump SetupOnNegX\n# 1100 # On axis: -Y, off axis -X\njump SetupOnNegY\n# 1110 # On axis: -Y, off axis +X\njump SetupOnNegY\n\n: SetupOffAxis\n# 0000 # On axis: +X, off axis -Y\njump SetupOffNegY\n# 0010 # On axis: +X, off axis +Y\njump SetupOffPosY\n# 0100 # On axis: +Y, off axis +X\njump SetupOffPosX\n# 0110 # On axis: +Y, off axis -X\njump SetupOffNegX\n# 1000 # On axis: -X, off axis +Y\njump SetupOffPosY\n# 1010 # On axis: -X, off axis -Y\njump SetupOffNegY\n# 1100 # On axis: -Y, off axis -X\njump SetupOffNegX\n# 1110 # On axis: -Y, off axis +X\njump SetupOffPosX\n\n# 0000\n\t\t# On axis: +X, off axis -Y\n: SetupOnPosX\n\ton_axis := UR_X\n\ton_axis -= Tx\n\tjump0 SetupOffAxis\n\n: SetupOnNegX\n\ton_axis := Tx\n\ton_axis -= UL_X\n\tjump0 SetupOffAxis\n\n: SetupOnPosY\n\ton_axis := LL_Y\n\ton_axis -= Ty\n\tjump0 SetupOffAxis\n\n: SetupOnNegY\n\ton_axis := Ty\n\ton_axis -= UL_Y\n\tjump0 SetupOffAxis\n\n\n: SetupOffPosX\n\toff_axis := UR_X\n\toff_axis -= Tx\n\tjump get_off_axis\n\n: SetupOffNegX\n\toff_axis := Tx\n\toff_axis -= UL_X\n\tjump get_off_axis\n\n: SetupOffPosY\n\toff_axis := LL_Y\n\toff_axis -= Ty\n\tjump get_off_axis\n\n: SetupOffNegY\n\toff_axis := Ty\n\toff_axis -= UL_Y\n\tjump get_off_axis\n\n\n: draw_game_box\n\n\tv0 := UL_X\n\n\tv1 := UL_Y\n\tv2 := LL_Y\n\n\ti := line_h\n\n\tloop\n\t\tsprite v0 v1 1\n\t\tsprite v0 v2 1\n\n\t\tv0 += 8\n\t\tif v0 != UR_Max8 then\n\tagain\n\n\ti := line_h_2\n\tsprite v0 v1 1\n\tsprite v0 v2 1\n\n\t\n\n\tv0 := UL_X\n\tv1 := UR_X\n\tv2 := UL_Y_plus1\n\n\ti := line_v\n\n\tloop\n\t\tsprite v0 v2 8\n\t\tsprite v1 v2 8\n\n\t\tv2 += 8\n\t\tif v2 != LL_Max8 then\n\tagain\n\n\tv0 := 95\n\tv1 := 1\n\ti := long qtex_clean\n\tqtex\n\n\tv0 := 3\n\tv1 := 29\n\ti := long qtex_sweep\n\tqtex\n\n\tv0 := 3\n\tv1 := 56\n\ti := long qtex_rank\n\tqtex\n\n\tv0 := 96\n\tv1 := 50\n\ti := long qtex_score\n\tqtex\n;\n\n: qtex\n\tv2 := 0\n\tv3 := 5\n\tloop\n\t\tsprite v0 v1 5\n\t\tv0 += 8\n\t\tv2 += 1\n\t\ti += v3\n\t\tif v2 != 4 then\n\tagain\n;\n\n: get_off_axis\n\t# Takes:\n\t# on_axis: the large value of the triangle\n\t# off_axis: the maximun acceptable value for the triangle\n\n\t# Returns:\n\t# on_axis on final axis vector\n\t# off_axis off final axis vector\n\t# \n\n\t:alias work_rot v2\n\t:alias WIP_off v5\n\n\t# Yep you guessed it self modifying code:\n\t:next quick_rot_for_axis\n\twork_rot := 0x00\n\n\t# if they're literally presenting a 0 degree angle, then, we have no off axis to calculate\n\tif work_rot == 0 begin\n\t\toff_axis := 0\n\t\tv1 := 0x80\n\t\t# Obviously, this is already the case:\n\t\t# on_axis := on_axis\n\t\tjump AxesReturnPoint\n\tend\n\n\tif work_rot == 45 begin\n\t\t# This case is a little more complicated, but in essence\n\n\t\t# if we need to remember to set v1 register to subpixels count\n\t\t# then we can do that here:\n\t\tv1 := 0x80\n\n\t\t# What on and off axis are is... vague\n\t\t# But if either axis is less than the other then that's the minimum\n\n\t\tif on_axis > off_axis then on_axis := off_axis\n\t\tif off_axis > on_axis then off_axis := on_axis\n\t\tjump validated_off_axis\n\t\tend\n\t\n\t\n\t# Also modify our backup plan memory read as this is the unadjusted base of the table\n\t# This is whe data we want to adjust:\n\t: offaxis_mem_read_base\n\ti := long quick_tan_table\n\t:calc offaxis_mem_read { offaxis_mem_read_base + 2 }\n\n\ti += on_axis\n\ti += on_axis\n\n\tload v1\n\t# v0 will be total off axis displacement\n\t# v1 will be the remaining subpixels at this point\n\n\tWIP_off := v0\n\n\n\tif WIP_off > off_axis begin\n\t\t# unfortunately, this exceeds our stated maximum\n\t\t# We could raycast however we can also precompute the best result\n\t\t# for every one of these, like we do for the on_axis read\n\n\t\t# if we do this then we lose the knowledge of what our subpixels are\n\t\t# Maybe it's best just to get our subpixels again when we need them?\n\n\t\tWIP_off := off_axis\n\t\t0xF0 00\n\t\t: off_axis_table_address\n\t\t0 0\n\n\t\ti += off_axis\n\t\tload v0\n\n\t\t:monitor off_axis_table_address 2\n\t\t# We must not exend on access though:\n\t\tif v0 < on_axis then on_axis := v0\n\tend\n\t# otherwise this is a perfectly find on axis length\n\toff_axis := WIP_off\n\n\t: validated_off_axis\n\t# If this off axis in excess of our maximum?\n\t# Who knows\n\tjump AxesReturnPoint\n\n\n: set_i_to_offaxis\n\t0xF0 00\n\t: mem_generic_off_axis\n\t0 0\n;\n\n\n\n# This is a jump table\n# We are going to receive one of the 8 zones here:\n# Uses up code, but is in principal faster than anding out the bits.\n# Maybe\n# jump0 -> jumpT -> Entry\n# vF := 0b10 -> vf &= TrZ -> if vf then Entry / Entry\n: update_rotation_code\n\tjump flip_rotation\n\tjump leave_rotation\n\n\tjump flip_rotation\n\tjump leave_rotation\n\n\tjump flip_rotation\n\tjump leave_rotation\n\n\tjump flip_rotation\n\tjump leave_rotation\n\t# Rotation must have changed for us to be here:\n\t# if __0_, then the correct value is 45 - Tr\n\t# if __1_, then Tr can be used to index into the tan table normally\n\n# We save a copy of the normalisd rotation into memory here\n: rotation_normalised\n\t0\n# v0 will be a safe copy of TrZ\n# v2 is a copy of the rotation\n: flip_rotation\n\tv1 := 45\n\tv2 =- v1\n: leave_rotation\n\t# At this time v2 now contains our correct rotation value for our tables:\n\t# v2: Rotation to use for quick_tan\n\n\t# let's save this\n\tv0 := v2\n\ti := rotation_normalised\n\tsave v0\n\n\t# We need to obtain the memory address of the pregenerated memory from quick_tan\n\ti := long quick_tan\n\t# Add rotation, twice:\n\ti += v2\n\ti += v2\n\tload v1\n\t# v0 v1 now contain the correct value for the starting memory address for this rotation\n\n\ti := offaxis_mem_read\n\tsave v1\n\n\ti := long quick_off_axis\n\ti += v2\n\ti += v2\n\tload v1\n\ti := off_axis_table_address\n\tsave v1\n\ti := mem_generic_off_axis\n\tsave v1\n\n\t# Also, set the value for rotation in get_off_axis:\n\tv0 := v2\n\ti := quick_rot_for_axis\n\tsave v0\n\n\tjump update_rotation_code_return\n\n\t# Technically we only need to like, do this, if TrZ has changed:\n: update_trz_code\n\t# put a doubled version in vE\n\tvE := TrZ\n\tvE += TrZ\n\n\ti := long simple_axis_apply\n\ti += vE\n\tload v3\n\n\ti := simple_axis_apply_target_A\n\tsave v3\n\n\t# put the correct value to bitflip to the opposrite side:\n\tvF := 0b10000\n\tvE ^= vF\n\ti := long simple_axis_apply\n\ti += vE\n\tload v3\n\n\ti := simple_axis_apply_target_B\n\tsave v3\n\n\t# Then we must return, and, we jumped here, so\n;\n\n: trigger_pull\n\t# We want to strobe a pixel from crosshair_a to crosshair_b\n\t# We know the real positions of these crosshairs in crosshair_1_data\n\t# And we know the on and off axis values relative to the player\n\n\t# No matter what we are pulling the trigger here\n\n\t# We use up to v8 in this function, which is ok and doesn't affect normal gameplay\n\n\tv2 := random 0x01\n\tif v2 == 0 then\ti := address_crosshair_1_data_memory\n\tif v2 == 1 then i := address_crosshair_2_data_memory\n\tload v1\n\ti := pull_trigger_internal_loop\n\tsave v1\n\tif v2 == 0 then\ti := apply_on_axis_flipped_memory\n\tif v2 == 1 then i := apply_on_axis_main_memory\n\tload v1\n\ti := pull_trigger_internal_loop_apply_memory\n\tsave v1\n\n\tincrease_sweeps\n\t\n\t# Load up the on subpixels and onaxis value for crosshair 1\n\ti := crosshair_1_subpixels\n\tload v1\n\n\t# v0 = subpx of crosshair 1\n\t# v1 = on axis of crosshai r1\n\n\t# We could Copy subpixels into subpixel accumulating register\n\t# But we might not be starting from here.\n\t# So we don't\n\t# v2 := v0\n\t# v1 is our current on axis\n\n\t# So load up just this value from crosshair 2:\n\ti := crosshair_2_onaxis\n\tload v0\n\t# Add the two onaxis values together\n\tv1 += v0\n\n\t# Save to a register\n\tv6 := v1\n\t# And fix the remaining offset:\n\tv6 += -1\n\n\t# Load up the normalised rotation:\n\ti := rotation_normalised\n\tload v0\n\n\t# Look up the memory location for subpixels per frame:\n\ti := long tan_table\n\t# Step in by rotation\n\ti += v0\n\t# Load it up\n\tload v0\n\t# Store it for later!\n\tsubpx_step := v0\n\n\t# Now, since we actually want every pixel between the two locations\n\t# It's more code efficient to actually math it out rather than use our tables\n\n\tvE := 0\n\t\n\ti := 0x180\n\tsave vF\n\n\t\t# Our loop here:\n\t\t# v0 = cross_x\n\t\t# v1 = cross_y\n\t\t# v2 = subpixel accumulator\n\t\t# v3 = on_axis\n\t\t# v4 = off_axis\n\t\t# v5 = subpx_step\n\t\t# v6 = distance_countdown\n\t\t# v7 = check for collisions with player sweep\n\t\t# v8 = end condition\n\t\t# vE = Allows for the delay of frames\n\n\t# Track points with this:\n\tTx := 0\n\t# Starting points should be the current number of sweeps:\n\ti := long sweeps_this_level\n\t# Let's get XO chip finally\n\tload Tr - Tr\n\tvF := 10\n\tTr =- vF\n\n\t# Draw the line\n\t# in theory if we hit something we're not supposed to, we need to crash out\n\tv7 := 1\n\tv8 := 0\n\n\tpull_trigger_internal_loop\n\tif v7 == 2 begin\n\t\t# if we hit something bad, we have to undraw the line we drew, and skip \n\t\t# collision testing\n\t\tjump line_abort_point\n\tend\n\t\n\t\n\tq_delay\n\n\t# We now juse the graphics planes to avoid having to undraw all the enemies by just only drawing them\n\t# into the plane 2 where the line currently resides\n\t# We have to remove all enemies first and test them individually against the line\n\t# Turn off collisions:\n\t#v5 := 0\n\t# Remove them all:\n\t#sweep_enemies\n\t#sweep_trash\n\t\n\t# Activate collision detection\n\tv5 := 1\n\t# Test one at a time (as part of v5 being on)\n\tsweep_trash\n\tif Tx == 0 then Tr := 0\n\tsweep_enemies\n\n\n\tplane 1\n\tdraw_score\n\ti := long score_this_level\n\tload v0\n\tv0 += Tx\n\ti := long score_this_level\n\tsave v0\n\tdraw_score\n\n\t# if v7 is 0 then we got all the trash:\n\tif v7 == 0 begin\n\t\t#:breakpoint level_complete\n\t\t# Get the level we loaded:\n\n\t\tv0 := 4\n\t\tv1 := 2\n\t\tloop\n\t\t\tbuzzer := v1\n\t\t\tvF := 10\n\t\t\tf_delay\n\t\t\tv0 -= 1\n\t\t\tif v0 != 0 then\n\t\tagain\n\n\t\tv0 := key\n\n\t\ti := load_level_number\n\t\tload v0\n\t\t# We must have completed this level\n\t\tvA := v0\n\n\t\ti := long level_select_last\n\t\tload v3\n\t\t# v0: current level\n\t\t# v1: total levels unlocked\n\t\t# v2: total levels competed\n\t\t# v3: current chapter\n\n\t\tvA += 1\n\t\tv2 := vA\n\t\tvA += 1\n\t\tv1 := vA\n\n\t\ti := long level_select_last\n\t\tsave v3\n\n\t\tjump game_restart\n\tend\n\n\t# turn off collision check\n\t#v5 := 0\n\t# And restore the enemies:\n\t#sweep_enemies\n\t#sweep_trash\n\n\n\t: line_abort_point\n\t# Then undraw the line:\n\ti := 0x180\n\t# restore how many pixels to draw\n\tload v6\n\tv7 := 0\n\tif v8 != v6 then pull_trigger_internal_loop\n\n\ti := 0x180\n\tload vF\n\tplane 1\n\n\tjump trigger_return\n\t\n: trigger_quick_mem\n 0 0\n\n : sweep_trash\n \t# use v6 to count in 3s\n \tv6 := 0\n \t# Use v5 to count linearly now:\n \tv5 := 0\n \t#plane 1\n\n \t# We can also use v7 at this time:\n\n \tv7 := 0\n\n \t#if v5 == 1 then \n \tplane 2\n \tloop\n\t \ti := long quick_trash\n\t \ti += v6\n\t \tload v2\n\n\t \tif v2 == -1 then jump skip_trash_sweep\n\n\t \t# At least 1 item of trash remains\n\t \tv7 += 1\n\n\t \ti := long furniture\n\t \ti += v2\n\t \tsprite v0 v1 8\n\n\t \t#if v5 != 0 begin\n\t \t\tvE := vF\n\t\t\tsprite v0 v1 8\n\t \t\tif vE != 0 begin\n\n\t \t\t\tv7 += -1\n\t\t\t\tplane 1\n\t\t\t\tsprite v0 v1 8\n\t\t\t\t\n\t\t\t\tTx += Tr\n\t\t\t\tif Tr != 0 then Tr += 1\n\n\t\t\t\tv2 := v5\n\t\t\t\tcalc_trash_ui_pos\n\n\t\t\t\tv0 -= 1\n\t\t\t\tv1 -= 1 \n\t\t\t\t\n\t\t\t\ti := long trash_get\n\t\t\t\t#sprite v0 v1 0\n\t\t\t\tplane 2\n\t\t\t\tsprite v0 v1 0\n\n\t \t\t\ti := long level_reset_data\n\t \t\t\tload v2\n\t \t\t\ti := long quick_trash\n\t \t\t\ti += v6\n\t \t\t\tsave v2\n\t \t\tend\n\t \t#end\n\n\t \t: skip_trash_sweep\n \t\tv6 += 3\n \t\tv5 += 1\n\n \t\tif v6 != 27 then\n \tagain\n\n ;\n\n: sweep_enemies\n\tv6 := 0\n\n\t#plane 1\n\t#if v5 == 1 then\n\tplane 2\n\n\tloop\n\t\ti := long enemy_fast_redraw\n\t\ti += v6\n\t\tload v3\n\n\t\tif v3 == -1 then jump trigger_skip_empty_mob\n\t\ti := long brushable_mobs\n\t\ti += v2\n\n\t\tsprite v0 v1 8\n\t\t# Test vF here perhaps\n\t\t#if v5 == 1 begin\n\t\t\tvE := vF\n\t\t\tsprite v0 v1 8\n\t\t\tif vE == 0 begin\n\t\t\t\t# This enemy did not touch our line, we can undraw it to stop testing\n\t\t\t\tjump trigger_skip_empty_mob\n\t\t\tend\n\n\t\t\tTx += Tr\n\t\t\tif Tr != 0 then Tr += 1\n\n\t\t\tplane 1\n\t\t\tsprite v0 v1 8\n\t\t\tplane 2\n\n\t\t\t# Otherwise it does collide, specifically with our line\n\t\t\t# If that happens, we could remove it from the game here\n\t\t\t# That depends on us knowing that the line is good\n\t\t\t# and did not collide with anything it shouldn't be allowed to\n\n\t\t\t# We can use graphics planes to acheive the above perhaps\n\n\t\t\t# But let's remove this enemy from the redraw list:\n\t\t\ti := long enemy_fast_wipe\n\t\t\tload v3\n\t\t\ti := long enemy_fast_redraw\n\t\t\ti += v6\n\t\t\tsave v3\n\n\t\t\t# And also request that it be removed\n\t\t\tremove_enemy\n\t\t#end\n\n\t\t: trigger_skip_empty_mob\n\t\tv6 += 0x08\n\t\tif v6 != 64 then\n\tagain\n;\n\n\n: pull_trigger_internal_loop\t# This label is used to change\n\t\t# Plot to the starting point:\t\t\t\t\t\t|\n\t\ti := crosshair_2_data\t# <-------------------------- this command\n\t\tload v2\n\t\tcross_x += 1\n\t\tcross_y += 1\n\n\t\t# We know that v2 contains the subpixels achieved by the line when it hit the barrier\n\t\t# But we are going to be counting backwards\n\t\t# So let's just invert this value and call it good:\n\n\t\tvF := 0xFF\n\t\tv2 ^= vF\n\t\tv2 += 1\n\n\t\tplane 2\n\t\t\n\t\tloop\n\t\t\t# We can just step on 1 pixel at a time:\n\t\t\ton_axis := 1\n\t\t\toff_axis := 0\n\t\t\tv2 += subpx_step\n\t\t\tif vf != 0 then off_axis := 1\n\t\t\t# Easy 45 degree mode:\n\t\t\tif subpx_step == 0xFF then off_axis := 1\n\t\t\t\n\t\t\t# If I wanted to reverse this, I would call the other command\n\t\t\t# And start at the other coords\n\t\t\t: pull_trigger_internal_loop_apply_memory\n\t\t\tapply_on_axis_main\n\n\t\t\ti := line_v\n\t\t\tsprite cross_x cross_y 1\n\n\t\t\tif v7 == 0 then vF := 0\n\n\t\t\tif vF != 0 begin\n\t\t\t\t# We've hit something we're not allowed to\n\t\t\t\t# We have to abort this line\n\n\t\t\t\ton_axis := 5\n\t\t\t\toff_axis := 4\n\n\t\t\t\tv8 := v6\n\n\t\t\t\tplane 3\n\t\t\t\tloop\n\t\t\t\t\tscroll-up 1\n\t\t\t\t\tbuzzer := off_axis\n\t\t\t\t\tvF := 4\n\t\t\t\t\tf_delay\n\t\t\t\t\ton_axis -= 1\n\t\t\t\t\tscroll-down 1\n\t\t\t\t\tvF := 4\n\t\t\t\t\tf_delay\n\t\t\t\t\tif on_axis != 0 then\n\t\t\t\tagain\n\t\t\t\tplane 2\n\n\t\t\t\tsprite cross_x cross_y 1\n\t\t\t\tv7 := 2\n\t\t\t\treturn\n\t\t\tend\n\n\n\t\t\tvE += 0b01000000\n\t\t\tif vE == 0 begin\n\t\t\t\tq_delay\n\t\t\tend\n\n\t\t\tv6 += -1\n\n\t\t\tif v6 != v8 then\n\t\tagain\n\n\t\tplane 1\n;\n\n: q_delay\n\tvf := 1\n: f_delay\n\tdelay := vf\n\tloop\n\t\tvf := delay\n\t\tif vf != 0 then\n\tagain\n;\n\n# So let's do it with actual code, at run time, because we can!\n: generate_tan_table\n\t# I want to generate a table of\n\t# whole px, subpx for each distance value, per angle\n\t# Max distance is 8 * 7, so let's assume ~63 for easy data stride\n\t# Angle is from (in principal) 0 to in principal (45)\n\t# But we start with 1 because 0 is... all 0s\n\n\tTr := 1\n\n\t# So, this code runs over the whole rotation space and yields the off_axis value for an on_axis displacement\n\t# We have a 2nd table, which works in the reverse - the maximum on_axis displacement for a given off_axis (per rotation)\n\t# We also want access to the remainder subpixels for a given on axis displacement.\n\t# This allows us to pull subpixels per step from tan_table and still know where to start,\n\t# when drawing a line, as we define our starting point as a vague point on the line\n\t# (to allow for simple player control that feels good)\n\t# Either I can work this out on hit, or, I can form a table\n\t# This code here is able to generate table 1 and table 3,\n\t# but the process of having the correct final result for the subpixels is muddied\n\t# You only need this when you try to draw a line, so it's just making the \n\t# hot loop slower to ensure we have these to handy\n\t# So, how can we change this code so that it generates the subpixel table separately?\n\n\tloop\n\t\t# Pull our incrimental subpixel value for this rotation:\n\t\ti := long tan_table\n\t\ti += Tr\n\t\tload v0\n\n\t\t# I have a problem.\n\t\t# I want to self modify this code:\n\t\t: tangen_address_base\n\t\ti := long quick_tan_table\n\t\t:calc code_tangen_address { tangen_address_base + 2 }\n\t\t# fortunately we modify this AFTER we have already used it, later in this loop\n\t\t# Otherwise I can't use calc?\n\n\t\t:monitor tangen_address_base 8\n\n\t\t# Register set up per pass:\n\t\t# Initial sub pixels:\n\t\tv1 := 0x80 \n\t\tv3 := 0\n\t\t# Copy subpixels to another, safe register:\n\t\tsubpx_step := v0 # v5 will be subpix per step\n\t\tv0 := 0  # v0 will be total displacement\n\n\t\t# We will have I pointing at the correct location of this extended tan data\n\t\t# We save the 0 value to prevent complicated maths. Same reason we start with r 0\n\n\t\tloop\n\t\t\t# We will change this to v1 for a 2nd pass:\n\t\t\t:next generate_tan_table_value_retain\n\t\t\t#v0 := v2\n\t\t\t# Save current data (and step on)\n\t\t\tsave v1\n\n\t\t\t# Incriment subpixels:\n\t\t\tv1 += subpx_step\n\t\t\t# If this overflows, we increase displacement in v0\n\t\t\tif vf != 0 then v0 += 1\n\n\t\t\t# v3 counts up:\n\t\t\tv3 += 1\n\t\t\t# Do this 63 times:\n\t\t\tif v3 != 64 then\n\t\tagain\n\n\t\ti := code_tangen_address\n\t\tload v1\n\n\t\t# We now have the memory address of the data for quick_tan_table + r * 64 in our v0 and v1\n\t\t# Turns out we want that in our quicktan table:\n\t\t: generate_tan_table_lookup_base_address\n\t\ti := long quick_tan\n\n\t\t# Set vD to 180 for subpixel table\n\t\ti += vD\n\n\t\t# Incriment I by 2x Tr\n\t\ti += Tr\n\t\ti += Tr\n\t\tsave v1\n\t\t\n\t\t# Then work out the next address:\n\t\tv2 := 0x80 # Data is 128 bytes each:\n\t\tv1 += v2\n\t\tif vf != 0 then v0 += 1\n\n\t\t# Then we save that into our next pass's I command so we work out the next piece of data\n\t\ti := code_tangen_address\n\t\tsave v1\n\n\t\t# Step forward I:\n\t\tTr += 1\n\n\t\t# OK I now have a mad table\n\n\t\tif Tr != 45 then\n\tagain\n;\n\n\n\t\n\n: generate_offaxis_max_table\n\t# So, we also want a table that allows us to figure out the maximum value \n\t# of an on_axis line if the off_axis has to be clamped to some lower value\n\t# We could either search through the displacement data (eg as a binary search)\n\t# or we can create a table that gives us the answer\n\n\tTr := 1\n\n\t# Steal the last valid good memory address from the other function:\n\ti := code_tangen_address\n\tload v1\n\ti := offaxis_gen_memory_target\n\tsave v1\n\n\t# We could use our existing table to work this out but it's actually slightly\n\t# easier to work from scratch\n\t# typical offset is quick_tan_table + 5632\n\tloop\n\t\ti := long tan_table\n\t\ti += Tr\n\t\tload v0\n\t\tsubpx_step := v0\n\n\t\t# v0 as on_axis will be the maximum value that we can count to before we overflow to the next pixel.\n\t\tv0 := 0\n\t\t# off axis:\n\t\toff_axis := 0\n\n\t\t# This time, subpixels will be 0:\n\t\tv2 := 0x00\n\t\t\n\t\t# We will use the overflow to indicate when we've found the next \n\n\t\t# i := long\n\t\t0xF0 00\n\t\t: offaxis_gen_memory_target\n\t\t00 00\n\n\t\t# if you want to go 0 px off axis, you can go... 0?\n\t\tsave v0\n\n\t\tloop\n\t\t\tv0 += 1\n\t\t\tv2 += subpx_step\n\t\t\tif vF != 0 begin\n\t\t\t\t# the current value of on axis is the maximum value for this off axis\n\t\t\t\tsave v0\n\t\t\t\t# i will step on by off_axis amount\n\t\t\t\toff_axis += 1\n\t\t\t\tend\n\n\n\t\t\tif v0 != 63 then\n\t\tagain\n\n\t\tsave v0\n\t\toff_axis += 1\n\n\t\tv0 := 0xFF\n\t\tsave v0\n\t\toff_axis += 1\n\n\t\ti := offaxis_gen_memory_target\n\t\tload v1\n\n\t\t# update the table, I guesss!!!\n\n\t\ti := long quick_off_axis\n\t\ti += Tr\n\t\ti += Tr\n\t\tsave v1\n\n\t\tv1 += off_axis\n\t\tv0 += vF\n\t\ti := offaxis_gen_memory_target\n\t\tsave v1\n\n\t\tTr += 1\n\t\t\n\t\tif Tr == 45 begin\n\t\t\t# the next memory address is set up correctly\n\t\t\ti := final_off_axis_save\n\t\t\tsave v1\n\t\t\t\n\t\t\ti := long quick_off_axis\n\t\t\ti += Tr\n\t\t\ti += Tr\n\t\t\tsave v1\n\t\t\n\t\t\t\n\t\t\t0xF0 00\n\t\t\t: final_off_axis_save\n\t\t\t0 0 \n\t\t\t\n\t\t\tv0 := 0\n\t\t\tv1 := 1\n\t\t\tv2 := 2\n\t\t\t\n\t\t\tsave v1\n\t\t\t\n\t\tend\n\n\t\tif Tr != 45 then\n\tagain\n\t\n\t# We also want a 1 pixel deep final value for 45 degrees\n\t\n\t\n\n;\n\n: service_enemy\n\t# v0 is the current value of frame cycle\n\t# which atm is a value of 0b????0000\n\n\t# v0 := Current movement type    --------- (gets moved elsewhere)\n\t# v1 := Current movement subframe --------- (gets moved elsewhere)\n\t# v2 := mob_frame : Current animation Frame\n\t# ------------ Easy Save separation\n\t# v3 := mob_x : Grid X position\n\t# v4 := mob_y : Grid Y position\n\t# v5 := mob_type : Type of enemy, useful for working out graphic and movement type\n\t# v6 := movement index\n\t# v7 := \n\t# ------------------\n\t# v8 := infinite loop protection when deciding next movement type\n\t# v9 := movement subframe relocate\n\t# vA := mob movement type\n\t# vB mob_data_spacing\n\t# vC mob_draw_y\n\t# vD mob_draw_x\n\t# vE \n\n\t:alias mob_frame v2\n\t:alias mob_x v3\n\t:alias mob_y v4\n\t# 8 bytes per mob\n\t:alias mob_type v5\n\t:alias mob_movement_index v6\n\t:alias mob_speeder v7\n\n\t:alias mob_infinite_loop_protection v8\n\t:alias mob_movement_type vA\n\t:alias mob_movement_subframe v9\n\n\t:alias mob_data_spacing vB\n\t:alias mob_draw_x vD\n\t:alias mob_draw_y vC\n\n\ti := frame_cycle_count\n\tload v0\n\n\ti := long enemy_list\n\ti += v0\n\t# Keep this for a hot minute in case we need it:\n\tvE := v0\n\tload enemy_data_size\n\n\t# This will load our enemy into our registers v0 to v7?\n\n\t# If there's no mob here, we skip:\n\tif mob_type == -1 then jump maybe_create_enemy\n\t# We need to get the display position of this mob:\n: enemy_created\n\t# Backup our registers\n\ti := 0x180\n\tsave vF\n\n\t# Copy our data over to our retaining registers:\n\tmob_movement_type := v0\n\tmob_movement_subframe := v1\n\n\t# Step A: Load up the X/Y coords into mob_x mob_y\n\n\t# Now because we save the enemy position we don't need to do this:\n\t# calc_mob_draw_xy\n\n\n\t# mob_type is now a 0x8 strided list\n\t# load up the sprite spacing for this sprite:\n\t# i := mob_spacing\n\t# i += mob_type\n\t# load v0\n\t# mob_data_spacing := v0\n\n\t# If the mob frame is -1, then it's the first time it's ever been drawn\n\t# In this case we don't need to undraw it:\n\tif mob_frame == -1 begin\n\t\tmob_frame := 0\n\t\tmob_movement_subframe := 16\n\t\tjump mob_skip_undraw\n\tend\n\n\t# Step B: we also need to know the enemy's last displacement:\n\t# This uses movement_type and movement_subframe to load up the offsets\n\t# into v0 and v1\n\t# then we add in the base draw position of this enemy:\n\n\t# We can do this:\n\t#load_movement_subdata\n\t#v0 += mob_draw_x\n\t#v1 += mob_draw_y\n\t# But instead we can do this:\n\ti := long enemy_fast_redraw\n\ti += vE\n\tload v1\n\t# We could load v2 and get the below offset, but we already have it:\n\n\t# Point I at the sprite:\n\ti := brushable_mobs\n\ti += mob_type\n\ti += mob_frame\n\n\t# Undraw the enemy:\n\tsprite v0 v1 8\n\n\t# Iterate the frame every time we process this enemy, so that\n\t# it always does a little dance\n\t# conviniently, the sprites are strided by 0x80\n\tmob_frame += 0x80\n\n\t# And move it only half the time.\n\t# it would be cool if we could make some mobs move faster or slower:\n\n\tmob_speeder -= 1\n\n\t:const mob_speed_offset 0\n\n\tif mob_speeder == 0 begin\n\t\ti := long default_mob_datas\n\t\ti += mob_type\n\t\tv0 := mob_speed_offset\n\t\tload v0\n\t\tmob_speeder := v0\n\t\tmob_movement_subframe += 2\n\tend\n\t\n\t# Cycle the mob frame\n\n\n\tif mob_movement_subframe == 16 begin\n\t\t# We have completed our movement.\n\t\t# We marked our new cell as ours when we started moving.\n\t\t# So we must clear our current cell:\n\n\t\t# If it's a type of movement that actually moves:\n\t\tif mob_movement_type != 0 begin\n\t\t\tv0 := mob_x\n\t\t\tv1 := mob_y\n\t\t\taddress_game_cell\n\t\t\ti := long game_grid\n\t\t\ti += v1\n\t\t\tv0 := -1\n\t\t\tsave v0\n\t\t\t\n\t\t\t# Get single digit translation:\n\t\t\tmob_movement_subframe := 0\n\t\t\t# We pick the subframe assoicated with 1 px offset\n\t\t\t# But instead apply that to the grid:\n\t\t\tload_movement_subdata\n\t\t\tmob_x += v0\n\t\t\tmob_y += v1\n\t\t\t# New position marked\n\t\tend\n\n\t\t: mob_skip_undraw\n\t\t# We should progress to the next part of their movement at this time\n\n\t\tmob_infinite_loop_protection := 0\n\t\t# We need to apply the kind of movement that we hoped to achieve\n\t\t: mob_movement_jumpback\n\t\tmob_infinite_loop_protection += 1\n\t\tif mob_infinite_loop_protection == 6 then jump mob_loop_fail\n\t\t# We need to defend against infinite loops at this time\n\t\tif mob_movement_index == 16 then mob_movement_index := 0\n\t\t# mob movement index is the reference from the start of this mob's movement pattern that we're at\n\t\ti := long enemy_behaviors\n\t\ti += mob_type\n\t\ti += mob_type\n\t\ti += mob_movement_index\n\t\t# There are up to 16 kinds of thing that move with this system\n\t\t# Each type of movement has 16 bytes available to it\n\t\t# Load 2 bytes associated with movement\n\t\tload v1\n\n\t\t# If we've reached the end:\n\t\t# Go back to the start\n\t\tif v0 == -1 begin\n\t\t\tmob_movement_index := 0\n\t\t\tjump mob_movement_jumpback\n\t\tend\n\n\t\t# We just loaded from memory\n\t\t# v0 is our new movement type\n\t\t# v1 is our conditional\n\n\t\t# we need to do some math thinking stuff here\n\t\t# so we're going to need v0 and v1 shipped somewhere else\n\t\tmob_movement_type := v0\n\t\tvE := v1\n\n\t\tif mob_movement_type == -2 begin\n\t\t\tmob_movement_type := random 0b00110000\n\t\t\tmob_movement_type += 16\n\t\tend\n\n\t\t# A non 0 movement type is obviously acceptable:\n\t\tif mob_movement_type == 0 then jump movement_auto_valid\n\n\t\t# we need to look up the cell associated with this new position:\n\t\tmob_movement_subframe := 0\n\t\tload_movement_subdata\n\t\tv0 += mob_x\n\t\tv1 += mob_y\n\t\taddress_game_cell\n\n\t\t# v0 : cell data\n\t\t# v1 : cell address\n\n\t\t# If v0 is -1, then it's fine\n\n\t\t# if v0 is NOT -1, then, we can't move right now\n\t\tif v0 != -1 begin\n\t\t\t# What we do now depends on the value of vE\n\t\t\t# Progression rules:\n\t\t\t# We also have conditionals\n\t\t\t# 0: Progress regardless\n\t\t\t# 1: Repeat until impossible\n\t\t\t# 2: Retry until successful\n\n\t\t\t# Progress anyway\n\t\t\tif vE == 0 begin\n\t\t\t\t# Just defer movement type to 0:\n\t\t\t\t: mob_loop_fail\n\t\t\t\t# This prevents us from experiencing another result:\n\t\t\t\tvE := 0\n\t\t\t\tmob_movement_type := 0\n\t\t\t\tmob_movement_index += 2\n\t\t\tend\n\n\t\t\t# This movement is impossible, so we should actually progress to the next movement\n\t\t\tif vE == 1 begin\n\t\t\t\t# We want to progress on a step:\n\t\t\t\tmob_movement_index += 2\n\t\t\t\t# This can create an infinite loop if the enemy is unable to progress in any direction:\n\t\t\t\tjump mob_movement_jumpback\n\t\t\tend\n\n\t\t\tif vE == 2 begin\n\t\t\t\t# We want to do nothing for this frame, but not progress:\n\t\t\t\tmob_movement_type := 0\n\t\t\t\t# If we can't move because it's a bad coord, we'll never succeed!!\n\t\t\t\t# So progress anyway:\n\t\t\t\tif v0 == -2 then mob_movement_index += 2\n\t\t\tend\n\t\tend\n\n\t\tif v0 == -1 begin\n\t\t\t# Load up this enemy ID:\n\t\t\ti := frame_cycle_count\n\t\t\tload v0\n\t\t\t# Target the game_grid and save our ID into it:\n\t\t\ti := long game_grid\n\t\t\ti += v1\n\t\t\tsave v0\n\n\t\t\t: movement_auto_valid\n\t\t\t# If we can move into this location\n\t\t\t# Then v1 = 0 == progress\n\t\t\t#      v1 = 1 == don't progress yet\n\t\t\t#      v1 = 2 == progress\n\t\t\tif vE != 1 then mob_movement_index += 2\n\t\tend\n\n\t\t# we need to save the whole enemy in this case\n\n\t\tmob_movement_subframe := 0\n\tend\n\n\tcalc_mob_draw_xy\n\tload_movement_subdata\n\t# Re index to sprite frame:\n\n\tv0 += mob_draw_x\n\tv1 += mob_draw_y\n\n\t# Take a copy of exactly where we drew this enemy on the screen:\n\ti := temp_e_data_b\n\tsave v1\n\n\ti := long brushable_mobs\n\ti += mob_type\n\ti += mob_frame\n\n\t# This is the exact position of where the mob is drawn\n\tsprite v0 v1 8\n\n\t# Right now, v0 and v1 contain the information I want about the sprite position\n\t# mob_type + mob_frame consitute a < 256 byte offset to the graphic\n\n\ti := frame_cycle_count\n\tload v0\n\ti := long enemy_list\n\ti += v0\n\n\t# Keep the offset somewhere\n\tvE := v0\n\n\t# Save our updated enemy data\n\t# We move this data back into the save memory region:\n\tv0 := mob_movement_type\n\tv1 := mob_movement_subframe\n\tsave enemy_data_size\n\n\n\t# Load up the X Y draw positions:\n\ti := temp_e_data_b\n\tload v1\n\t# For the purposes of collsion, we want to quickly undraw this enemy\n\t# Let's save the X Y position into a list\n\t# Note that mob_frame IS v2\n\tv2 += mob_type\n\tv3 := mob_type\n\n\t# Generate fast redraw info\n\ti := long enemy_fast_redraw\n\ti += vE\n\tsave v3\n\n\t# Restore our regular gameplay registers:\n\ti := 0x180\n\tload vF\n;\n\n: temp_e_data_b\n 0 0\n\n\n: calc_mob_draw_xy\n\ti := grid_xy\n\ti += mob_x\n\tload v0\n\tmob_draw_x := v0\n\n\ti := grid_xy\n\ti += mob_y\n\tload v0\n\tmob_draw_y := v0\n\n\t# Translate over to the start of the grid:\n\tmob_draw_x += UL_X_plus1\n\tmob_draw_y += UL_Y_plus1\n;\n\n: load_movement_subdata\n\tv0 := 0\n\tv1 := 0\n\n\tif mob_movement_type == 0 then return\n\t# movement patterns are strided by 8 pairs of bytes\n\ti := long movement_patterns\n\t# we should store the direct access value in this register:\n\ti += mob_movement_type\n\ti += mob_movement_subframe\n\t# load the two small offsets\n\tload v1\n;\n\n: last_enemy\n -8\n\n: maybe_create_enemy\n\t# vF contains the current enemy slot that is empty\n\t# I guess I should load an enemy from our hypothetical list of enemies:\n\n\ti := last_enemy\n\tload v0\n\n\tv0 += 8\n\tif v0 == 128 then v0 := 0\n\n\tvF := random 0b00001111\n\tif vF != 0 then return\n\n\ti := last_enemy\n\tsave v0\n\n\tv2 := v0\n\n\t# enemy type is a multiple of 8\n\tv3 := 0\n\t# It also is where the current movement step is stored so it has to exist\n\n\t# I guess maybe we have to loop this till we find an empty space?\n\t# Note that this should be a multiple of 16 in order to work\n\t: retry_get_empty_position\n\ti := long random_mob_position\n\tload v0\n\tv0 += 2\n\tif v0 == 200 then v0 := 0\n\ti := long random_mob_position\n\tsave v0\n\ti += v0\n\tload v1\n\t# next X Y coords loaded into v0 v1\n\t# Set the enemy to these coords\n\ti := long enemy_template_save_target\n\tsave v3\n\n\t# Check this cell is actaully available:\n\taddress_game_cell \n\t# If not:\n\tif v0 != -1 then jump retry_get_empty_position\n\n\t# If yes:\n\t# Register this enemy to this location:\n\n\ti := long game_grid\n\ti += v1\n\tv0 := vE\n\tsave v0\n\n\ti := long enemy_template\n\tload v7\n\n\ti := long enemy_list\n\ti += vE\n\tsave v7\n\t# We can now relocate enemy_template v7 to the new memory location\n\n\tjump enemy_created\n;\n\n: remove_enemy\n\t# v6 contains the enemy to remove as x8\n\ti := long enemy_list\n\ti += v6\n\n\t# This enemy should be defaulted out\n\tv0 := 5\n\ti += v0\n\tv0 := -1\n\tsave v0\n\n\t# additionally, there may be cells associated with it in game_grid\n\t# These need to be cleared out\n\n\tv1 := 0\n\ti := long game_grid\n\tloop\n\t\tload v0\n\n\t\tif v0 == v6 begin\n\t\t\ti := long game_grid\n\t\t\ti += v1\n\t\t\tv0 := -1\n\t\t\tsave v0\n\t\tend\n\t\tv1 += 1\n\t\tif v1 != 49 then\n\tagain\n;\n\n\n\n: address_game_cell\n\t# v0 := X pos\n\t# v1 := Y pos\n\tif v0 == 255 then jump bad_coord\n\tif v0 == 7 then jump bad_coord\n\tif v1 == 255 then jump bad_coord\n\tif v1 == 7 then jump bad_coord\n\n\ti := long game_grid_stride\n\ti += v1\n\tv1 := v0\n\tload v0\n\tv1 += v0\n\ti := long game_grid\n\ti += v1\n\tload v0\n;\n: bad_coord\n\tv0 := -2\n\t# v0 now has the value of this cell in it\n\t# v1 now has the relative index to this cell in it\n;\n\n: draw_obstacles\n\tv0 := 0\n\n\ti := 0x180\n\tsave vF\n\n\tplane 2\n\n\t:alias trash_counter v7\n\t:alias other_trash_counter v8\n\n\tmob_y := 0\n\tloop\n\t\tmob_x := 0\n\t\tloop\n\t\t\tv0 := mob_x\n\t\t\tv1 := mob_y\n\t\t\taddress_game_cell\n\n\t\t\t# v0 will be content\n\t\t\t# v1 will be offset from game_grid\n\n\t\t\tif v0 != -1 begin\n\t\t\t\tmob_type := 128\n\t\t\t\tmob_type += v0\n\t\t\t\tif vF == 1 begin\t\n\t\t\t\t\t# if the item was in the region at 128 or aboutve:\n\t\t\t\t\t# We know it's the index of something special\n\n\t\t\t\t\t# We probably want the x8 version of this index:\n\t\t\t\t\tv2 <<= mob_type # x2\n\t\t\t\t\tv2 <<= v2 # x4\n\t\t\t\t\tv2 <<= v2 # x8\n\n\t\t\t\t\t# NO HIT obsticles that must not be hit:\n\t\t\t\t\tif mob_type < 16 begin\n\t\t\t\t\t\tplane 2\n\t\t\t\t\t\t# furniture\n\t\t\t\t\t\tcalc_mob_draw_xy\n\t\t\t\t\t\ti := long furniture\n\t\t\t\t\t\ti += v2\n\n\t\t\t\t\t\tsprite mob_draw_x mob_draw_y 8\n\t\t\t\t\t\tjump draw_obstacles_pass_trash\n\t\t\t\t\tend\n\n\t\t\t\t\t# Trash items which must be cleared:\n\t\t\t\t\tif mob_type < 32 begin\n\t\t\t\t\t\tplane 1\n\t\t\t\t\t\tcalc_mob_draw_xy\n\n\t\t\t\t\t\tv0 := mob_draw_x\n\t\t\t\t\t\tv1 := mob_draw_y\n\t\t\t\t\t\ti := long quick_trash\n\t\t\t\t\t\ti += trash_counter\n\t\t\t\t\t\tsave v2\n\n\t\t\t\t\t\t# Draw it because that makes things simpler:\n\t\t\t\t\t\ti := long furniture\n\t\t\t\t\t\ti += v2\n\n\t\t\t\t\t\tsprite mob_draw_x mob_draw_y 8\n\n\t\t\t\t\t\tv2 := other_trash_counter\n\t\t\t\t\t\tcalc_trash_ui_pos\n\t\t\t\t\t\tsprite v0 v1 8\n\n\t\t\t\t\t\ttrash_counter += 3\n\t\t\t\t\t\tother_trash_counter += 1\n\t\t\t\t\tend\n\t\t\t\tend\n\n\t\t\t\t: draw_obstacles_pass_trash\n\t\t\t\tvF := 8\n\t\t\t\tf_delay\n\t\t\tend\n\n\t\t\tmob_x += 1\n\t\t\tif mob_x != 7 then\n\t\tagain\n\t\tmob_y += 1\n\t\tif mob_y != 7 then\n\tagain\n\n\n\n\tplane 1\n\n\ti := 0x180\n\tload vF\n;\n\n: calc_trash_ui_pos\n\t# v2 is trash index\n\tv0 := 98\n\tv1 := 8\n\tif v2 == 0 then jump skip_annoying_math\n\tloop\n\t\tv0 += 9\n\t\t:calc what_would_it_be { 98 + 3 * 9 }\n\t\tif v0 == what_would_it_be begin\n\t\t\tv1 += 9\n\t\t\tv0 := 98\n\t\tend\n\t\tv2 -= 1\n\t\tif v2 != 0 then\n\tagain\n\t: skip_annoying_math\n;\n\n: load_level\n\t# level is in... v0?\n\n\t# This is the stupid way of loading a level\n\ti := long levels_load\n\t# Stride in by 4x\n\ti += v0\n\ti += v0\n\ti += v0\n\ti += v0\n\t# Load v4 bytes\n\tload v3\n\n\ti := load_level_source_address\n\tsave v3\n\n\n\n\n\t# we need to read \n\tv9 := 0\n\tloop\n\t\ti := long level_reset_data\n\t\t#i += v9\n\t\tload v6\n\t\ti := game_grid\n\t\ti += v9\n\t\tsave v6\n\n\t\tv9 += 7\n\t\t:calc g_grid_plus_trash { 49 + 4 * 7 }\n\t\tif v9 != g_grid_plus_trash then\n\tagain\n\tv9 := 0\n\n\tloop\n\t\t: load_level_source_address\n\t\ti := long level_lr_1\n\t\ti += v9\n\t\tload v0\n\n\t\tif v0 == -1 then jump load_level_get_enemies\n\t\tv2 := v0\n\t\tload v1\n\t\tv9 += 3\n\n\t\t# v0 v1 x y, v2 obsticles\n\t\taddress_game_cell\n\t\ti := long game_grid\n\t\ti += v1\n\t\tv0 := v2\n\t\tsave v0\n\tagain\n\tv9 := 0\n\n\t: load_level_get_enemies\n\t# Also draws trash:\n\tdraw_obstacles\n\tv9 := 0\n;\n\n: level_select_mode\n\t# Captures gameplay and allows the player to select a level\n\n\tplane 3\n\tclear\n\tplane 1\n\n\ti := long wipey_wipe\n\tload vF\n\n\ti := long level_select_last\n\tload v3\n\n\t:alias total_levels_unlocked v8\n\t:alias total_levels_complete v9\n\t:alias current_chapter vA\n\t:alias current_level vB\n\t# v0: current level\n\t# v1: total levels unlocked\n\t# v2: total levels competed\n\t# v3: current chapter\n\tcurrent_level := v0\n\ttotal_levels_unlocked := v1\n\ttotal_levels_complete := v2\n\tcurrent_chapter := v3\n\n\ti := long mul_8\n\ti += current_chapter\n\tload v0\n\n\t# We now know where to index into chapters\n\n\t:alias chapter_offset v7\n\tchapter_offset := v0\n\n\tv6 := 0\n\n\t# First, draw the layout:\n\tmob_draw_x := 0\n\tmob_draw_y := 1\n\n\t:alias completed_levels_drawn v4\n\t:alias highest_current_level v5\n\tcompleted_levels_drawn := 0\n\thighest_current_level := 0\n\tloop\n\t\ti := long chapters\n\t\ti += chapter_offset\n\t\ti += v6\n\n\t\tload v0\n\t\t# What are we looking at here:\n\t\tif v0 == -1 begin\n\t\t\tmob_draw_x += 4\n\t\t\ti := long level_select_marker_first\n\t\t\tsprite mob_draw_x mob_draw_y  8\n\t\t\tmob_draw_x += 8\n\t\t\tjump lv_select_end_loop\n\t\tend\n\n\t\tif v0 >= 0x80 begin\n\t\t\tif v6 == 7 begin\n\t\t\t\tif completed_levels_drawn != 6 then\tjump lv_select_end_loop\n\t\t\tend\n\t\t\ti := long padded_line_h\n\t\t\tsprite mob_draw_x mob_draw_y 4\n\t\t\tmob_draw_x += 8\n\t\t\ti := long level_select_marker_next\n\t\t\tsprite mob_draw_x mob_draw_y  8\n\t\t\tmob_draw_x += 8\n\t\tend\n\n\t\tif v0 < total_levels_unlocked begin\n\t\t\t# This level is completed\n\t\t\ti := long padded_line_h\n\t\t\tsprite mob_draw_x mob_draw_y 4\n\t\t\tmob_draw_x += 8\n\t\t\ti := long level_select_marker\n\t\t\tsprite mob_draw_x mob_draw_y  8\n\n\t\t\tif v0 < total_levels_complete begin\n\t\t\t\tcompleted_levels_drawn += 1\n\t\t\t\ti := long level_select_complete\n\t\t\t\tsprite mob_draw_x mob_draw_y  8\n\t\t\tend\n\n\t\t\tmob_draw_x += 8\n\t\tend\n\n\t\thighest_current_level := v6\n\n\t\t: lv_select_end_loop\n\t\tv6 += 1\n\t\tif v6 != 8 then\n\tagain\n\n\thighest_current_level += 1\n\n\t: level_select_move_select_arrow\n\t# Actual select loop:\n\t# Use current 0 - 8 to select what we're looking at:\n\ti := long mul_8\n\ti += current_level\n\tload v0\n\tv0 += v0\n\tv0 += 4\n\tmob_draw_x := v0\n\tmob_draw_y := 9\n\ti := long level_select_pointer\n\tsprite mob_draw_x mob_draw_y  8\n\n\t#current_level\n\n\t: level_select_reject_input\n\ti := long level_select_pointer\n\tv0 := key\n\n\tif v0 == 7 begin\n\t\tsprite mob_draw_x mob_draw_y  8\n\t\t# Left\n\t\tcurrent_level += -1\n\t\tif current_level == -1 then current_level := 0\n\n\t\tjump level_select_move_select_arrow\n\tend\n\tif v0 == 9 begin\n\t\tsprite mob_draw_x mob_draw_y  8\n\t\t# Right\n\t\tcurrent_level += 1\n\n\t\ti := long chapters\n\t\ti += chapter_offset\n\t\ti += current_level\n\t\tload v0\n\n\t\tif v0 == total_levels_unlocked then current_level -= 1\n\n\t\tif current_level == highest_current_level then current_level -= 1\n\n\t\tif current_level == 8 then current_level := 7\n\n\n\t\tjump level_select_move_select_arrow\n\tend\n\tif v0 == 0xE begin\n\t\t# F\n\t\ti := chapters\n\t\ti += chapter_offset\n\t\ti += current_level\n\t\tload v0\n\n\t\tif v0 == -1 then jump level_select_reject_input\n\n\t\t# Change chapter\n\t\tif v0 >= 0x80 begin\n\t\t\tv0 -= 0x80\n\t\t\tcurrent_chapter := v0\n\n\t\t\tif current_level == 0 then current_level := 6\n\t\t\tif current_level == 7 then current_level := 1\n\t\t\tv0 := current_level\n\t\t\tv1 := total_levels_unlocked\n\t\t\tv2 := total_levels_complete\n\t\t\tv3 := current_chapter\n\n\t\t\ti := long level_select_last\n\t\t\tsave v3\n\t\t\tjump level_select_mode\n\t\tend\n\n\t\t# Otherwise we select this level:\n\n\t\tv1 := v0\n\n\t\ti := long level_select_last\n\t\tv0 := current_level\n\t\tsave v0\n\n\t\tv0 := v1\n\n\t\treturn\n\tend\n\tjump level_select_reject_input\n\n: reset_sweeps\n\tv0 := 0\n\ti := long sweeps_this_level\n\tsave v0\n\ti := long score_this_level\n\tsave v0\n\n\tdraw_sweeps\n\tdraw_score\n;\n\n: increase_sweeps\n\t\n\ti := long sweeps_this_level\n\tload v0\n\tv3 := v0\n\tdraw_sweeps\n\tv0 := v3\n\tv0 += 1\n\tif v0 == 11 then v0 := 10\n\ti := long sweeps_this_level\n\tsave v0\n\n\tdraw_sweeps\n;\n\n: draw_sweeps\n\tv1 := 28\n\tv2 := 56\n\tq_dig\n;\n\n: draw_score\n\ti := long score_this_level\n\tload v0\n\n\ti := 0x170\n\tbcd v0\n\n\tload v0\n\tv1 := 108\n\tv2 := 56\n\tq_dig\n\n\ti := 0x171\n\tload v0\n\tv1 += 6\n\tq_dig\n\n\ti := 0x172\n\tload v0\n\tv1 += 6\n\tq_dig\n\n\t:monitor 0x170 3\n;\n\n: q_dig\n\ti := mul_5\n\ti += v0\n\tload v0\n\ti := long fivewide_digits\n\ti += v0\n\tsprite v1 v2 5\n;\n\n# Ideally these will live in low memory\n: crosshair_a\n0b10100000\n0b00000000\n0b10100000\n\n: crosshair_b\n0b11100000\n0b11100000\n0b11100000\n\n:calc FREE { 4096 - HERE }\n: FREE_CODE_BYTES\n:byte { FREE >> 8 }\n:byte { FREE }\n:monitor FREE_CODE_BYTES \"%2i\"\n\n: fivewide_digits\n0x70 0x88 0x88 0x88 0x70 0x20 0x60 0x20 0x20 0xF8 0x70 0x88 0x30 0x40 0xF8 0xF0\n0x08 0x70 0x08 0xF0 0x30 0x50 0x90 0xF8 0x10 0xF8 0x80 0xF0 0x08 0xF0 0x70 0x80\n0xF0 0x88 0x70 0xF8 0x08 0x08 0x10 0x10 0x70 0x88 0x70 0x88 0x70 0x78 0x88 0xF8\n0x08 0x08 0x88 0x50 0x20 0x50 0x88 \n\n: sweeps_this_level\n0 \n\n: score_this_level\n0 0 0\n\n: wipey_wipe\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n: chapters\n-1    0  1  2  3  4  5 0x81\n0x80  6  7  8  9 10 11 0x82\n0x81 12 13 14 15 16 17 0x83\n0x82 18 19 20 21 22 23 0x84\n0x83 24 25 26 27 28 29 30\n\n: mul_5\n0 5 10 15 20 25 30 35 40 45 50 55 60\n\n: mul_6\n0\n6\n12\n18\n24\n30\n36\n42\n\n: level_select_last\n 1 1 0 0 0 0 0\n\n# Level number\t\t\t\t\t\tSweep Par\t\t\t\tPlayer Score Max \t\t\t\t\tPlayer Score Min\n# \t\t\t\tHas been completed\t\t\t  Player Sweeps Max\t\t\t\t  Player Sweeps Min\n:macro a_level_save X Y { X 0 Y 0  0 0 0 0 }\n\n: level_progress\na_level_save  0 4\na_level_save  1 4\na_level_save  2 4\na_level_save  3 4\na_level_save  4 4\na_level_save  5 4\na_level_save  6 4\na_level_save  7 4\na_level_save  8 4\na_level_save  9 4\na_level_save 10 4\na_level_save 11 4\n\n# Ironically it's much easier for us to define vertical columns in memory\n# I fixed it now the game grid makes sense\n: game_grid_stride\n0 7 14 21 28 35 42\n\n: game_grid\n-1 -1 -1 -1 -1 -1 -1\n-1 -1 -1 -1 -1 -1 -1\n-1 -1 -1 -1 -1 -1 -1\n-1 -1 -1 -1 -1 -1 -1\n-1 -1 -1 -1 -1 -1 -1\n-1 -1 -1 -1 -1 -1 -1\n-1 -1 -1 -1 -1 -1 -1\n\n: quick_trash # 7 x 4 items:\n0 0 0\t0 0 0\t0 0 0\t0 0 0\t0 0 0\t0 0 0\t0 0 0\t\n0 0 0   0 0 0   0\n\n# I would waste so much memory just writing out the levels\n# like this but at least I can see them and decide if they're good\n\n# These are 4 bytes:\n: levels_load\n# 0\n i := long level_lr_1\n i := long level_lr_2\n i := long level_lr_3\n i := long level_lr_4\n i := long level_lr_5\n i := long level_lr_6\n\n: enemies_load\n i := long level_lr_1_enemy\n i := long level_lr_2_enemy\n i := long level_lr_3_enemy\n i := long level_lr_4_enemy\n i := long level_lr_5_enemy\n i := long level_lr_6_enemy\n\n: level_reset_data\n-1\t\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t\t-1\n#-1\t\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t\t-1\n#-1\t\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t\t-1\n#-1\t\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t\t-1\n#-1\t\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t\t-1\n#-1\t\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t\t-1\n#-1\t\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t\t-1\n\n:macro ob x { :byte { 0x80 + x } }\n#\to_cat\t\t0\n#\to_bucket\t1\n#\to_chair_a\t2\n#\to_chair_b\t3\n#\to_drawer\t4\n#\to_brolly\t5\n#\to_table_a\t6\n#\to_table_b\t7\n#\to_bed_a\t\t8\n#\to_bed_b\t\t9\n#\to_cot\t\t10\n#\to_book_a\t11\n#\to_sofa_a\t12\n#\to_sofa_b\t13\n#\to_stand\t\t14\n#\to_book_b\t15\n\n:macro tr x { :byte { 0x90 + x } }\n# t_muck1 0\n# t_muck2 1\n# t_muck3 2\n# t_cobweb 3\n# t_puddle 4\n# t_trash 5\n# t_cutlery 6\n# t_crockery 7\n# ? 8 something for the cellar?\n# t_books1 9\n# t_books2 10\n# t_books3 11\n# t_shirt 12\n# t_robe 13\n# t_pillow 14\n# t_laundry 15\n\n: levels\n# Living Room 1\n: level_lr_1\nob 0\t1 2\nob 6\t6 5\n\ntr 0\t2 0\ntr 1    5 2\ntr 2\t3 4\ntr 3\t0 5\ntr 2\t6 6\n-1\n\n: level_lr_2\nob 1\t1 3\nob 4\t1 6\nob 5\t6 4\n\ntr 3\t4 4\ntr 4    1 1\ntr 1\t2 6\ntr 5\t4 2\n-1\n\n: level_lr_3\nob 0\t1\t5\nob 8\t5\t3\nob 9\t6\t3\nob 10\t6\t0\nob 10\t0\t2\n\ntr 10\t3\t2\ntr 3\t0\t2\ntr 2\t1\t3\ntr 13\t5\t4\n-1\n\n: level_lr_4\nob 7\t6\t5\nob 8\t0\t2\nob 9\t1\t2\nob 13\t1\t5\n\ntr 3\t2\t5\ntr 13\t2\t2\ntr 5\t4\t5\ntr 14\t4\t3\ntr 4\t5 \t6\ntr 7\t3\t1\n-1\n\n: level_lr_5\nob 14\t1\t1\nob 2\t1\t3\nob 12\t4\t6\nob 13\t5\t6\nob 3\t6\t2\nob 15\t4\t3\n\ntr 7\t3\t3\ntr 11\t6\t5\ntr 3\t1\t6\n-1\n\n\n: level_lr_6\nob 4\t5\t3\nob 5\t1\t4\nob 10\t6\t6\nob 11\t3\t2\nob 14\t4\t4\n\ntr 13\t3\t6\ntr 7\t1\t0\ntr 14\t3\t2\ntr 6\t6\t1\ntr 15\t1\t5\n-1\n\n\n\n#\t 0\t\t1\t\t2\t\t3\t\t4\t\t5\t\t6\n#\t-1\t\t-1\t\ta\t\t-1\t\t-1\t\t-1\t\t-1\t# 0\n#\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t# 1\n#\t-1\t\tx\t\t-1\t\t-1\t\t-1\t\ta\t\t-1\t# 2\n#\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t# 3\n#\t-1\t\t-1\t\t-1\t\ta\t\t-1\t\t-1\t\t-1\t# 4\n#\ta\t\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t\tx\t# 5\n#\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t\ta\t# 6\n\n#\t 0\t\t1\t\t2\t\t3\t\t4\t\t5\t\t6\n#\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t# 0\n#\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t# 1\n#\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t# 2\n#\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t# 3\n#\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t# 4\n#\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t# 5\n#\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t\t-1\t# 6\n\n: level_lr_1_enemy\n\t8\n\t\t8 0 0 0 8 8 0 8 \n\n: level_lr_2_enemy\n\t12\n\t\t8 8 16 32 24 16 24 8 16 24 32 32 \n\n: level_lr_3_enemy\n\t12\n\t\t40 40 24 24 24 32 24 32 0 0 24 24 \n\n: level_lr_4_enemy\n\t11\n\t\t56 32 0 56 0 0 56 32 32 32 56 \n\n: level_lr_5_enemy\n\t9\n\t\t16 24 40 40 24 16 16 16 40 \n\n: level_lr_6_enemy\n\t10\n\t\t64 48 64 16 16 48 48 16 64 64 \n\n# Let's decide that a level is defined in memory entirely as a grid\n# and we draw in obsticles with negative numbers\n\n\n: simple_axis_apply\n# 0000 # On axis: +X, off axis -Y\ncross_x += on_axis\ncross_y -= off_axis\n\n# 0010 # On axis: +X, off axis +Y\ncross_x += on_axis\ncross_y += off_axis\n\n# 0100 # On axis: +Y, off axis +X\ncross_y += on_axis\ncross_x += off_axis\n\n# 0110 # On axis: +Y, off axis -X\ncross_y += on_axis\ncross_x -= off_axis\n\n# 1000 # On axis: -X, off axis +Y\ncross_x -= on_axis\ncross_y += off_axis\n\n# 1010 # On axis: -X, off axis -Y\ncross_x -= on_axis\ncross_y -= off_axis\n\n# 1100 # On axis: -Y, off axis -X\ncross_y -= on_axis\ncross_x -= off_axis\n\n# 1110 # On axis: -Y, off axis +X\ncross_y -= on_axis\ncross_x += off_axis\n\n: padded_line_h\n0 0 0\n\n: line_h\n0xFF\n: line_h_2\n0b11000000\n\n: line_v\n0x80 0x80 0x80 0x80 0x80 0x80 0x80 0x80\n\n:macro fast_mob X { :byte { X * 8 } }\n\n\n: player_crosshair\n0x28 0x00 0x82 0x00 0x82 0x00 0x28 0x00 \n\n\n: use_crosshair\n0 0 0 0 0 0 0 0\n\n\n: mul_8\n: mob_spacing\n: grid_xy\n0x00 0x08 0x10 0x18 0x20 0x28 0x30 0x38\n0x40 0x48 0x50 0x58 0x60 0x68 0x70 0x78\n\n# 4x32 bytes = 128 bytes\n: brushable_mobs\n0x00 0x3C 0x70 0xB0 0x18 0x18 0x18 0x7E 0x00 0x00 0x1C 0x3E 0x2A 0x3E 0x3E 0x3E\n0x00 0x2C 0x7E 0x6A 0x3C 0x7E 0x5A 0x00 0x00 0x00 0x00 0x0C 0x04 0x0C 0x1E 0x3E\n0x00 0x00 0x00 0x3E 0x6B 0x7F 0x3E 0x3E 0x00 0x42 0x66 0x3C 0x18 0x00 0x00 0x00\n0x00 0x00 0x00 0x10 0x38 0x3D 0x1E 0x7E 0x00 0x00 0x00 0x00 0xFC 0x56 0x7E 0x1F\n0x00 0x28 0xFE 0x7C 0xD6 0x7C 0x28 0x00 0x3C 0xEB 0x7E 0xEB 0xAA 0xAA 0x6A 0x3C\n0x00 0x3E 0x2A 0x3E 0x10 0x10 0x38 0x7E 0x33 0x3F 0x7F 0xFF 0xC9 0xFF 0x3F 0x0E\n0x24 0x66 0xFF 0xDB 0xFF 0x66 0x24 0x00 0x00 0x18 0x18 0x18 0x18 0x18 0x3C 0x7E\n0x00 0x10 0x28 0x8A 0xCB 0xFF 0xBD 0xFF 0x3C 0x24 0x24 0x24 0x24 0x7E 0x5A 0x7E\n\n# And another 128 for their other frame:\n0x00 0x3C 0x0E 0x0D 0x18 0x18 0x18 0x7E 0x00 0x1C 0x3E 0x2A 0x3E 0x22 0x22 0x3E\n0x00 0x5A 0x3E 0x54 0x7E 0x3E 0x6C 0x00 0x00 0x00 0x0C 0x14 0x04 0x0E 0x1E 0x1E\n0x00 0x00 0x63 0x7F 0x2A 0x3E 0x3E 0x1C 0x00 0x00 0x00 0xC3 0x7E 0x18 0x00 0x00\n0x00 0x00 0x00 0x20 0x70 0x75 0x3E 0xFE 0x00 0x00 0x00 0x00 0x3E 0x6B 0xFE 0x7C\n0x00 0x28 0xFE 0x7C 0xD6 0x7C 0x44 0x00 0x18 0x7E 0x6A 0x3E 0x56 0x56 0x56 0x3C\n0x00 0x7C 0x54 0x7C 0x08 0x08 0x1C 0x7E 0x76 0x7E 0xFF 0xFF 0x49 0x7F 0x7E 0x38\n0x3C 0x7E 0x7E 0xDB 0x7E 0x7E 0x3C 0x00 0x00 0x18 0x18 0x18 0x18 0x3C 0x7E 0x3C\n0x18 0x04 0x49 0xCB 0xFF 0xBD 0xFF 0x42 0x3C 0x66 0x7E 0x7E 0x00 0x00 0x00 0x00\n\n: furniture\n0x00 0x00 0x20 0x4A 0x4E 0x7E 0x3E 0x00 0x18 0x24 0x24 0x3C 0x3C 0x3C 0x38 0x00\n0x10 0x30 0x30 0x3E 0x3E 0x36 0x36 0x24 0x1E 0x12 0x12 0x3E 0x7E 0x7E 0x5A 0x48\n0x3F 0x7F 0x43 0x7F 0x43 0x7F 0x43 0x7E 0x00 0x10 0x28 0x08 0x1C 0x1C 0x1C 0x18\n0x3F 0x7F 0xFF 0xA5 0xA5 0xA5 0xA5 0x84 0x00 0x00 0x3F 0x7E 0x08 0x1E 0x3C 0x00\n0x00 0x0F 0x1A 0x3F 0x40 0x7F 0x7F 0x7F 0x00 0xFE 0x4A 0xFE 0x06 0xFE 0xFE 0xFC\n0x00 0x20 0x60 0xFF 0xFF 0xFF 0xA5 0x84 0x7F 0xA9 0xA9 0xFF 0x95 0xD5 0xFF 0xAB\n0x00 0x0F 0x10 0x2F 0x5F 0x70 0x7F 0x60 0x00 0x3C 0xC2 0xFA 0xF6 0x1E 0xFE 0x0C\n0x18 0x1C 0x08 0x08 0x08 0x08 0x18 0x24 0xAB 0xFF 0xA5 0xA5 0xFF 0xD5 0xD5 0xFE\n\n: trash\n0x00 0x40 0x3C 0x70 0x4E 0x1E 0x08 0x00 0x00 0x34 0x6E 0x1C 0x66 0x38 0x68 0x00\n0x10 0x1C 0x36 0x74 0x6E 0x1E 0x32 0x02 0xF8 0xD7 0xAA 0xC4 0xAA 0x90 0xA8 0xC0\n0x6E 0xD9 0x82 0x42 0xC3 0x81 0x52 0x2C 0x00 0x14 0x08 0x1E 0x3F 0x7F 0x7F 0x7E\n0x00 0x00 0x2A 0x6E 0x64 0x24 0x24 0x00 0x00 0x06 0x09 0xAF 0xEF 0xED 0xAF 0xE6\n0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x38 0x4F 0x79 0x4F 0x79 0x7F 0x0E\n0x00 0x78 0x5E 0x52 0x56 0x72 0x1E 0x00 0x00 0x00 0x3C 0x24 0x2C 0x24 0x3C 0x00\n0x00 0x00 0x3E 0x49 0x6B 0x3A 0x2E 0x3E 0x00 0x36 0x7F 0x7F 0x3E 0x3E 0x3E 0x7F\n0x00 0x81 0x7E 0x4A 0x52 0x7E 0x81 0x00 0x00 0x14 0x08 0x3C 0x42 0x42 0x42 0x3C\n\n: trash_get # oversize 16x16 sprite because I hate work\n0xC1 0x80 0xE3 0x80 0x77 0x00 0x3E 0x00 0x1C 0x00 0x3E 0x00 0x77 0x00 0xE3 0x80\n0xC1 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00\n\n: qtex_clean\n0x7A 0x82 0x82 0x82 0x7B 0x0F 0x08 0x0E 0x08 0xEF 0x88 0x14 0x22 0x3E 0xA2 0x88\n0xCA 0xA8 0x9A 0x88\n\n: qtex_sweep\n0x7A 0x82 0x72 0x0A 0xF1 0x2F 0xA8 0xAF 0xA8 0x4F 0xBE 0x20 0x3C 0x20 0xBE 0xF0\n0x88 0xF0 0x80 0x80\n\n: qtex_rank\n0xF0 0x89 0xF2 0x93 0x8A 0x88 0x4C 0x2A 0xE9 0x28 0xA2 0xA4 0xB8 0xA4 0xA2 0x00\n0x00 0x00 0x00 0x00 \n\n: qtex_score\n0x79 0x82 0x72 0x0A 0xF1 0xE7 0x08 0x08 0x08 0xE7 0x3C 0xA2 0xBC 0xA4 0x22 0xF8\n0x80 0xF0 0x80 0xF8\n\n: block_cube\n0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF \n\n:macro enemy_framework X Y T { 16 0 1 X Y T \n\t\t:byte { T * 16 } \n\t\t0 }\n\n: enemy_template\n16 0 -1 \n\t   : enemy_template_save_target\n\t   0 0 0 0 \n\t   \t\t   1\n\n:monitor enemy_template 8\n\n: enemy_list_wipe\nenemy_framework 0 0 -1\n\n: enemy_fast_wipe\n0 0 0 -1 0 0 0 0\n\n\n: enemy_fast_redraw\n 0 0 0 -1 0 0 0 0\n 0 0 0 -1 0 0 0 0\n 0 0 0 -1 0 0 0 0\n 0 0 0 -1 0 0 0 0\n\n 0 0 0 -1 0 0 0 0\n 0 0 0 -1 0 0 0 0\n 0 0 0 -1 0 0 0 0\n 0 0 0 -1 0 0 0 0\n\n: enemy_list\nenemy_framework 1 5 -1\nenemy_framework 1 1 -1\nenemy_framework 2 1 -1\nenemy_framework 3 1 -1\nenemy_framework 1 2 -1\nenemy_framework 2 2 -1\nenemy_framework 3 2 -1\nenemy_framework 1 3 -1\n\n\n\t: test_enemy\n\t# Imagine an enemy:\n\t# We can definitely go to 8\n#   0 1   2   3 4 5   6 7 8\n#   Move type\n\t# move frame\n\t0 0 # F\n\t\t  1 # X Y T\n\t\t      2 2 0\n\t\t      \t  # M N\n\t\t      \t    0 0\n\n# These are the enemy behavior types that exist\n# Each behavior is ?? bytes. Maybe 8\n\n# We also have conditionals\n# 0: Progress regardless\n# 1: Repeat until impossible\n# 2: Retry until successful\n\n\n: enemy_behaviors\n# 0 Wiggler\n# Movement Pattern\n\t# Move sideways one step, then move the other way one subpx_step\n\t16 0 48 0 \t-1 0 0 0 \t0 0 0 0  0 0 0 0 \n# 1 Chompo\n\t# move down, wait, move up, wait\n\t32 0 0 0 \t64 0 0 0 \t-1 0 0 0 0 0 0 0\n# 2 Skulkulon\n\t# Move one way, then the other\n\t16 1 48 1\t-1 0 0 0\t0 0 0 0\t 0 0 0 0\n# 3 Snaker\n\t# Legit just does nothing\n\t0 0 -1 0\t0 0 0 0\t\t0 0 0 0\t 0 0 0 0\n\n# 4 Angero\n\t# T shape\n\t16 0 64 0\t32 0 16 0\t48 0 64 0  32 0 48 0\n\n# 5 Batato\n\t# Moves randomly then stops then random again\n\t-2 0 0 0\t-1 0 0 0\t\t0 0 0 0\t 0 0 0 0\n\n# 6 Sneil\n\t# Occasionally moves sideways\n\t0 0 0 0\t   16 0 0 0\t\t0 0 0 0\t 48 0 0 0\n\n# 7 Limbox\n\t# Diagnoals\n\t0x50 1 0x60 1\t0x70 1 0x80 1\t\t-1 0 0 0\t 0 0 0 0\n\n# 8 Pincing\n\t# Sneaks down then swoops back up\n\t32 0 0 0\t32 0 0 0\t\t32 0 64 2\t 64 2 64 2\n\n# 9 Borkus\n\t# Fully Random All the time\n\t-2 0 -1 0\t0 0 0 0\t\t0 0 0 0\t 0 0 0 0\n\n# 10 Neck King\n\t# Moves up then moves down\n\t64 1 32 1\t-1 0 0 0\t\t0 0 0 0\t 0 0 0 0\n\n# 11 Blurbinger\n\t# Does a cool little diagonal dance\n\t0x50 0 64 0\t0x60 0 64 0\t\t-2 0 -2 0\t -1 0 0 0\n\n# 12 Blade-o\n# Moves really fast horizontally\n\t16 1 48 1\t-1 0 0 0\t0 0 0 0\t 0 0 0 0\n\n# 13 Plunge\n# Fast vertical movement\n\t64 1 32 1\t-1 0 0 0\t0 0 0 0\t 0 0 0 0\n\n# 14 Catbox\n\t# Cross shape\n\t16 0 48 0   64 0 32 0\t48 0 16 0 \t32 0 64 0\n\n# 15 Skulligmite\n\t# Goes around in circles\n\t64 1 48 1  32 1 16 1 \t-1 0 0 0 \t0 0 0 0 \n\n: default_mob_datas\n# 0 Wiggler\n\t1 0 0 0 0 0 0 0\n# 1 Chompo\n\t2 0 0 0 0 0 0 0\n# 2 Skulkulon\n\t2 0 0 0 0 0 0 0\n# 3 Snaker\n\t2 0 0 0 0 0 0 0\n# 4 Angero\n\t4 0 0 0 0 0 0 0\n# 5 Batato\n\t2 0 0 0 0 0 0 0\n# 6 Sneil\n\t4 0 0 0 0 0 0 0\n# 7 Limbox\n\t2 0 0 0 0 0 0 0\n# 8 Pincing\n\t1 0 0 0 0 0 0 0\n# 9 Borkus\n\t2 0 0 0 0 0 0 0\n# 10 Neck King\n\t2 0 0 0 0 0 0 0\n# 11 Blurbinger\n\t3 0 0 0 0 0 0 0\n# 12 Blade-o\n\t1 0 0 0 0 0 0 0\n# 13 Plunge\n\t1 0 0 0 0 0 0 0\n# 14 Catbox\n\t1 0 0 0 0 0 0 0\n# 15 Skulligmite\n\t2 0 0 0 0 0 0 0\n\t\n\n:const movement_length 16\n\n# it's me! Using macros! Hooray!\n:macro mpat_s X Y A {\n\t:byte { X * A }\n\t:byte { Y * A }\n}\n:macro mpat_8 X Y { \n \tmpat_s X Y 1\n \tmpat_s X Y 2\n \tmpat_s X Y 3\n \tmpat_s X Y 4\n \tmpat_s X Y 5\n \tmpat_s X Y 6\n \tmpat_s X Y 7\n \tmpat_s X Y 8\n}\n\n# These will generate eg 1 2 3 4 5 6 7 8 X Y coords for how to move an object per frame\n: movement_patterns\n# 0\nmpat_8  0  0\n\n# 1\nmpat_8  1  0\n# 2\nmpat_8  0  1\n# 3\nmpat_8 -1  0\n# 4\nmpat_8  0 -1\n\n# 5\nmpat_8  1  1\n# 6\nmpat_8 -1  1\n# 7\nmpat_8 -1 -1\n# 8\nmpat_8  1 -1\n\n\n: random_mob_position\n\t0\n\t2 1\t3 4\t1 5\t1 4\n\t4 4\t1 3\t3 3\t4 2\n\t2 3\t1 2\t5 3\t1 1\n\t3 2\t3 5\t4 3\t5 5\n\t4 5\t5 2\t3 1\t4 1\n\t2 4\t2 2\t5 4\t2 5\n\t5 1\t5 5\t5 3\t1 1\n\t3 4\t2 2\t5 1\t3 2\n\t4 2\t1 4\t2 4\t2 1\n\t2 5\t1 2\t4 1\t4 5\n\t4 3\t5 4\t1 3\t4 4\n\t5 2\t3 3\t2 3\t1 5\n\t3 1\t3 5\t3 2\t4 2\n\t4 5\t2 4\t4 4\t5 5\n\t5 3\t4 1\t3 5\t2 5\n\t2 2\t1 1\t3 1\t1 3\n\t1 2\t5 2\t1 5\t3 4\n\t2 3\t5 4\t2 1\t3 3\n\t5 1\t4 3\t1 4\t2 4\n\t3 5\t2 1\t5 1\t2 2\n\t5 4\t1 1\t3 2\t3 4\n\t5 5\t1 3\t1 2\t1 5\n\t2 5\t4 1\t4 5\t1 4\n\t4 2\t3 3\t5 3\t4 4\n\t3 1\t5 2\t2 3\t4 3\n\n\n: level_select_marker\n0x38 0x44 0x82 0x82 0x82 0x44 0x38 0x00\n: level_select_complete\n0x00 0x00 0x10 0x38 0x10 0x00 0x00 0x00\n: level_select_pointer\n0x10 0x38 0x7C 0x10 0x10 0x10 0x00 0x00\n\n: level_select_marker_first\n0x38 0x44 0xBA 0xBF 0xBA 0x44 0x38 0x00 \n\n: level_select_marker_prev\n0x38 0x54 0xB2 0xFE 0xB2 0x54 0x38 0x00\n\n: level_select_marker_next\n0x38 0x54 0x9A 0xFE 0x9A 0x54 0x38 0x00 \n\n: level_select_marker_final\n0x38 0x44 0xBA 0xFA 0xBA 0x44 0x38 0x00\n\n: ringus\n0x07 0xE0 0x1F 0xF8 0x3F 0xFC 0x7C 0x3E 0x70 0x0E 0xF0 0x0F 0xE0 0x07 0xE0 0x07\n0xE0 0x07 0xE0 0x07 0xF0 0x0F 0x70 0x0E 0x7C 0x3E 0x3F 0xFC 0x1F 0xF8 0x07 0xE0\n\n\n: sweeper_walk_broom\n0x00 0x00 0xAA 0x00 0xFE 0x00 0x7C 0x00 0x10 0x00 0x13 0xE0 0x17 0xF0 0x17 0x50\n0x17 0x50 0x13 0xF0 0x1F 0xE0 0x1F 0xC0 0x1F 0xE0 0x17 0xE0 0x17 0xE0 0x3F 0xF0\n0xAA 0x00 0xFE 0x00 0x7C 0x00 0x10 0x00 0x10 0x00 0x13 0xE0 0x17 0xF0 0x17 0x50\n0x17 0x50 0x1F 0xF0 0x1F 0xE0 0x1F 0xC0 0x17 0xE0 0x17 0xE0 0x3F 0xF0 0x1F 0xF0\n0x55 0x00 0x7F 0x00 0x3E 0x00 0x08 0x00 0x08 0x00 0x09 0xF0 0x0B 0xF8 0x0B 0xA8\n0x0B 0xA8 0x0F 0xF8 0x0F 0xF0 0x0F 0xE0 0x0F 0xE0 0x0F 0xF0 0x1F 0xF0 0x3F 0xF8\n0x00 0x00 0x55 0x00 0x7F 0x00 0x3E 0x00 0x08 0x00 0x09 0xF0 0x0B 0xF8 0x0B 0xA8\n0x0B 0xA8 0x09 0xF8 0x0F 0xF0 0x0F 0xE0 0x0F 0xE0 0x0F 0xF0 0x0F 0xF0 0x1F 0xF0\n\n: sweeper_platform_a\n0b00011111\n\n##################################\n\n# Yeah ok, so I wanted to try and use macros and calc to work out things.\n# But because I have to put them at the end of my rom, and I can't forward reference them\n# Like I can't put a label at the end here, do a calc of that + 128, and use it earlier in the program\n# I genuinely have no idea how they bahave, or what tehy're going to do\n# So, I just can't use them\n\n# This did work but I'm replacing it with a fixed data table because I don't know how it would impact the labels\n# I wanted to use that would follow it:\n#:macro d0     X { X X X X X }\n#:macro do-45 X { d0 X d0 X d0 X d0 X d0 X d0 X d0 X d0 X d0 X }\n#:macro tan-entry {\n#\t:byte { 256 * tan ( ( HERE - tan_table ) * PI / 180 ) }\n#}\n#: tan_table\n#\tdo-45 tan-entry\n\n: tan_table # 46 bytes that represent subpixels on the offaxis when incrimenting adjacent by 1\n 0x00 0x04 0x08 0x0D 0x11 0x16 0x1A 0x1F \n 0x23 0x28 0x2D 0x31 0x36 0x3B 0x3F 0x44 \n 0x49 0x4E 0x53 0x58 0x5D 0x62 0x67 0x6C \n 0x71 0x77 0x7C 0x82 0x88 0x8D 0x93 0x99 \n 0x9F 0xA6 0xAC 0xB3 0xB9 0xC0 0xC8 0xCF \n 0xD6 0xDE 0xE6 0xEE 0xF7 0xFF \n\n: quick_tan # This will be 90 bytes of address information that will correspond with the memory address of \n\t\t\t# saved off axis positions and subpixels for all rotations from 0 to 45\n\t\t\t# This allows us to load I with quick_tan, add r (0-45) * 2, pull the address\n\t\t\t# set I to that vlaue, and then I += main axis length, and get the off axis\n\n\t\t\t# Obviously we're going to generate this with code\n\t\t\t# So here come the 0s!\n 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 # 32\n 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 # 64\n 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0  0 0 # 90\n\n# Yep you guessed it:\n: quick_sub\n 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 # 32\n 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 # 64\n 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0  0 0 # 90\n\n : quick_off_axis\n 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 # 32\n 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 # 64\n 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0  0 0 # 90\n # And then two more, for 45\n 0 0\n\n: register_dump\n 0 0 0 0 0 0 0 0 \n 0 0 0 0 0 0 0 0 \n\n:monitor register_dump 16\n:monitor game_grid 49\n\n\n: quick_tan_table\n \t# This will be a ~ 5kb data structure of all our data\n\n:calc probably_offaxis_data { quick_tan_table + 44 * 128 }\n#:monitor quick_off_axis 90\n\n:monitor sweeps_this_level 2\n:monitor level_select_last 4","options":{"tickrate":500,"fillColor":"#000000","fillColor2":"#888888","blendColor":"#000000","backgroundColor":"#FFFFFF","buzzColor":"#666666","quietColor":"#000000","shiftQuirks":false,"loadStoreQuirks":false,"vfOrderQuirks":false,"clipQuirks":false,"vBlankQuirks":false,"jumpQuirks":false,"screenRotation":0,"maxSize":65024,"touchInputMode":"swipe","logicQuirks":false,"fontStyle":"octo","displayScale":"4"},"rom":[192,126,240,0,20,36,240,85,39,30,39,102,0,255,240,0,17,132,247,101,104,8,240,0,17,140,247,85,120,255,56,0,18,26,240,0,17,124,247,101,104,8,240,0,17,204,247,85,120,255,56,0,18,46,42,179,162,117,240,85,243,1,0,224,241,1,0,255,172,138,255,101,36,49,111,16,39,20,240,0,21,69,96,8,97,8,208,16,240,0,21,197,96,0,113,16,208,17,240,0,14,210,112,8,208,17,112,8,208,17,112,8,208,17,43,219,96,0,42,99,109,64,108,32,107,0,106,2,35,153,37,46,128,160,130,176,200,15,120,4,180,235,96,0,224,158,18,150,112,1,102,0,96,14,224,161,21,80,133,208,96,7,224,161,125,255,96,9,224,161,125,1,93,80,118,1,133,192,96,5,224,161,124,255,96,8,224,161,124,1,92,80,118,1,70,0,18,214,77,38,125,1,77,89,125,255,76,6,124,1,76,57,124,255,133,176,96,4,224,161,123,255,96,6,224,161,123,1,149,176,19,12,118,1,59,45,18,248,107,0,122,2,74,16,106,0,37,46,59,255,19,6,107,44,122,254,74,254,106,14,37,46,128,160,130,176,180,235,35,153,163,150,240,101,112,8,48,64,19,48,163,151,192,3,112,252,64,255,96,253,193,3,113,252,65,255,97,253,241,85,96,0,121,128,163,150,240,85,54,0,19,60,35,153,19,96,56,0,120,255,35,209,35,189,163,179,244,85,172,74,57,0,172,71,208,19,35,201,35,195,163,184,244,85,172,71,57,0,172,74,208,19,39,220,72,1,19,106,56,0,19,120,163,151,241,101,240,0,14,220,128,212,129,196,208,24,111,1,39,20,72,1,19,136,56,0,19,138,200,15,120,4,208,24,120,255,240,0,23,4,255,85,18,142,18,0,0,0,0,163,179,241,101,172,74,57,0,172,71,208,19,163,184,241,101,172,71,57,0,172,74,208,19,0,238,91,31,28,0,0,34,31,29,0,0,143,240,143,240,0,238,143,240,143,240,0,238,128,160,111,8,128,243,179,225,128,160,179,225,130,16,128,208,112,255,129,192,113,255,0,238,20,1,20,1,20,13,20,13,20,7,20,7,20,19,20,19,20,43,20,37,20,25,20,31,20,37,20,43,20,31,20,25,99,92,131,213,179,241,131,208,115,221,179,241,99,60,131,197,179,241,131,192,115,253,179,241,100,92,132,213,20,151,132,208,116,221,20,151,100,60,132,197,20,151,132,192,116,253,20,151,96,35,97,3,98,60,174,210,208,17,208,33,112,8,48,91,20,57,174,211,208,17,208,33,96,35,97,92,98,4,174,212,208,40,209,40,114,8,50,60,20,81,96,95,97,1,240,0,17,28,36,133,96,3,97,29,240,0,17,48,36,133,96,3,97,56,240,0,17,68,36,133,96,96,97,50,240,0,17,88,36,133,0,238,98,0,99,5,208,21,112,8,114,1,243,30,50,4,20,137,0,238,98,0,50,0,20,163,100,0,97,128,19,213,50,45,20,187,97,128,143,64,143,53,79,0,131,64,143,48,143,69,79,0,132,48,20,227,240,0,23,20,243,30,243,30,241,101,133,0,143,64,143,85,63,0,20,225,133,64,240,0,0,0,244,30,240,101,143,48,143,7,79,0,131,0,132,80,19,213,240,0,0,0,0,238,20,252,21,0,20,252,21,0,20,252,21,0,20,252,21,0,0,97,45,130,23,128,32,164,251,240,85,240,0,21,244,242,30,242,30,241,101,164,189,241,85,240,0,22,168,242,30,242,30,241,101,164,211,241,85,164,231,241,85,128,32,164,152,240,85,19,12,142,160,142,164,240,0,14,175,254,30,243,101,163,189,243,85,111,16,142,243,240,0,14,175,254,30,243,101,163,195,243,85,0,238,194,1,66,0,163,68,66,1,163,84,241,101,166,176,241,85,66,0,163,82,66,1,163,66,241,101,166,206,241,85,43,239,163,181,241,101,163,187,240,101,129,4,134,16,118,255,164,251,240,101,240,0,21,198,240,30,240,101,133,0,110,0,161,128,255,85,109,0,240,0,12,134,91,179,111,10,139,247,103,1,104,0,38,176,55,2,21,170,21,252,39,18,101,1,38,16,77,0,107,0,38,106,241,1,44,19,240,0,12,135,240,101,128,212,240,0,12,135,240,85,44,19,55,0,21,252,96,4,97,2,241,24,111,10,39,20,112,255,48,0,21,210,240,10,162,117,240,101,138,0,240,0,12,215,243,101,122,1,130,160,122,1,129,160,240,0,12,215,243,85,18,14,161,128,246,101,103,0,88,96,38,176,161,128,255,101,241,1,19,98,0,0,102,0,101,0,103,0,242,1,240,0,13,118,246,30,242,101,66,255,22,96,119,1,240,0,15,252,242,30,208,24,142,240,208,24,78,0,22,96,119,255,241,1,208,24,141,180,59,0,123,1,130,80,42,73,112,255,113,255,240,0,16,252,242,1,208,16,240,0,13,194,242,101,240,0,13,118,246,30,242,85,118,3,117,1,54,27,22,24,0,238,102,0,242,1,240,0,17,140,246,30,243,101,67,255,22,168,240,0,14,252,242,30,208,24,142,240,208,24,62,0,22,140,22,168,141,180,59,0,123,1,241,1,208,24,242,1,240,0,17,132,243,101,240,0,17,140,246,30,243,85,41,119,118,8,54,64,22,110,0,238,163,184,242,101,112,1,113,1,111,255,130,243,114,1,242,1,99,1,100,0,130,84,63,0,100,1,69,255,100,1,35,189,174,212,208,17,71,0,111,0,79,0,23,0,99,5,100,4,136,96,243,1,0,209,244,24,111,4,39,20,115,255,0,193,111,4,39,20,51,0,22,228,242,1,208,17,103,2,0,238,126,64,62,0,23,8,39,18,118,255,86,128,22,192,241,1,0,238,111,1,255,21,255,7,63,0,23,22,0,238,107,1,240,0,21,198,251,30,240,101,240,0,23,20,97,128,99,0,133,0,96,0,241,85,129,84,63,0,112,1,115,1,51,64,23,52,167,42,241,101,240,0,21,244,253,30,251,30,251,30,241,85,98,128,129,36,63,0,112,1,167,42,241,85,123,1,59,45,23,32,0,238,107,1,167,42,241,101,167,130,241,85,240,0,21,198,251,30,240,101,133,0,96,0,100,0,98,0,240,0,0,0,240,85,112,1,130,84,79,0,23,146,240,85,116,1,48,63,23,134,240,85,116,1,96,255,240,85,116,1,167,130,241,101,240,0,22,168,251,30,251,30,241,85,129,68,128,244,167,130,241,85,123,1,59,45,23,214,167,204,241,85,240,0,22,168,251,30,251,30,241,85,240,0,0,0,96,0,97,1,98,2,241,85,59,45,23,112,0,238,163,150,240,101,240,0,17,204,240,30,142,0,247,101,69,255,25,33,161,128,255,85,138,0,137,16,50,255,24,0,98,0,105,16,24,70,240,0,17,140,254,30,241,101,174,252,245,30,242,30,208,24,114,128,119,255,55,0,24,38,240,0,19,20,245,30,96,0,240,101,135,0,121,2,57,16,24,182,74,0,24,70,128,48,129,64,41,163,240,0,13,69,241,30,96,255,240,85,105,0,41,12,131,4,132,20,104,0,120,1,72,6,24,136,70,16,102,0,240,0,18,20,245,30,245,30,246,30,241,101,48,255,24,102,102,0,24,72,138,0,142,16,58,254,24,114,202,48,122,16,74,0,24,176,105,0,41,12,128,52,129,68,41,163,64,255,24,160,62,0,24,142,110,0,106,0,118,2,62,1,24,150,118,2,24,72,62,2,24,160,106,0,64,254,118,2,48,255,24,180,163,150,240,101,240,0,13,69,241,30,240,85,62,1,118,2,105,0,40,246,41,12,128,212,129,196,168,244,241,85,240,0,14,252,245,30,242,30,208,24,163,150,240,101,240,0,17,204,240,30,142,0,128,160,129,144,247,85,168,244,241,101,130,84,131,80,240,0,17,140,254,30,243,85,161,128,255,101,0,238,0,0,174,236,243,30,240,101,141,0,174,236,244,30,240,101,140,0,125,36,124,4,0,238,96,0,97,0,74,0,0,238,240,0,19,148,250,30,249,30,241,101,0,238,248,169,32,240,101,112,8,64,128,96,0,207,15,63,0,0,238,169,32,240,85,130,0,99,0,240,0,20,36,240,101,112,2,64,200,96,0,240,0,20,36,240,85,240,30,241,101,240,0,17,119,243,85,41,163,48,255,25,57,240,0,13,69,241,30,128,224,240,85,240,0,17,116,247,101,240,0,17,204,254,30,247,85,23,238,0,238,240,0,17,204,246,30,96,5,240,30,96,255,240,85,97,0,240,0,13,69,240,101,80,96,25,155,240,0,13,69,241,30,96,255,240,85,113,1,49,49,25,139,0,238,64,255,25,201,64,7,25,201,65,255,25,201,65,7,25,201,240,0,13,62,241,30,129,0,240,101,129,4,240,0,13,69,241,30,240,101,0,238,96,254,0,238,96,0,161,128,255,85,242,1,100,0,99,0,128,48,129,64,41,163,64,255,26,53,101,128,133,4,63,1,26,49,130,94,130,46,130,46,111,16,143,87,63,0,26,7,242,1,40,246,240,0,15,252,242,30,221,200,26,49,111,32,143,87,63,0,26,49,241,1,40,246,128,208,129,192,240,0,13,118,247,30,242,85,240,0,15,252,242,30,221,200,130,128,42,73,208,24,119,3,120,1,111,8,39,20,115,1,51,7,25,217,116,1,52,7,25,215,241,1,161,128,255,101,0,238,96,98,97,8,66,0,26,97,112,9,48,125,26,91,113,9,96,98,114,255,50,0,26,81,0,238,240,0,13,146,240,30,240,30,240,30,240,30,243,101,170,139,243,85,105,0,240,0,13,194,246,101,173,69,249,30,246,85,121,7,57,77,26,119,105,0,240,0,13,201,249,30,240,101,64,255,26,173,130,0,241,101,121,3,41,163,240,0,13,69,241,30,128,32,240,85,26,139,105,0,41,205,105,0,0,238,243,1,0,224,241,1,240,0,12,138,255,101,240,0,12,215,243,101,139,0,136,16,137,32,138,48,240,0,14,236,250,30,240,101,135,0,102,0,109,0,108,1,100,0,101,0,240,0,12,154,247,30,246,30,240,101,48,255,26,251,125,4,240,0,21,5,221,200,125,8,27,69,111,128,143,7,79,0,27,27,54,7,27,11,52,6,27,69,240,0,14,207,221,196,125,8,240,0,21,21,221,200,125,8,143,128,143,7,63,0,27,67,240,0,14,207,221,196,125,8,240,0,20,237,221,200,143,144,143,7,63,0,27,65,116,1,240,0,20,245,221,200,125,8,133,96,118,1,54,8,26,225,117,1,240,0,14,236,251,30,240,101,128,4,112,4,141,0,108,9,240,0,20,253,221,200,240,0,20,253,240,10,48,7,27,119,221,200,123,255,75,255,107,0,27,77,48,9,27,151,221,200,123,1,240,0,12,154,247,30,251,30,240,101,144,128,123,255,155,80,123,255,75,8,107,7,27,77,48,14,27,217,172,154,247,30,251,30,240,101,64,255,27,99,111,128,143,7,79,0,27,203,112,128,138,0,75,0,107,6,75,7,107,1,128,176,129,128,130,144,131,160,240,0,12,215,243,85,26,179,129,0,240,0,12,215,128,176,240,85,128,16,0,238,27,99,96,0,240,0,12,134,240,85,240,0,12,135,240,85,44,11,44,19,0,238,240,0,12,134,240,101,131,0,44,11,128,48,112,1,64,11,96,10,240,0,12,134,240,85,44,11,0,238,97,28,98,56,44,55,0,238,240,0,12,135,240,101,161,112,240,51,240,101,97,108,98,56,44,55,161,113,240,101,113,6,44,55,161,114,240,101,113,6,44,55,0,238,172,194,240,30,240,101,240,0,12,79,240,30,209,37,0,238,160,0,160,224,224,224,3,179,112,136,136,136,112,32,96,32,32,248,112,136,48,64,248,240,8,112,8,240,48,80,144,248,16,248,128,240,8,240,112,128,240,136,112,248,8,8,16,16,112,136,112,136,112,120,136,248,8,8,136,80,32,80,136,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,1,2,3,4,5,129,128,6,7,8,9,10,11,130,129,12,13,14,15,16,17,131,130,18,19,20,21,22,23,132,131,24,25,26,27,28,29,30,0,5,10,15,20,25,30,35,40,45,50,55,60,0,6,12,18,24,30,36,42,1,1,0,0,0,0,0,0,0,4,0,0,0,0,0,1,0,4,0,0,0,0,0,2,0,4,0,0,0,0,0,3,0,4,0,0,0,0,0,4,0,4,0,0,0,0,0,5,0,4,0,0,0,0,0,6,0,4,0,0,0,0,0,7,0,4,0,0,0,0,0,8,0,4,0,0,0,0,0,9,0,4,0,0,0,0,0,10,0,4,0,0,0,0,0,11,0,4,0,0,0,0,0,0,7,14,21,28,35,42,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,240,0,13,201,240,0,13,223,240,0,13,245,240,0,14,17,240,0,14,48,240,0,14,76,240,0,14,107,240,0,14,116,240,0,14,129,240,0,14,142,240,0,14,154,240,0,14,164,255,255,255,255,255,255,255,128,1,2,134,6,5,144,2,0,145,5,2,146,3,4,147,0,5,146,6,6,255,129,1,3,132,1,6,133,6,4,147,4,4,148,1,1,145,2,6,149,4,2,255,128,1,5,136,5,3,137,6,3,138,6,0,138,0,2,154,3,2,147,0,2,146,1,3,157,5,4,255,135,6,5,136,0,2,137,1,2,141,1,5,147,2,5,157,2,2,149,4,5,158,4,3,148,5,6,151,3,1,255,142,1,1,130,1,3,140,4,6,141,5,6,131,6,2,143,4,3,151,3,3,155,6,5,147,1,6,255,132,5,3,133,1,4,138,6,6,139,3,2,142,4,4,157,3,6,151,1,0,158,3,2,150,6,1,159,1,5,255,8,8,0,0,0,8,8,0,8,12,8,8,16,32,24,16,24,8,16,24,32,32,12,40,40,24,24,24,32,24,32,0,0,24,24,11,56,32,0,56,0,0,56,32,32,32,56,9,16,24,40,40,24,16,16,16,40,10,64,48,64,16,16,48,48,16,64,64,128,52,129,69,128,52,129,68,129,52,128,68,129,52,128,69,128,53,129,68,128,53,129,69,129,53,128,69,129,53,128,68,0,0,0,255,192,128,128,128,128,128,128,128,128,40,0,130,0,130,0,40,0,0,0,0,0,0,0,0,0,0,8,16,24,32,40,48,56,64,72,80,88,96,104,112,120,0,60,112,176,24,24,24,126,0,0,28,62,42,62,62,62,0,44,126,106,60,126,90,0,0,0,0,12,4,12,30,62,0,0,0,62,107,127,62,62,0,66,102,60,24,0,0,0,0,0,0,16,56,61,30,126,0,0,0,0,252,86,126,31,0,40,254,124,214,124,40,0,60,235,126,235,170,170,106,60,0,62,42,62,16,16,56,126,51,63,127,255,201,255,63,14,36,102,255,219,255,102,36,0,0,24,24,24,24,24,60,126,0,16,40,138,203,255,189,255,60,36,36,36,36,126,90,126,0,60,14,13,24,24,24,126,0,28,62,42,62,34,34,62,0,90,62,84,126,62,108,0,0,0,12,20,4,14,30,30,0,0,99,127,42,62,62,28,0,0,0,195,126,24,0,0,0,0,0,32,112,117,62,254,0,0,0,0,62,107,254,124,0,40,254,124,214,124,68,0,24,126,106,62,86,86,86,60,0,124,84,124,8,8,28,126,118,126,255,255,73,127,126,56,60,126,126,219,126,126,60,0,0,24,24,24,24,60,126,60,24,4,73,203,255,189,255,66,60,102,126,126,0,0,0,0,0,0,32,74,78,126,62,0,24,36,36,60,60,60,56,0,16,48,48,62,62,54,54,36,30,18,18,62,126,126,90,72,63,127,67,127,67,127,67,126,0,16,40,8,28,28,28,24,63,127,255,165,165,165,165,132,0,0,63,126,8,30,60,0,0,15,26,63,64,127,127,127,0,254,74,254,6,254,254,252,0,32,96,255,255,255,165,132,127,169,169,255,149,213,255,171,0,15,16,47,95,112,127,96,0,60,194,250,246,30,254,12,24,28,8,8,8,8,24,36,171,255,165,165,255,213,213,254,0,64,60,112,78,30,8,0,0,52,110,28,102,56,104,0,16,28,54,116,110,30,50,2,248,215,170,196,170,144,168,192,110,217,130,66,195,129,82,44,0,20,8,30,63,127,127,126,0,0,42,110,100,36,36,0,0,6,9,175,239,237,175,230,0,0,0,0,0,0,0,0,0,56,79,121,79,121,127,14,0,120,94,82,86,114,30,0,0,0,60,36,44,36,60,0,0,0,62,73,107,58,46,62,0,54,127,127,62,62,62,127,0,129,126,74,82,126,129,0,0,20,8,60,66,66,66,60,193,128,227,128,119,0,62,0,28,0,62,0,119,0,227,128,193,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,122,130,130,130,123,15,8,14,8,239,136,20,34,62,162,136,202,168,154,136,122,130,114,10,241,47,168,175,168,79,190,32,60,32,190,240,136,240,128,128,240,137,242,147,138,136,76,42,233,40,162,164,184,164,162,0,0,0,0,0,121,130,114,10,241,231,8,8,8,231,60,162,188,164,34,248,128,240,128,248,255,255,255,255,255,255,255,255,16,0,255,0,0,0,0,1,16,0,1,0,0,255,240,0,0,0,0,255,0,0,0,0,0,0,0,255,0,0,0,0,0,0,0,255,0,0,0,0,0,0,0,255,0,0,0,0,0,0,0,255,0,0,0,0,0,0,0,255,0,0,0,0,0,0,0,255,0,0,0,0,0,0,0,255,0,0,0,0,0,0,0,255,0,0,0,0,16,0,1,1,5,255,240,0,16,0,1,1,1,255,240,0,16,0,1,2,1,255,240,0,16,0,1,3,1,255,240,0,16,0,1,1,2,255,240,0,16,0,1,2,2,255,240,0,16,0,1,3,2,255,240,0,16,0,1,1,3,255,240,0,0,0,1,2,2,0,0,0,16,0,48,0,255,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,64,0,0,0,255,0,0,0,0,0,0,0,16,1,48,1,255,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,16,0,64,0,32,0,16,0,48,0,64,0,32,0,48,0,254,0,0,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,48,0,0,0,80,1,96,1,112,1,128,1,255,0,0,0,0,0,0,0,32,0,0,0,32,0,0,0,32,0,64,2,64,2,64,2,254,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,64,1,32,1,255,0,0,0,0,0,0,0,0,0,0,0,80,0,64,0,96,0,64,0,254,0,254,0,255,0,0,0,16,1,48,1,255,0,0,0,0,0,0,0,0,0,0,0,64,1,32,1,255,0,0,0,0,0,0,0,0,0,0,0,16,0,48,0,64,0,32,0,48,0,16,0,32,0,64,0,64,1,48,1,32,1,16,1,255,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,2,0,3,0,4,0,5,0,6,0,7,0,8,0,0,1,0,2,0,3,0,4,0,5,0,6,0,7,0,8,255,0,254,0,253,0,252,0,251,0,250,0,249,0,248,0,0,255,0,254,0,253,0,252,0,251,0,250,0,249,0,248,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,255,1,254,2,253,3,252,4,251,5,250,6,249,7,248,8,255,255,254,254,253,253,252,252,251,251,250,250,249,249,248,248,1,255,2,254,3,253,4,252,5,251,6,250,7,249,8,248,0,2,1,3,4,1,5,1,4,4,4,1,3,3,3,4,2,2,3,1,2,5,3,1,1,3,2,3,5,4,3,5,5,4,5,5,2,3,1,4,1,2,4,2,2,5,4,2,5,5,1,5,5,5,3,1,1,3,4,2,2,5,1,3,2,4,2,1,4,2,4,2,1,2,5,1,2,4,1,4,5,4,3,5,4,1,3,4,4,5,2,3,3,2,3,1,5,3,1,3,5,3,2,4,2,4,5,2,4,4,4,5,5,5,3,4,1,3,5,2,5,2,2,1,1,3,1,1,3,1,2,5,2,1,5,3,4,2,3,5,4,2,1,3,3,5,1,4,3,1,4,2,4,3,5,2,1,5,1,2,2,5,4,1,1,3,2,3,4,5,5,1,3,1,2,1,5,2,5,4,1,4,5,1,4,4,2,3,3,5,3,4,4,3,1,5,2,2,3,4,3,56,68,130,130,130,68,56,0,0,0,16,56,16,0,0,0,16,56,124,16,16,16,0,0,56,68,186,191,186,68,56,0,56,84,178,254,178,84,56,0,56,84,154,254,154,84,56,0,56,68,186,250,186,68,56,0,7,224,31,248,63,252,124,62,112,14,240,15,224,7,224,7,224,7,224,7,240,15,112,14,124,62,63,252,31,248,7,224,0,0,170,0,254,0,124,0,16,0,19,224,23,240,23,80,23,80,19,240,31,224,31,192,31,224,23,224,23,224,63,240,170,0,254,0,124,0,16,0,16,0,19,224,23,240,23,80,23,80,31,240,31,224,31,192,23,224,23,224,63,240,31,240,85,0,127,0,62,0,8,0,8,0,9,240,11,248,11,168,11,168,15,248,15,240,15,224,15,224,15,240,31,240,63,248,0,0,85,0,127,0,62,0,8,0,9,240,11,248,11,168,11,168,9,248,15,240,15,224,15,224,15,240,15,240,31,240,31,0,4,8,13,17,22,26,31,35,40,45,49,54,59,63,68,73,78,83,88,93,98,103,108,113,119,124,130,136,141,147,153,159,166,172,179,185,192,200,207,214,222,230,238,247,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}</script>
<script>"use strict";

function invertKeymap(k) {
	return Object.keys(k).reduce((a,b) => {
		Object.keys(k[b]).forEach(x => a[x]=+b)
		return a
	}, {})
}

function getPref(key) {
	try { return JSON.parse(localStorage.getItem(key)) }
	catch(e) { console.log(e); return null }
}
function setPref(key, value) {
	try { localStorage.setItem(key, JSON.stringify(value)) }
	catch(e) { console.log(e); }
}

var keymap = (this.STATIC_KEYMAP) || getPref('octoKeymap') || {
	0x0: { x:1 },
	0x1: { 1:1 },
	0x2: { 2:1 },
	0x3: { 3:1 },
	0x4: { q:1 },
	0x5: { w:1, ArrowUp:1 },
	0x6: { e:1, ' ':1 },
	0x7: { a:1, ArrowLeft:1 },
	0x8: { s:1, ArrowDown:1 },
	0x9: { d:1, ArrowRight:1 },
	0xA: { z:1 },
	0xB: { c:1 },
	0xC: { 4:1 },
	0xD: { r:1 },
	0xE: { f:1 },
	0xF: { v:1 },
}

var keymapInverse = invertKeymap(keymap)

var smallfonts = {
	octo: [
		0xF0, 0x90, 0x90, 0x90, 0xF0, // 0
		0x20, 0x60, 0x20, 0x20, 0x70, // 1
		0xF0, 0x10, 0xF0, 0x80, 0xF0, // 2
		0xF0, 0x10, 0xF0, 0x10, 0xF0, // 3
		0x90, 0x90, 0xF0, 0x10, 0x10, // 4
		0xF0, 0x80, 0xF0, 0x10, 0xF0, // 5
		0xF0, 0x80, 0xF0, 0x90, 0xF0, // 6
		0xF0, 0x10, 0x20, 0x40, 0x40, // 7
		0xF0, 0x90, 0xF0, 0x90, 0xF0, // 8
		0xF0, 0x90, 0xF0, 0x10, 0xF0, // 9
		0xF0, 0x90, 0xF0, 0x90, 0x90, // A
		0xE0, 0x90, 0xE0, 0x90, 0xE0, // B
		0xF0, 0x80, 0x80, 0x80, 0xF0, // C
		0xE0, 0x90, 0x90, 0x90, 0xE0, // D
		0xF0, 0x80, 0xF0, 0x80, 0xF0, // E
		0xF0, 0x80, 0xF0, 0x80, 0x80, // F
	],
	vip: [
		0xF0, 0x90, 0x90, 0x90, 0xF0,
		0x60, 0x20, 0x20, 0x20, 0x70,
		0xF0, 0x10, 0xF0, 0x80, 0xF0,
		0xF0, 0x10, 0xF0, 0x10, 0xF0,
		0xA0, 0xA0, 0xF0, 0x20, 0x20,
		0xF0, 0x80, 0xF0, 0x10, 0xF0,
		0xF0, 0x80, 0xF0, 0x90, 0xF0,
		0xF0, 0x10, 0x10, 0x10, 0x10,
		0xF0, 0x90, 0xF0, 0x90, 0xF0,
		0xF0, 0x90, 0xF0, 0x10, 0xF0,
		0xF0, 0x90, 0xF0, 0x90, 0x90,
		0xF0, 0x50, 0x70, 0x50, 0xF0,
		0xF0, 0x80, 0x80, 0x80, 0xF0,
		0xF0, 0x50, 0x50, 0x50, 0xF0,
		0xF0, 0x80, 0xF0, 0x80, 0xF0,
		0xF0, 0x80, 0xF0, 0x80, 0x80,
	],
	dream6800: [
		0xE0, 0xA0, 0xA0, 0xA0, 0xE0,
		0x40, 0x40, 0x40, 0x40, 0x40,
		0xE0, 0x20, 0xE0, 0x80, 0xE0,
		0xE0, 0x20, 0xE0, 0x20, 0xE0,
		0x80, 0xA0, 0xA0, 0xE0, 0x20,
		0xE0, 0x80, 0xE0, 0x20, 0xE0,
		0xE0, 0x80, 0xE0, 0xA0, 0xE0,
		0xE0, 0x20, 0x20, 0x20, 0x20,
		0xE0, 0xA0, 0xE0, 0xA0, 0xE0,
		0xE0, 0xA0, 0xE0, 0x20, 0xE0,
		0xE0, 0xA0, 0xE0, 0xA0, 0xA0,
		0xC0, 0xA0, 0xE0, 0xA0, 0xC0,
		0xE0, 0x80, 0x80, 0x80, 0xE0,
		0xC0, 0xA0, 0xA0, 0xA0, 0xC0,
		0xE0, 0x80, 0xE0, 0x80, 0xE0,
		0xE0, 0x80, 0xC0, 0x80, 0x80,
	],
	eti660: [
		0xE0, 0xA0, 0xA0, 0xA0, 0xE0,
		0x20, 0x20, 0x20, 0x20, 0x20,
		0xE0, 0x20, 0xE0, 0x80, 0xE0,
		0xE0, 0x20, 0xE0, 0x20, 0xE0,
		0xA0, 0xA0, 0xE0, 0x20, 0x20,
		0xE0, 0x80, 0xE0, 0x20, 0xE0,
		0xE0, 0x80, 0xE0, 0xA0, 0xE0,
		0xE0, 0x20, 0x20, 0x20, 0x20,
		0xE0, 0xA0, 0xE0, 0xA0, 0xE0,
		0xE0, 0xA0, 0xE0, 0x20, 0xE0,
		0xE0, 0xA0, 0xE0, 0xA0, 0xA0,
		0x80, 0x80, 0xE0, 0xA0, 0xE0,
		0xE0, 0x80, 0x80, 0x80, 0xE0,
		0x20, 0x20, 0xE0, 0xA0, 0xE0,
		0xE0, 0x80, 0xE0, 0x80, 0xE0,
		0xE0, 0x80, 0xC0, 0x80, 0x80,
	],
	fish: [
		0x60, 0xA0, 0xA0, 0xA0, 0xC0,
		0x40, 0xC0, 0x40, 0x40, 0xE0,
		0xC0, 0x20, 0x40, 0x80, 0xE0,
		0xC0, 0x20, 0x40, 0x20, 0xC0,
		0x20, 0xA0, 0xE0, 0x20, 0x20,
		0xE0, 0x80, 0xC0, 0x20, 0xC0,
		0x40, 0x80, 0xC0, 0xA0, 0x40,
		0xE0, 0x20, 0x60, 0x40, 0x40,
		0x40, 0xA0, 0x40, 0xA0, 0x40,
		0x40, 0xA0, 0x60, 0x20, 0x40,
		0x40, 0xA0, 0xE0, 0xA0, 0xA0,
		0xC0, 0xA0, 0xC0, 0xA0, 0xC0,
		0x60, 0x80, 0x80, 0x80, 0x60,
		0xC0, 0xA0, 0xA0, 0xA0, 0xC0,
		0xE0, 0x80, 0xC0, 0x80, 0xE0,
		0xE0, 0x80, 0xC0, 0x80, 0x80,
	],
}
var bigfonts = {
	octo: [
		0xFF, 0xFF, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xFF, 0xFF, // 0
		0x18, 0x78, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0xFF, // 1
		0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, // 2
		0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, // 3
		0xC3, 0xC3, 0xC3, 0xC3, 0xFF, 0xFF, 0x03, 0x03, 0x03, 0x03, // 4
		0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, // 5
		0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, 0xC3, 0xC3, 0xFF, 0xFF, // 6
		0xFF, 0xFF, 0x03, 0x03, 0x06, 0x0C, 0x18, 0x18, 0x18, 0x18, // 7
		0xFF, 0xFF, 0xC3, 0xC3, 0xFF, 0xFF, 0xC3, 0xC3, 0xFF, 0xFF, // 8
		0xFF, 0xFF, 0xC3, 0xC3, 0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, // 9
		0x7E, 0xFF, 0xC3, 0xC3, 0xC3, 0xFF, 0xFF, 0xC3, 0xC3, 0xC3, // A
		0xFC, 0xFC, 0xC3, 0xC3, 0xFC, 0xFC, 0xC3, 0xC3, 0xFC, 0xFC, // B
		0x3C, 0xFF, 0xC3, 0xC0, 0xC0, 0xC0, 0xC0, 0xC3, 0xFF, 0x3C, // C
		0xFC, 0xFE, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xFE, 0xFC, // D
		0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, // E
		0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, 0xC0, 0xC0, 0xC0, 0xC0  // F
	],
	schip: [
		0x3C, 0x7E, 0xE7, 0xC3, 0xC3, 0xC3, 0xC3, 0xE7, 0x7E, 0x3C,
		0x18, 0x38, 0x58, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C,
		0x3E, 0x7F, 0xC3, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xFF, 0xFF,
		0x3C, 0x7E, 0xC3, 0x03, 0x0E, 0x0E, 0x03, 0xC3, 0x7E, 0x3C,
		0x06, 0x0E, 0x1E, 0x36, 0x66, 0xC6, 0xFF, 0xFF, 0x06, 0x06,
		0xFF, 0xFF, 0xC0, 0xC0, 0xFC, 0xFE, 0x03, 0xC3, 0x7E, 0x3C,
		0x3E, 0x7C, 0xE0, 0xC0, 0xFC, 0xFE, 0xC3, 0xC3, 0x7E, 0x3C,
		0xFF, 0xFF, 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x60, 0x60,
		0x3C, 0x7E, 0xC3, 0xC3, 0x7E, 0x7E, 0xC3, 0xC3, 0x7E, 0x3C,
		0x3C, 0x7E, 0xC3, 0xC3, 0x7F, 0x3F, 0x03, 0x03, 0x3E, 0x7C,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // no hex chars!
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	],
	fish: [
		0x7C, 0xC6, 0xCE, 0xDE, 0xD6, 0xF6, 0xE6, 0xC6, 0x7C, 0x00, // at most 7x9 pixels!
		0x10, 0x30, 0xF0, 0x30, 0x30, 0x30, 0x30, 0x30, 0xFC, 0x00,
		0x78, 0xCC, 0xCC, 0x0C, 0x18, 0x30, 0x60, 0xCC, 0xFC, 0x00,
		0x78, 0xCC, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0xCC, 0x78, 0x00,
		0x0C, 0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x0C, 0x1E, 0x00,
		0xFC, 0xC0, 0xC0, 0xC0, 0xF8, 0x0C, 0x0C, 0xCC, 0x78, 0x00,
		0x38, 0x60, 0xC0, 0xC0, 0xF8, 0xCC, 0xCC, 0xCC, 0x78, 0x00,
		0xFE, 0xC6, 0xC6, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00,
		0x78, 0xCC, 0xCC, 0xEC, 0x78, 0xDC, 0xCC, 0xCC, 0x78, 0x00,
		0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0x18, 0x18, 0x30, 0x70, 0x00,
		0x30, 0x78, 0xCC, 0xCC, 0xCC, 0xFC, 0xCC, 0xCC, 0xCC, 0x00,
		0xFC, 0x66, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x66, 0xFC, 0x00,
		0x3C, 0x66, 0xC6, 0xC0, 0xC0, 0xC0, 0xC6, 0x66, 0x3C, 0x00,
		0xF8, 0x6C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00,
		0xFE, 0x62, 0x60, 0x64, 0x7C, 0x64, 0x60, 0x62, 0xFE, 0x00,
		0xFE, 0x66, 0x62, 0x64, 0x7C, 0x64, 0x60, 0x60, 0xF0, 0x00,
	],
	none: new Array(16*10).fill(0x00),
}
var fontsets = {
	octo     : { small: smallfonts.octo,      big: bigfonts.octo  },
	vip      : { small: smallfonts.vip,       big: bigfonts.none  },
	dream6800: { small: smallfonts.dream6800, big: bigfonts.none  },
	eti660   : { small: smallfonts.eti660,    big: bigfonts.none  },
	schip    : { small: smallfonts.octo,      big: bigfonts.schip },
	fish     : { small: smallfonts.fish,      big: bigfonts.fish  },
}

////////////////////////////////////
//
//   The Chip8 Interpreter:
//
////////////////////////////////////

function Emulator() {

	// persistent configuration settings
	this.tickrate           = 20;
	this.fillColor          = "#FFCC00";
	this.fillColor2         = "#FF6600";
	this.blendColor         = "#662200";
	this.backgroundColor    = "#996600";
	this.buzzColor          = "#FFAA00";
	this.quietColor         = "#000000";
	this.shiftQuirks        = false;
	this.loadStoreQuirks    = false;
	this.vfOrderQuirks      = false;
	this.clipQuirks         = false;
	this.jumpQuirks         = false;
	this.logicQuirks        = false;
	this.vBlankQuirks       = false;
	this.enableXO           = true;
	this.screenRotation     = 0;//must be 0, 90, 180, or 270
	this.maxSize            = 3584;
	this.touchInputMode     = 'none';
	this.maskFormatOverride = true;
	this.numericFormatStr   = "default";
	this.fontStyle          = 'octo';

	// interpreter state
	this.p  = [[],[]];  // pixels
	this.m  = [];       // memory (bytes)
	this.r  = [];       // return stack
	this.v  = [];       // registers
	this.pc = 0;        // program counter
	this.i  = 0;        // index register
	this.dt = 0;        // delay timer
	this.st = 0;        // sound timer
	this.hires = false; // are we in SuperChip high res mode?
	this.flags = [];    // semi-persistent hp48 flag vars
	this.pattern = [];  // audio pattern buffer
	this.plane = 1;     // graphics plane
	this.profile_data = {};

	// control/debug state
	this.keys = {};       // track keys which are pressed
	this.waiting = false; // are we waiting for a keypress?
	this.waitReg = -1;    // destination register of an awaited key
	this.halted = true;
	this.breakpoint = false;
	this.metadata = {};
	this.tickCounter = 0;
	this.linted = false;

	// external interface stubs
	this.exitVector  = function() {}                                   // fired by 'exit'
	this.importFlags = function() { return [0, 0, 0, 0, 0, 0, 0, 0]; } // load persistent flags
	this.exportFlags = function(flags) {}                              // save persistent flags
	this.buzzTrigger = function(ticks, remainingTicks) {}                              // fired when buzzer played

	this.init = function(rom) {
		// initialise memory with a new array to ensure that it is of the right size and is initiliased to 0
		this.m = this.enableXO ? new Uint8Array(0x10000) : new Uint8Array(0x1000);

		this.p = [[], []];
		if (this.enableXO)
			for(var z = 0; z < 64*128; z++) { this.p[0][z] = 0; this.p[1][z] = 0; }
		else
			for(var z = 0; z < 32*64; z++) { this.p[0][z] = 0; this.p[1][z] = 0; }

		// initialize memory
		var font = fontsets[this.fontStyle];
		for(var z = 0; z < 32*64;            z++) { this.p[0][z] = 0; this.p[1][z] = 0; }
		for(var z = 0; z < font.small.length;z++) { this.m[z] = font.small[z]; }
		for(var z = 0; z < font.big.length;  z++) { this.m[z + font.small.length] = font.big[z]; }
		for(var z = 0; z < rom.rom.length;   z++) { this.m[0x200+z] = rom.rom[z]; }
		for(var z = 0; z < 16;               z++) { this.v[z] = 0; }
		for(var z = 0; z < 16;               z++) { this.pattern[z] = 0; }

		// initialize interpreter state
		this.r = [];
		this.pc = 0x200;
		this.i  = 0;
		this.dt = 0;
		this.st = 0;
		this.hires = false;
		this.plane = 1;

		// initialize control/debug state
		this.keys = {};
		this.waiting = false;
		this.waitReg = -1;
		this.halted = false;
		this.breakpoint = false;
		this.stack_breakpoint = -1;
		this.metadata = rom;
		this.tickCounter = 0;
		this.profile_data = {};
	}

	this.writeCarry = function(dest, value, flag) {
		this.v[dest] = (value & 0xFF);
		this.v[0xF] = flag ? 1 : 0;
		if (this.vfOrderQuirks) {
			this.v[dest] = (value & 0xFF);
		}
	}

	this.math = function(x, y, op) {
		// basic arithmetic opcodes
		switch(op) {
			case 0x0: this.v[x]  = this.v[y]; break;
			case 0x1: this.v[x] |= this.v[y]; if (this.logicQuirks) this.v[0xF]=0; break;
			case 0x2: this.v[x] &= this.v[y]; if (this.logicQuirks) this.v[0xF]=0; break;
			case 0x3: this.v[x] ^= this.v[y]; if (this.logicQuirks) this.v[0xF]=0; break;
			case 0x4:
				var t = this.v[x]+this.v[y];
				this.writeCarry(x, t, (t > 0xFF));
				break;
			case 0x5:
				var t = this.v[x]-this.v[y];
				this.writeCarry(x, t, (this.v[x] >= this.v[y]));
				break;
			case 0x7:
				var t = this.v[y]-this.v[x];
				this.writeCarry(x, t, (this.v[y] >= this.v[x]));
				break;
			case 0x6:
				if (this.shiftQuirks) { y = x; }
				var t = this.v[y] >> 1;
				this.writeCarry(x, t, (this.v[y] & 0x1));
				break;
			case 0xE:
				if (this.shiftQuirks) { y = x; }
				var t = this.v[y] << 1;
				this.writeCarry(x, t, ((this.v[y] >> 7) & 0x1));
				break;
			default:
				haltBreakpoint("unknown math opcode "+op.toString(16).toUppercase());
		}
	}

	this.misc = function(x, rest) {
		// miscellaneous opcodes
		switch(rest) {
			case 0x01:
				this.plane = (x & 0x3);
				break;
			case 0x02:
				for(var z = 0; z < 16; z++) {
					this.pattern[z] = this.m[this.i+z];
				}
				break;
			case 0x07: this.v[x] = this.dt; break;
			case 0x0A: this.waiting = true; this.waitReg = x; break;
			case 0x15: this.dt = this.v[x]; break;
			case 0x18: this.buzzTrigger(this.v[x], this.st); this.st = this.v[x]; break;
			case 0x1E: this.i = (this.i + this.v[x])&0xFFFF; break;
			case 0x29: this.i = ((this.v[x] & 0xF) * 5); break;
			case 0x30: this.i = ((this.v[x] & 0xF) * 10 + fontsets[this.fontStyle].small.length); break;
			case 0x33:
				this.m[this.i]   = Math.floor(this.v[x]/100)%10;
				this.m[this.i+1] = Math.floor(this.v[x]/10)%10;
				this.m[this.i+2] = this.v[x]%10;
				break;
			case 0x55:
				for(var z = 0; z <= x; z++) { this.m[this.i+z] = this.v[z]; }
				if (!this.loadStoreQuirks) { this.i = (this.i+x+1)&0xFFFF; }
				break;
			case 0x65:
				for(var z = 0; z <= x; z++) { this.v[z] = this.m[this.i+z]; }
				if (!this.loadStoreQuirks) { this.i = (this.i+x+1)&0xFFFF; }
				break;
			case 0x75:
				for(var z = 0; z <= x; z++) { this.flags[z] = this.v[z]; }
				this.exportFlags(this.flags);
				break;
			case 0x85:
				this.flags = this.importFlags();
				if (typeof this.flags == "undefined" || this.flags == null) {
					this.flags = [0, 0, 0, 0, 0, 0, 0, 0];
				}
				for(var z = 0; z <= x; z++) { this.v[z] = this.flags[z]; }
				break;
			default:
				haltBreakpoint("unknown misc opcode "+rest.toString(16).toUppercase());
		}
	}

	this.sprite = function sprite(x, y, len) {
		this.v[0xF] = 0x0;
		var rowSize = this.hires ? 128 : 64;
		var colSize = this.hires ?  64 : 32;
		var i = this.i;
		for(var layer = 0; layer < 2; layer++) {
			if ((this.plane & (layer+1)) == 0) { continue; }
			if (len == 0) {
				// draw a SuperChip 16x16 sprite
				for(var a = 0; a < 16; a++) {
					for(var b = 0; b < 16; b++) {
						var target = ((x+b) % rowSize) + ((y+a) % colSize)*rowSize;
						var source = ((this.m[i+(a*2)+(b > 7 ? 1:0)] >> (7-(b%8))) & 0x1) != 0;
						if (this.clipQuirks) {
							if ((x%rowSize)+b>=rowSize || (y%colSize)+a>=colSize) { source = 0; }
						}
						if (!source) { continue; }
						if (this.p[layer][target]) { this.p[layer][target] = 0; this.v[0xF] = 0x1; }
						else { this.p[layer][target] = 1; }
					}
				}
				i += 32;
			}
			else {
				// draw a Chip8 8xN sprite
				for(var a = 0; a < len; a++) {
					for(var b = 0; b < 8; b++) {
						var target = ((x+b) % rowSize) + ((y+a) % colSize)*rowSize;
						var source = ((this.m[i+a] >> (7-b)) & 0x1) != 0;
						if (this.clipQuirks) {
							if ((x%rowSize)+b>=rowSize || (y%colSize)+a>=colSize) { source = 0; }
						}
						if (!source) { continue; }
						if (this.p[layer][target]) { this.p[layer][target] = 0; this.v[0xF] = 0x1; }
						else { this.p[layer][target] = 1; }
					}
				}
				i += len;
			}
		}
	}

	this.call = function(nnn) {
		if (this.r.length >= 12) {
			haltBreakpoint("call stack overflow.");
		}
		this.r.push(this.pc);
		this.pc = nnn
	}

	this.jump0 = function(nnn) {
		if (this.jumpQuirks) { this.pc = nnn + this.v[(nnn >> 8)&0xF];  }
		else                 { this.pc = nnn + this.v[0]; }
	}

	this.machine = function(nnn) {
		if (nnn == 0x000) { this.halted = true; return; }
		haltBreakpoint("machine code is not supported.");
	}

	this.skip = function() {
		var op = (this.m[this.pc  ] << 8) | this.m[this.pc+1];
		this.pc += (op == 0xF000) ? 4 : 2;
	}

	this.opcode = function() {
		// Increment profilining data
		this.profile_data[this.pc] = (this.profile_data[this.pc] || 0) + 1;

		// decode the current opcode
		var op  = (this.m[this.pc  ] << 8) | this.m[this.pc+1];
		var o   = (this.m[this.pc  ] >> 4) & 0x00F;
		var x   = (this.m[this.pc  ]     ) & 0x00F;
		var y   = (this.m[this.pc+1] >> 4) & 0x00F;
		var n   = (this.m[this.pc+1]     ) & 0x00F;
		var nn  = (this.m[this.pc+1]     ) & 0x0FF;
		var nnn = op & 0xFFF;
		this.pc += 2;

		// execute a simple opcode
		if (op == 0x00E0) {
			// clear
			for(var layer = 0; layer < 2; layer++) {
				if ((this.plane & (layer+1)) == 0) { continue; }
				for(var z = 0; z < this.p[layer].length; z++) {
					this.p[layer][z] = 0;
				}
			}
			return;
		}
		if (op == 0x00EE) {
			// return
			this.pc = this.r.pop();
			return;
		}
		if ((op & 0xF0FF) == 0xE09E) {
			// if -key
			if (Object.keys(keymap[this.v[x]]||{}).some(x => x in this.keys)) { this.skip(); }
			return;
		}
		if ((op & 0xF0FF) == 0xE0A1) {
			// if key
			if (!Object.keys(keymap[this.v[x]]||{}).some(x => x in this.keys)) { this.skip(); }
			return;
		}
		if ((op & 0xFFF0) == 0x00C0) {
			// scroll down n pixels
			var rowSize = this.hires ? 128 : 64;
			for(var layer = 0; layer < 2; layer++) {
				if ((this.plane & (layer+1)) == 0) { continue; }
				for(var z = this.p[layer].length - 1; z >= 0; z--) {
					this.p[layer][z] = (z >= rowSize * n) ? this.p[layer][z - (rowSize * n)] : 0;
				}
			}
			return;
		}
		if ((op & 0xFFF0) == 0x00D0) {
			// scroll up n pixels
			var rowSize = this.hires ? 128 : 64;
			for(var layer = 0; layer < 2; layer++) {
				if ((this.plane & (layer+1)) == 0) { continue; }
				for(var z = 0; z < this.p[layer].length; z++) {
					this.p[layer][z] = (z < (this.p[layer].length - rowSize * n)) ? this.p[layer][z + (rowSize * n)] : 0;
				}
			}
			return;
		}
		if (op == 0x00FB) {
			// scroll right 4 pixels
			var rowSize = this.hires ? 128 : 64;
			for(var layer = 0; layer < 2; layer++) {
				if ((this.plane & (layer+1)) == 0) { continue; }
				for(var a = 0; a < this.p[layer].length; a += rowSize) {
					for(var b = rowSize-1; b >= 0; b--) {
						this.p[layer][a + b] = (b > 3) ? this.p[layer][a + b - 4] : 0;
					}
				}
			}
			return;
		}
		if (op == 0x00FC) {
			// scroll left 4 pixels
			var rowSize = this.hires ? 128 : 64;
			for(var layer = 0; layer < 2; layer++) {
				if ((this.plane & (layer+1)) == 0) { continue; }
				for(var a = 0; a < this.p[layer].length; a += rowSize) {
					for(var b = 0; b < rowSize; b++) {
						this.p[layer][a + b] = (b < rowSize - 4) ? this.p[layer][a + b + 4] : 0;
					}
				}
			}
			return;
		}
		if (op == 0x00FD) {
			// exit
			this.halted = true;
			this.exitVector();
			return;
		}
		if (op == 0x00FE) {
			// lores
			this.hires = false;
			this.p = [[], []];
			for(var z = 0; z < 32*64; z++) { this.p[0][z] = 0; this.p[1][z] = 0; }
			return;
		}
		if (op == 0x00FF) {
			// hires
			this.hires = true;
			this.p = [[], []];
			for(var z = 0; z < 64*128; z++) { this.p[0][z] = 0; this.p[1][z] = 0; }
			return;
		}
		if (op == 0xF000) {
			// long memory reference
			this.i = ((this.m[this.pc] << 8) | (this.m[this.pc+1])) & 0xFFFF;
			this.pc += 2;
			return;
		}

		if (o == 0x5 && n != 0) {
			if (n == 2) {
				// save range
				var dist = Math.abs(x - y);
				if (x < y) { for(var z = 0; z <= dist; z++) { this.m[this.i+z] = this.v[x+z]; }}
				else       { for(var z = 0; z <= dist; z++) { this.m[this.i+z] = this.v[x-z]; }}
				return;
			}
			else if (n == 3) {
				// load range
				var dist = Math.abs(x - y);
				if (x < y) { for(var z = 0; z <= dist; z++) { this.v[x+z] = this.m[this.i+z]; }}
				else       { for(var z = 0; z <= dist; z++) { this.v[x-z] = this.m[this.i+z]; }}
				return;
			}
			else {
				haltBreakpoint("unknown opcode "+op.toString(16).toUppercase());
			}
		}
		if (o == 0x9 && n != 0) {
			haltBreakpoint("unknown opcode "+op.toString(16).toUppercase());
		}

		// dispatch complex opcodes
		switch(o) {
			case 0x0: this.machine(nnn);                            break;
			case 0x1: this.pc = nnn;                                break;
			case 0x2: this.call(nnn);                               break;
			case 0x3: if (this.v[x] == nn)        { this.skip(); }  break;
			case 0x4: if (this.v[x] != nn)        { this.skip(); }  break;
			case 0x5: if (this.v[x] == this.v[y]) { this.skip(); }  break;
			case 0x6: this.v[x] = nn;                               break;
			case 0x7: this.v[x] = (this.v[x] + nn) & 0xFF;          break;
			case 0x8: this.math(x, y, n);                           break;
			case 0x9: if (this.v[x] != this.v[y]) { this.skip(); }  break;
			case 0xA: this.i = nnn;                                 break;
			case 0xB: this.jump0(nnn);                              break;
			case 0xC: this.v[x] = (Math.random()*256)&nn;           break;
			case 0xD: this.sprite(this.v[x], this.v[y], n);         break;
			case 0xF: this.misc(x, nn);                             break;
			default: haltBreakpoint("unknown opcode "+o.toString(16).toUppercase());
		}
	}

	this.tick = function() {
		if (this.halted) { return; }
		this.tickCounter++;
		try {
			this.opcode();
		}
		catch(err) {
			console.log("halted: " + err);
			this.halted = true;
		}
	}
}
</script>
<script>"use strict";

////////////////////////////////////
//
//   Emulator Execution
//
////////////////////////////////////

//must be set > 0
var scaleFactor = 5;
//dom id for canvas element
var renderTarget = "target";

const optionFlags = [
	"tickrate",
	"fillColor",
	"fillColor2",
	"blendColor",
	"backgroundColor",
	"buzzColor",
	"quietColor",
	"shiftQuirks",
	"loadStoreQuirks",
	"vfOrderQuirks",
	"clipQuirks",
	"vBlankQuirks",
	"jumpQuirks",
	"screenRotation",
	"maxSize",
	"touchInputMode",
	"logicQuirks",
	"fontStyle",
]
function unpackOptions(emulator, options) {
	optionFlags.forEach(x => { if (x in options) emulator[x] = options[x] })
	if (options["enableXO"]) emulator.maxSize = 65024 // legacy option
}
function packOptions(emulator) {
	const r = {}
	optionFlags.forEach(x => r[x] = emulator[x])
	return r
}

function setRenderTarget(scale, canvas) {
	scaleFactor = scale;
	renderTarget = canvas;
	var c = document.getElementById(canvas);

	// Remove any existing previous delta frame so first frame is always drawn:
	c.last = undefined;

	var w  = scaleFactor * 128;
	var h  = scaleFactor *  64;

	if (emulator.screenRotation == 90 || emulator.screenRotation == 270) {
		c.width  = h;
		c.height = w;
	}
	else {
		c.width  = w;
		c.height = h;
	}
}

function setTransform(emulator, g) {
	g.setTransform(1, 0, 0, 1, 0, 0);
	var x = scaleFactor * 128;
	var y = scaleFactor *  64;
	switch(emulator.screenRotation) {
		case 90:
			g.rotate(0.5 * Math.PI);
			g.translate(0, -y);
			break;
		case 180:
			g.rotate(1.0 * Math.PI);
			g.translate(-x, -y);
			break;
		case 270:
			g.rotate(1.5 * Math.PI);
			g.translate(-x, 0);
			break;
		default:
			console.assert(emulator.screenRotation === 0, 'Screen rotation not set to 0, 90, 180, or 270. Treating as 0.')
	}
}


function arrayEqual(a, b) {
	var length = a.length;
	if (length !== b.length) { return false; }
	for (var i = 0; i < length; i++) {
		if (a[i] !== b[i]) { return false; }
	}
	return true;
}

function getColor(id) {
	switch(id) {
		case 0: return emulator.backgroundColor;
		case 1: return emulator.fillColor;
		case 2: return emulator.fillColor2;
		case 3: return emulator.blendColor;
	}
	throw "invalid color: " + id;
}

function renderDisplay(emulator) {
	var c = document.getElementById(renderTarget);

	// Canvas rendering can be expensive. Exit out early if nothing has changed.
	var colors = [emulator.backgroundColor, emulator.fillColor, emulator.fillColor2, emulator.blendColor];
	if (c.last !== undefined) {
		if (arrayEqual(c.last.p[0], emulator.p[0]) && arrayEqual(c.last.p[1], emulator.p[1])
				&& arrayEqual(c.last.colors, colors)) {
			return;
		}
		if (c.last.hires !== emulator.hires)
			c.last = undefined;  // full redraw when switching resolution
	}
	var g = c.getContext("2d");
	setTransform(emulator, g);
	var w      = emulator.hires ? 128         : 64;
	var h      = emulator.hires ? 64          : 32;
	var size   = emulator.hires ? scaleFactor : scaleFactor*2;
	var lastPixels = c.last !== undefined? c.last.p: [[], []]

	g.scale(size, size)
	var z = 0;
	for(var y = 0; y < h; ++y) {
		for(var x = 0; x < w; ++x, ++z) {
			var oldColorIdx = lastPixels[0][z] + (lastPixels[1][z] << 1);
			var colorIdx = emulator.p[0][z] + (emulator.p[1][z] << 1);
			if (oldColorIdx !== colorIdx) {
				g.fillStyle = getColor(colorIdx);
				g.fillRect(x, y, 1, 1);
			}
		}
	}
	g.scale(1, 1) //restore scale to 1,1 just in case

	c.last = {
		colors: colors,
		p: [emulator.p[0].slice(), emulator.p[1].slice()],
		hires: emulator.hires,
	};
}

////////////////////////////////////
//
//   Audio Playback
//
////////////////////////////////////

var audio;
var audioNode;
var audioSource;
var audioData;

var AudioBuffer = function(buffer, duration) {
	if (!(this instanceof AudioBuffer)) {
		return new AudioBuffer(buffer, duration);
	}

	this.pointer = 0;
	this.buffer = buffer;
	this.duration = duration;
}

AudioBuffer.prototype.write = function(buffer, index, size) {
	size = Math.max(0, Math.min(size, this.duration))
	if (!size) { return size; }

	this.duration -= size;
	var bufferSize = this.buffer.length;
	var end = index + size;

	for(var i = index; i < end; ++i) {
		buffer[i] = this.buffer[this.pointer++];
		this.pointer %= bufferSize;
	}

	return size;
}

AudioBuffer.prototype.dequeue = function(duration) {
	this.duration -= duration;
}

var FREQ = 4000;
var TIMER_FREQ = 60;
var SAMPLES = 16;
var BUFFER_SIZE = SAMPLES * 8


function audioEnable() {
	// this will only work if called directly from a user-generated input handler:
	if (audio && audio.state == 'suspended') audio.resume()
}

function audioSetup() {
	if (!audio) {
		if (typeof AudioContext !== 'undefined') {
			audio = new AudioContext();
		}
		else if (typeof webkitAudioContext !== 'undefined') {
			audio = new webkitAudioContext();
		}
	}
	audioEnable()
	if (audio && !audioNode) {
		audioNode = audio.createScriptProcessor(4096, 1, 1);
		audioNode.onaudioprocess = function(audioProcessingEvent) {
			var outputBuffer = audioProcessingEvent.outputBuffer;
			var outputData = outputBuffer.getChannelData(0);
			var samples_n = outputBuffer.length;

			var index = 0;
			while(audioData.length && index < samples_n) {
				var size = samples_n - index;
				var written = audioData[0].write(outputData, index, size);
				index += written;
				if (written < size) {
					audioData.shift();
				}
			}

			while(index < samples_n) {
				outputData[index++] = 0;
			}
			//the last one can be long sound with high value of buzzer, so always keep it
			if (audioData.length > 1) {
				var audioDataSize = 0;
				var audioBufferSize = audioNode.bufferSize;
				audioData.forEach(function(buffer) { audioDataSize += buffer.duration; })
				while(audioDataSize > audioBufferSize && audioData.length > 1) {
					audioDataSize -= audioData.shift().duration;
				}
			}
		}
		audioData = [];
		audioNode.connect(audio.destination);
		return true;
	}
	if (audio && audioNode) { return true; }
	return false;
}

function stopAudio() {
	if (!audio) { return; }
	if (audioNode) {
		audioNode.disconnect();
		audioNode = null;
	}
	audioData = [];
}

var VOLUME = 0.25;

function playPattern(soundLength, buffer, remainingTicks) {
	if (!audio) { return; }
	audioEnable()

	var samples = Math.floor(BUFFER_SIZE * audio.sampleRate / FREQ);
	var audioBuffer = new Array(samples);
	if (remainingTicks && audioData.length > 0) {
		audioData[audioData.length - 1].dequeue(Math.floor(remainingTicks * audio.sampleRate / TIMER_FREQ));
	}

	for(var i = 0; i < samples; ++i) {
		var srcIndex = Math.floor(i * FREQ / audio.sampleRate);
		var cell = srcIndex >> 3;
		var bit = srcIndex & 7;
		audioBuffer[i] = (buffer[srcIndex >> 3] & (0x80 >> bit)) ? VOLUME: 0;
	}
	audioData.push(new AudioBuffer(audioBuffer, Math.floor(soundLength * audio.sampleRate / TIMER_FREQ)));
}

function escapeHtml(str) {
    var div = document.createElement('div');
    div.appendChild(document.createTextNode(str));
    return div.innerHTML;
}
</script>
<script>/**
* Adaptive Input
**/

const ael = (element, event, listener) => element.addEventListener   (event, listener, { passive:false })
const rel = (element, event, listener) => element.removeEventListener(event, listener, { passive:false })
const pd  = event => (event.preventDefault(),event.stopPropagation())

const VIP_HEX  = '123c456d789ea0bf'.split('')
const VIP_KEYS = VIP_HEX.map(x => parseInt(x,16))

const GAMEPAD_STYLES = `
.gamepad{
  position:absolute;
  top:10%;
  left:0px;
  width:100%;
  height:90%;
  opacity:0.3;
  user-select: none;
  -webkit-user-select: none;
}
.gamepad .dpad{
  position:absolute;
  bottom: 50px;
  left:   50px;
  width:  250px;
  height: 250px;
  background: gray;
  border-radius: 50%;
  overflow:hidden;
}
.gamepad .stick{
  display:none;
  position:absolute;
  border-radius: 50%;
  width:100px;
  height:100px;
  margin-left:-50px;
  margin-top:-50px;
}
.gamepad .buttons{
  position:absolute;
  bottom: 50px;
  right:  50px;
  width:  250px;
  height: 250px;
}
.gamepad .gamebutton{
  position:absolute;
  width:  125px;
  height: 125px;
  background:gray;
  border-radius:50%;
  overflow:hidden;
  line-height: 125px;
  font-size:50px;
  font-weight:bold;
  color:darkgray;
  text-align:center;
}
.gamepad .dpad.active .stick {display:block;background:#444}
.gamepad .gamebutton.active{background:#444;}
.gamepad .gamebutton.b{left:0;bottom:0;}
.gamepad .gamebutton.a{right:0;top:0;}
`
const VIP_STYLES = `
.vip-pad {display:flex;flex-direction:column;align-items:center;z-index:2000;}
.vip-pad .keypad {display:flex;flex-direction:column;margin-top:10px;}
.vip-pad .keypad>div {display:flex;flex-direction:row;}
.vip-pad .keypad>div>div {
  -webkit-user-select: none;
  user-select: none;
  background:gray;
  width: 100px;
  height: 51px;
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 1px;
}
.vip-pad .keypad>div>div:active,
.vip-pad .keypad>div>div.active {background:black; border:1px solid white;margin:0px;}
`

const INPUT_MODULES = {
  /**
  * An invisible set of gesture recognizers,
  * giving directional input and an action for taps.
  **/
  swipe: {
    install: (screen,up,down,options) => {

      let vdirs      = []
      let direction  = { i:null, sx:0, sy:0, lx:0, ly:0 }
      let action1    = {}
      let taptimeout = null

      const updateStick = _ => {
        // find the relative position of the stick to its starting point
        const cx = direction.lx - direction.sx
        const cy = direction.ly - direction.sy

        // update the virtual direction buttons
        let t = []
        const DEAD_ZONE = 30
        if (Math.abs(cx) > DEAD_ZONE) t.push(cx < 0 ? options.left : options.right)
        if (Math.abs(cy) > DEAD_ZONE) t.push(cy < 0 ? options.up   : options.down)
        vdirs.forEach(x => (t    .indexOf(x)<0) && up  (x)) // clear keys no longer held
        t    .forEach(x => (vdirs.indexOf(x)<0) && down(x)) // push keys that were not held before
        vdirs = t
      }
      const tapDown= i => {
        if (Object.keys(action1).length == 0) down(options.action1)
        action1[i] = true
        if (i == direction.i) { direction = { i:null, sx:0, sy:0, lx:0, ly:0 } }
        taptimeout = null
      }
      const start = e => {
        const t = e.touches[0]
        const i = t.identifier
        // a single-touch is either directional or a tap...
        if (direction.i != null) {
          tapDown(i)
        }
        else {
          direction.i  = i
          direction.sx = t.clientX
          direction.sy = t.clientY
          direction.lx = t.clientX
          direction.ly = t.clientY
          taptimeout = setTimeout(_ => tapDown(i), 100)
        }
        updateStick(),pd(e)
      }
      const move = e => {
        for(let z = 0; z < e.changedTouches.length; z++) {
          const t = e.changedTouches[z]
          const i = t.identifier
          if (i == direction.i) {
            if (taptimeout != null) { clearTimeout(taptimeout); taptimeout = null }
            direction.lx = t.clientX
            direction.ly = t.clientY
          }
        }
        updateStick(),pd(e)
      }
      const end = e => {
        let r1 = false
        for(let z = 0; z < e.changedTouches.length; z++) {
          const t = e.changedTouches[z]
          const i = t.identifier
          if (i == direction.i) {
            if (taptimeout != null) {
              // cancel a short tap
              clearTimeout(taptimeout); taptimeout = null
              down(options.action1)
              setTimeout(_ => up(options.action1), 50)
            }
            direction = { i:null, sx:0, sy:0, lx:0, ly:0 }
          }
          if (i in action1) {
            delete action1[i]
            r1=true
          }
        }
        if (r1 && Object.keys(action1).length == 0) up(options.action1)
        updateStick(),pd(e)
      }
      ael(screen, 'touchstart', start)
      ael(screen, 'touchmove',  move)
      ael(screen, 'touchend',   end)
      screen.uninstallSwipe = _ => {
        rel(screen, 'touchstart', start)
        rel(screen, 'touchmove',  move)
        rel(screen, 'touchend',   end)
      }
    },
    remove: (screen) => {
      screen.uninstallSwipe()
      delete screen.uninstallSwipe
    }
  },

  /**
  * A virtual gamepad overlay with two remappable action keys.
  **/
  gamepad: {
    install: (screen,up,down,options) => {
      // build the UI
      if (document.querySelector('.gamepad')) return
      const root = document.createElement('div')
      root.classList.add('gamepad')
      root.innerHTML = `
      <div class='dpad'><div class='stick'></div></div>
      <div class='buttons'><div class='gamebutton b'>B</div><div class='gamebutton a'>A</div></div>
      <style>${GAMEPAD_STYLES}</style>`
      screen.parentElement.append(root)

      let vdirs      = []
      let directions = {}
      let buttons    = {}
      const pad   = document.querySelector('.gamepad .dpad')
      const stick = document.querySelector('.gamepad .dpad .stick')
      const a     = document.querySelector('.gamepad .gamebutton.a')
      const b     = document.querySelector('.gamepad .gamebutton.b')

      const updateStick = _ => {
        // find centroid of d-pad touchpoints ({0,0} if no touchpoints)
        const touches = Object.values(directions)
        let cx = 0, cy = 0, r = pad.getBoundingClientRect(), sr = stick.getBoundingClientRect()
        touches.forEach(t => (cx+=t.x, cy+=t.y))
        cx /= touches.length,         cy /= touches.length
        cx -= (r.left + (r.width/2)), cy -= (r.top + (r.height/2))

        // position the virtual stick, clamped within dpad
        const ca = Math.atan2(cy, cx)
        const cd = Math.min(Math.sqrt(cx*cx + cy*cy), (r.width/2)-(sr.width/2))
        stick.style.left = ((Math.cos(ca)*cd)+(r.width /2)|0)+'px'
        stick.style.top  = ((Math.sin(ca)*cd)+(r.height/2)|0)+'px'

        // update the virtual direction buttons
        let t = []
        const DEAD_ZONE = 30
        if (Math.abs(cx) > DEAD_ZONE) t.push(cx < 0 ? options.left : options.right)
        if (Math.abs(cy) > DEAD_ZONE) t.push(cy < 0 ? options.up   : options.down)
        vdirs.forEach(x => (t    .indexOf(x)<0) && up  (x)) // clear keys no longer held
        t    .forEach(x => (vdirs.indexOf(x)<0) && down(x)) // push keys that were not held before
        vdirs = t
      }

      const start = e => {
        for(let z = 0; z<e.touches.length; z++) {
          const t = e.touches[z]
          const i = t.identifier
          if (t.target == a) {
            t.target.classList.add('active')
            buttons[i]=options.action1
            down(options.action1)
          }
          if (t.target == b) {
            t.target.classList.add('active')
            buttons[i]=options.action2
            down(options.action2)
          }
          if (t.target == pad) {
            t.target.classList.add('active')
            directions[i]={x:t.clientX, y:t.clientY}
          }
        }
        updateStick(),pd(e)
      }
      const move = e => {
        for(let z = 0; z<e.changedTouches.length; z++) {
          const t = e.changedTouches[z]
          const i = t.identifier
          if (i in directions) directions[i]={x:t.clientX, y:t.clientY}
        }
        updateStick(),pd(e)
      }
      const end = e => {
        for(let z = 0; z<e.changedTouches.length; z++) {
          const t = e.changedTouches[z]
          const i = t.identifier
          if (i in buttons) {
            t.target.classList.remove('active')
            up(buttons[i])
            delete buttons[i]
          }
          if (i in directions) {
            t.target.classList.remove('active')
            delete directions[i]
          }
        }
        updateStick(),pd(e)
      }

      ael(a,   'touchstart', start)
      ael(a,   'touchend',   end  )
      ael(b,   'touchstart', start)
      ael(b,   'touchend',   end  )
      ael(pad, 'touchstart', start)
      ael(pad, 'touchmove',  move )
      ael(pad, 'touchend',   end  )
    },
    remove: (screen) => {
      document.querySelector('.gamepad').remove()
    },
  },

  /**
  * Treat the entire screen, or a centered square region, as invisible buttons,
  * mapped out in the order of the VIP hex keypad.
  **/
  seg16: {
    install: (screen,up,down,options) => {
      const tmap = {}
      const pointToKey = touch => {
        // poll this for each point, as it may vary over time,
        // and experimentally it's never right initially...
        const r = screen.getBoundingClientRect()
        if (options.mode == 'center') {
          if (r.width > r.height) { r.x += (r.width - r.height)/2; r.width = r.height }
          else                    { r.y += (r.height - r.width)/2; r.height = r.width }
        }
        const x = touch.clientX - r.x
        const y = touch.clientY - r.y
        if (x < 0 || x > r.width || y < 0 || y > r.height) return null
        const tx = Math.floor(x / (r.width /4))
        const ty = Math.floor(y / (r.height/4))
        return VIP_KEYS[tx + (4 * ty)]
      }
      const start = e => {
        for(let z=0; z<e.touches.length; z++) {
          const i = e.touches[z].identifier
          const k = pointToKey(e.touches[z])
          if (k != null) down(k)
          tmap[i]=k
        }
        pd(e)
      }
      const move = e => {
        for(let z=0; z<e.touches.length; z++) {
          const i = e.touches[z].identifier
          const k = pointToKey(e.touches[z])
          if (tmap[i] == k) continue       // same cell, nothing to do.
          if (tmap[i] != null) up(tmap[i]) // release old key, if any
          if (k != null)       down(k)     // press new key, if any
          tmap[i]=k
        }
        pd(e)
      }
      const end = e => {
        for(let z=0; z<e.changedTouches.length; z++) {
          const i = e.changedTouches[z].identifier
          const k = pointToKey(e.changedTouches[z])
          if (tmap[i] != null) up(tmap[i])
          tmap[i]=null
        }
        pd(e)
      }
      ael(screen, 'touchstart', start)
      ael(screen, 'touchmove',  move )
      ael(screen, 'touchend',   end  )
      screen.uninstallSeg16 = _ => {
        rel(screen, 'touchstart', start)
        rel(screen, 'touchmove',  move )
        rel(screen, 'touchend',   end  )
      }
    },
    remove:  (screen) => {
      screen.uninstallSeg16()
      delete screen.uninstallSeg16
    },
  },

  /**
  * Provide a visible 4x4 representation of the VIP hex keypad.
  **/
  vip: {
    install: (screen,up,down,options) => {
      if (document.querySelector('.vip-pad')) return
      const root = document.createElement('div')
      root.classList.add('vip-pad')
      root.innerHTML = `<div class='keypad'>
        ${[0,1,2,3].map(r=>`<div>${[0,1,2,3].map(c=>`<div>${VIP_HEX[c+(r*4)].toUpperCase()}</div>`).join('')}</div>`).join('')}
      </div>
      <style>${VIP_STYLES}</style>`
      if (screen.parentElement == document.body) { screen.parentElement.append(root) }
      else { screen.parentElement.parentElement.append(root) }
      const buttons = []
      document.querySelectorAll('.vip-pad .keypad>div>div').forEach(x=>buttons.push(x)) // make an actual Array
      const held = {}
      const start = e => {
        for(let z=0; z<e.touches.length; z++) {
          const t = e.touches[z]
          const i = t.identifier
          const k = VIP_KEYS[buttons.indexOf(t.target)]
          t.target.classList.add('active')
          down(k)
          held[i]=k
        }
        pd(e)
      }
      const end = e => {
        for(let z = 0; z<e.changedTouches.length; z++) {
          const t = e.changedTouches[z]
          const i = t.identifier
          if (held[i]) { up(held[i]); delete held[i] }
          t.target.classList.remove('active')
        }
        pd(e)
      }
      buttons.forEach(b => {
        ael(b, 'touchstart', start)
        ael(b, 'touchend',   end  )
      })
    },
    remove:  (screen) => {
      document.querySelector('.vip-pad').remove()
    },
  },
}

let adaptiveControlsInstalled = null

function injectAdaptiveControls(type, screen, keyup, keydown) {
  let options = {
    up:      5,
    down:    8,
    left:    7,
    right:   9,
    action1: 6,
    action2: 4,
    mode:    'center', // or 'fill', used by seg16
  }
  const lookup = vk => Object.keys(keymap[vk])[0]
  const install = _ => {
    rel(screen, 'touchstart', install)
    adaptiveControlsInstalled = type
    INPUT_MODULES[type].install(
      screen,
      key => keyup  ({ key:lookup(key), preventDefault:_=>_ }),
      key => keydown({ key:lookup(key), preventDefault:_=>_ }),
      options
    )
  }
  // uninstall anything that's already there:
  rel(screen, 'touchstart', install)
  if (adaptiveControlsInstalled) INPUT_MODULES[adaptiveControlsInstalled].remove(screen)

  if (type == 'none') return
  if (type == 'seg16fill') { type='seg16'; options.mode='fill' }
  // defer installing adaptive input until we actually see
  // an input event from the user:
  ael(screen, 'touchstart', install)
}
</script>
<body><canvas id='target' width=512 height=256></canvas></body>
<style>body{margin:0px;display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;}</style>
<script>
const emulator = new Emulator()
unpackOptions(emulator, data.options)
setRenderTarget(data.options.displayScale || 4, 'target')
emulator.init({rom:data.rom})
emulator.importFlags = _ => getPref('octoFlagRegisters')
emulator.exportFlags = f => setPref('octoFlagRegisters',f)
emulator.buzzTrigger = (ticks,rest)=> playPattern(ticks, emulator.pattern, rest)
const kd = e=>{
	if (!audio) audioSetup()
	if (!(e.key in emulator.keys)) emulator.keys[e.key]=true
	e.preventDefault()
}
const ku = e=>{
	if (e.key in emulator.keys) delete emulator.keys[e.key]
	if (!emulator.waiting) return
	const kindex = keymapInverse[e.key]
	if (kindex != undefined) {
		emulator.waiting = false
		emulator.v[emulator.waitReg] = kindex
	}
	e.preventDefault()
}
window.addEventListener('keydown',kd,false)
window.addEventListener('keyup',ku,false)
intervalHandle = setInterval(_=>{
	if (emulator.halted) return
	for(var z = 0; (z<emulator.tickrate) && (!emulator.waiting); z++) emulator.tick()
	if (emulator.dt > 0) emulator.dt--
	if (emulator.st > 0) emulator.st--
	renderDisplay(emulator)
	document.body.style.backgroundColor = emulator.st?emulator.buzzColor:emulator.quietColor
}, 1000/60)

injectAdaptiveControls(emulator.touchInputMode,document.getElementById('target'),ku,kd)
</script>
