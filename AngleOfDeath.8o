############################################
#                                          #
#    #####          ANGLE                  #
#   #########                              #
#   ##						OF             #
#   #  #####                               #
#   # ### # #					   DEATH   #
#   #  #####							   #
############################################


:alias Tx  vD	# target X
:alias Ty  vC	# target Y
:alias Tr  vB   # Rotation
:alias TrZ vA   # Rotation Zone
:alias frame_stepper v9
:alias next_crosshair v8
# v7


# Non critical frame to frame
:alias on_axis v3
:alias off_axis v4
# Convinience
:alias cross_x v0
:alias cross_y v1

:alias subpx_step v5

## Calculate gameplay dimensions:

:calc zone { 7 * 8 }

:calc UL_X { -1 + ( 128 - zone ) / 2 }
:calc UL_Y { -1 + ( 64 -  zone ) / 2 }
:calc UL_X_plus1 { UL_X + 1 }
:calc UL_Y_plus1 { UL_Y + 1 }

:calc LL_Y { 0 + ( 64 +  zone ) / 2 }

:calc UR_X { 0 + ( 128 + zone ) / 2 }

:calc UR_Max8 { UL_X + zone }
:calc LL_Max8 { UL_Y_plus1 + zone }

:calc player_LEFT_LIMIT { UL_X + 3 }
:calc player_RIGHT_LIMIT { UR_X - 3 }

:calc player_TOP_LIMIT { UL_Y + 3 }
:calc player_LOW_LIMIT { LL_Y - 3 }

#########
#
# The big redo
#
#########
# Positive Axes:
#
#      x--->  @ = 0
#      |
#      V
#
# The signs on the axes reflect a typical 'I'm a graph' sort of layout
# with 0 pointing down the X axis
# We can set a flag based on if the effect of the angle is inverted
# We can set a flag based on if the axes are flipped
# We can set a flag on if we are the 'opposite' of the regular line
# But these flags don't help us really... pick stuff on their own
# The main axis maximum is a combation of two flags
# The off axis maximum is again, a combination
# When we flip the axes, this is an X = Y mirror
# But we could still identify the regions
#
#   -    110 | 111    -
#      -     |     -
#   100   -  |  -   001
#  --------- X ----------  0 
#   101   -  |  -   000
#      -     |     -
#   -    011 | 010    -
#
# But these don't increment naturally at all
# Unless we pick a diagonal as 0, we run into a lot of problems when
# incrementing the zones in a circle in terms of if inidividual flags mean things to us
#                          
#   -    100 | 101    -  
#      -     |     -
#   011   -  |  -   110
#  --------- X ----------
#   010   -  |  -   111
#      -     |     -
#   -    001 | 000    -
#                        0
# But this kind of works
# Bit 1 always reflects a mirroring around the on axis line
# Bit 2 always corresponds with the on axis being horizontal vs vertical
# Bit 3 always corresponds with mirroring both the off axis line and on axis, or, adding 180 degrees
# By picking which diagonal 0 is, we can pick things to line up with 'positive' axes
# And treat the first bit being 0 as being our 'backwards' tan
# Plus, we can use these in a jump table to correctly 
# If we wanted to do this
# jump [address] is a 2 byte instrunction

# We can pick the order of +ve on axis values, if we accept clockwise, so, let's go ahead and do this:
#                        0 
#   -   1100 | 1110   -  
#      -     |     -
#   1010  -  |  -   0000
#  --------- X ----------
#   1000  -  |  -   0010
#      -     |     -
#   -   0110 | 0100   -
#                        

# We need to position our crosshairs on the border of our boundry square now
# We have the current angle in Tr and the current zone in jumpable format in TrZ

# We will already have the rotation table set correctly, so, we don't need to worry about that

:alias enemy_data_size v7
:alias enemy_data_simple_save v2

: main
	
	# pick a random start point
	v0 := random 0b01111110
	i := long random_mob_position
	save v0

	# Generate quick off_axis table
	generate_tan_table
	generate_offaxis_max_table

: game_restart
	plane 1
	clear
	hires

	draw_game_box

	i := enemy_fast_wipe
	load v7
	v8 := 8
	i := enemy_fast_redraw
	loop
		save v7
		v8 -= 1
		if v8 != 0 then
	again

	i := enemy_list_wipe
	load v7
	v8 := 8
	i := enemy_list
	loop
		save v7
		v8 -= 1
		if v8 != 0 then
	again	

	vF := 16
	f_delay

	v0 := 0
	load_level
	

	
	Tx := 64
	Ty := 32
	Tr := 0
	TrZ := 0b0010

	draw_crosshairs_from_memory

	update_trz_code

	v0 := TrZ
	v2 := Tr

	:macro calc_next_crosshair {
		next_crosshair := random 0b00001111
		next_crosshair += 4
	}
	calc_next_crosshair
	jump0 update_rotation_code

	loop

		v0 := 0 if v0 key begin
			:breakpoint q
			v0 += 1
		end

		# Let's handle input:
		# It would be handy to know if the player has not pushed any input

		:alias detect_rot v5
		:alias player_input v6

		player_input := 0
		
		v0 := 0xE if v0 key then jump trigger_pull

		: cross_return

		detect_rot := Tx
		v0 := 7   if v0 key then Tx += -1 # keyboard A
		v0 := 9   if v0 key then Tx +=  1 # keyboard D
		if Tx != detect_rot then player_input += 1

		detect_rot := Ty
		v0 := 5   if v0 key then Ty += -1 # keyboard W
		v0 := 8   if v0 key then Ty +=  1 # keyboard S
		if Ty != detect_rot then player_input += 1

		# We only have to run this code if they push a button:
		if player_input == 0 then jump service_rot

		# Gate player
		if Tx == player_LEFT_LIMIT then Tx += 1 # ie, go right
		if Tx == player_RIGHT_LIMIT then Tx += -1
		if Ty == player_TOP_LIMIT then Ty += 1
		if Ty == player_LOW_LIMIT then Ty += -1

		# We will use v5 to indicate we're trying to change rotation:

		: service_rot
		detect_rot := Tr
		v0 := 4   if v0 key then Tr += -1 # keyboard Q
		v0 := 6   if v0 key then Tr +=  1 # keyboard E
		# Skip rotation update if rotation is unchanged:
		if detect_rot == Tr then jump update_rotation_code_return

		# Here, if detect_rot is 0 and player_input is 0 then we
		# don't need to update our positions

		# if player_input is 1 but detect_rot is 0 then we don't need
		# to update rot

		# if player_input is 0 but detect_rot is 1, then we still
		# need to update stuff

		# 0 0 nothing
		# 1 0 pos only
		# ? 1 both

		# begin
			# This code runs only on r change
			player_input += 1

			if Tr == 45 begin
				Tr := 0
				TrZ += 0b010
				if TrZ == 0b010000 then TrZ := 0
				update_trz_code
			end
			if Tr == -1 begin
				Tr := 44
				TrZ -= 0b010 # mm sugar
				if TrZ == 0b11111110 then TrZ := 0b001110
				update_trz_code
			end
			# Rotation must have changed for us to be here:
			# if __1_, then Tr can be used to index into the tan table normally
			# if __0_, then the correct value is 45 - Tr

			# Here's a mad solution:
			v0 := TrZ
			v2 := Tr
			jump0 update_rotation_code
		# end
		: update_rotation_code_return
			# Here, we KNOW that the player pushed something
			# Can we all directly into the update code?

		# Undraw the existing cursors:
		draw_crosshairs_from_memory

		# Perform duty cycle
		i := frame_cycle_count
		load v0
		v0 += 8
		if v0 == 64 begin

			# calculate small offset to player crosshair
			i := player_crosshair_adjust
			v0 := random 0b00000011
			v0 -= 4
			if v0 == -1 then v0 := -3
			v1 := random 0b00000011
			v1 -= 4
			if v1 == -1 then v1 := -3
			save v1

			v0 := 0
			frame_stepper += 0x80

		end
		i := frame_cycle_count
		save v0

		# If player_input is true then we must redraw
		# if it is 0 then we can use saved values
		if player_input == 0 begin
			# DONT UPDATE STUFF:
			draw_crosshairs_from_memory
			jump bypass_crosshair_update
		end

		if next_crosshair != 0 then next_crosshair += -1

		############ UPDATE STUFF
		# Calculate first:
		DoFirstCrosshair
		: apply_on_axis_main_memory
		apply_on_axis_main
		# cross_x and y are v0 and v1

		# it is INCREDIBLY helpful to retain the original axis values
		: address_crosshair_1_data_memory
		i := crosshair_1_data
		save off_axis

		i := crosshair_b
		if frame_stepper != 0 then i := crosshair_a
		sprite cross_x cross_y 3

		DoSecondCrosshair
		: apply_on_axis_flipped_memory
		apply_on_axis_flipped

		: address_crosshair_2_data_memory
		i := crosshair_2_data
		save off_axis

		i := crosshair_a
		if frame_stepper != 0 then i := crosshair_b
		sprite cross_x cross_y 3

		: bypass_crosshair_update

		# Let's service enemies in the field
		# We don't need to process them all
		# But we do need to process them at all

		## v0 is our current frame cycle value

		service_enemy

		: trigger_return


		if next_crosshair == 1 then jump draw_player_crosshair

		if next_crosshair == 0 begin
			: draw_player_crosshair
			# Draw crosshair

			i := player_crosshair_adjust
			load v1

			i := long player_crosshair
			v0 += Tx
			v1 += Ty
			#v0 -= 3
			#v1 -= 3

			sprite v0 v1 8
		end

		# Try to delay only one 60 fps frame most of the time:
		vf := 1
		f_delay

		if next_crosshair == 1 then jump undraw_player_crosshair
		if next_crosshair == 0 begin
			calc_next_crosshair
			: undraw_player_crosshair
			# Undraw crosshair
			sprite v0 v1 8
		end
		next_crosshair += -1

		i := long register_dump
		save vF




	again




	jump main

: frame_cycle_count
  0

: player_crosshair_adjust
 0 0


: draw_crosshairs_from_memory
	i := crosshair_1_data
	load cross_y
	i := crosshair_b
	if frame_stepper != 0 then i := crosshair_a
	sprite cross_x cross_y 3

	i := crosshair_2_data
	load cross_y
	i := crosshair_a
	if frame_stepper != 0 then i := crosshair_b
	sprite cross_x cross_y 3
;

: crosshair_1_data
 0x5b 0x1F 
 			: crosshair_1_subpixels
 			0x1C 
 				: crosshair_1_onaxis
 				0 0
: crosshair_2_data
 0x22 0x1F
 			: crosshair_2_subpixels
 			0x1D
 				: crosshair_2_onaxis
 				0 0


# These are determined by our current rotation
: apply_on_axis_main
	: simple_axis_apply_target_A
	vF := vF
	vF := vF
;

: apply_on_axis_flipped
	: simple_axis_apply_target_B
	vF := vF
	vF := vF
;

: DoSecondCrosshair
	v0 := TrZ
	vF := 0b1000
	v0 ^= vF
	jump0 SetupOnAxis	# Note shared return path

: DoFirstCrosshair
	v0 := TrZ
	jump0 SetupOnAxis
	############ ->>>>>>>>>>>>

	: AxesReturnPoint
	# Store the final subpixel value into v2:
	v2 := v1

	# This is going to nuke v0 and v1
	cross_x := Tx
	cross_x -= 1
	cross_y := Ty
	cross_y -= 1
;

: SetupOnAxis
# 0000 # On axis: +X, off axis -Y
jump SetupOnPosX
# 0010 # On axis: +X, off axis +Y
jump SetupOnPosX
# 0100 # On axis: +Y, off axis +X
jump SetupOnPosY
# 0110 # On axis: +Y, off axis -X
jump SetupOnPosY
# 1000 # On axis: -X, off axis +Y
jump SetupOnNegX
# 1010 # On axis: -X, off axis -Y
jump SetupOnNegX
# 1100 # On axis: -Y, off axis -X
jump SetupOnNegY
# 1110 # On axis: -Y, off axis +X
jump SetupOnNegY

: SetupOffAxis
# 0000 # On axis: +X, off axis -Y
jump SetupOffNegY
# 0010 # On axis: +X, off axis +Y
jump SetupOffPosY
# 0100 # On axis: +Y, off axis +X
jump SetupOffPosX
# 0110 # On axis: +Y, off axis -X
jump SetupOffNegX
# 1000 # On axis: -X, off axis +Y
jump SetupOffPosY
# 1010 # On axis: -X, off axis -Y
jump SetupOffNegY
# 1100 # On axis: -Y, off axis -X
jump SetupOffNegX
# 1110 # On axis: -Y, off axis +X
jump SetupOffPosX

# 0000
		# On axis: +X, off axis -Y
: SetupOnPosX
	on_axis := UR_X
	on_axis -= Tx
	jump0 SetupOffAxis

: SetupOnNegX
	on_axis := Tx
	on_axis -= UL_X
	jump0 SetupOffAxis

: SetupOnPosY
	on_axis := LL_Y
	on_axis -= Ty
	jump0 SetupOffAxis

: SetupOnNegY
	on_axis := Ty
	on_axis -= UL_Y
	jump0 SetupOffAxis


: SetupOffPosX
	off_axis := UR_X
	off_axis -= Tx
	jump get_off_axis

: SetupOffNegX
	off_axis := Tx
	off_axis -= UL_X
	jump get_off_axis

: SetupOffPosY
	off_axis := LL_Y
	off_axis -= Ty
	jump get_off_axis

: SetupOffNegY
	off_axis := Ty
	off_axis -= UL_Y
	jump get_off_axis


: draw_game_box

	v0 := UL_X

	v1 := UL_Y
	v2 := LL_Y

	i := line_h

	loop
		sprite v0 v1 1
		sprite v0 v2 1

		v0 += 8
		if v0 != UR_Max8 then
	again

	i := line_h_2
	sprite v0 v1 1
	sprite v0 v2 1

	

	v0 := UL_X
	v1 := UR_X
	v2 := UL_Y_plus1

	i := line_v

	loop
		sprite v0 v2 8
		sprite v1 v2 8

		v2 += 8
		if v2 != LL_Max8 then
	again

	v0 := 95
	v1 := 1

	v2 := 0
	v3 := 5

	i := long qtex_clean
	loop
		sprite v0 v1 5
		v0 += 8
		v2 += 1
		i += v3
		if v2 != 4 then
	again

;

: get_off_axis
	# Takes:
	# on_axis: the large value of the triangle
	# off_axis: the maximun acceptable value for the triangle

	# Returns:
	# on_axis on final axis vector
	# off_axis off final axis vector
	# 

	:alias work_rot v2
	:alias WIP_off v5

	# Yep you guessed it self modifying code:
	:next quick_rot_for_axis
	work_rot := 0x00

	# if they're literally presenting a 0 degree angle, then, we have no off axis to calculate
	if work_rot == 0 begin
		off_axis := 0
		v1 := 0x80
		# Obviously, this is already the case:
		# on_axis := on_axis
		jump AxesReturnPoint
	end

	if work_rot == 45 begin
		# This case is a little more complicated, but in essence

		# if we need to remember to set v1 register to subpixels count
		# then we can do that here:
		v1 := 0x80

		# What on and off axis are is... vague
		# But if either axis is less than the other then that's the minimum

		if on_axis > off_axis then on_axis := off_axis
		if off_axis > on_axis then off_axis := on_axis
		jump validated_off_axis
		end
	
	
	# Also modify our backup plan memory read as this is the unadjusted base of the table
	# This is whe data we want to adjust:
	: offaxis_mem_read_base
	i := long quick_tan_table
	:calc offaxis_mem_read { offaxis_mem_read_base + 2 }

	i += on_axis
	i += on_axis

	load v1
	# v0 will be total off axis displacement
	# v1 will be the remaining subpixels at this point

	WIP_off := v0


	if WIP_off > off_axis begin
		# unfortunately, this exceeds our stated maximum
		# We could raycast however we can also precompute the best result
		# for every one of these, like we do for the on_axis read

		# if we do this then we lose the knowledge of what our subpixels are
		# Maybe it's best just to get our subpixels again when we need them?

		WIP_off := off_axis
		0xF0 00
		: off_axis_table_address
		0 0

		i += off_axis
		load v0

		:monitor off_axis_table_address 2
		# We must not exend on access though:
		if v0 < on_axis then on_axis := v0
	end
	# otherwise this is a perfectly find on axis length
	off_axis := WIP_off

	: validated_off_axis
	# If this off axis in excess of our maximum?
	# Who knows
	jump AxesReturnPoint


: set_i_to_offaxis
	0xF0 00
	: mem_generic_off_axis
	0 0
;



# This is a jump table
# We are going to receive one of the 8 zones here:
# Uses up code, but is in principal faster than anding out the bits.
# Maybe
# jump0 -> jumpT -> Entry
# vF := 0b10 -> vf &= TrZ -> if vf then Entry / Entry
: update_rotation_code
	jump flip_rotation
	jump leave_rotation

	jump flip_rotation
	jump leave_rotation

	jump flip_rotation
	jump leave_rotation

	jump flip_rotation
	jump leave_rotation
	# Rotation must have changed for us to be here:
	# if __0_, then the correct value is 45 - Tr
	# if __1_, then Tr can be used to index into the tan table normally

# We save a copy of the normalisd rotation into memory here
: rotation_normalised
	0
# v0 will be a safe copy of TrZ
# v2 is a copy of the rotation
: flip_rotation
	v1 := 45
	v2 =- v1
: leave_rotation
	# At this time v2 now contains our correct rotation value for our tables:
	# v2: Rotation to use for quick_tan

	# let's save this
	v0 := v2
	i := rotation_normalised
	save v0

	# We need to obtain the memory address of the pregenerated memory from quick_tan
	i := long quick_tan
	# Add rotation, twice:
	i += v2
	i += v2
	load v1
	# v0 v1 now contain the correct value for the starting memory address for this rotation

	i := offaxis_mem_read
	save v1

	i := long quick_off_axis
	i += v2
	i += v2
	load v1
	i := off_axis_table_address
	save v1
	i := mem_generic_off_axis
	save v1

	# Also, set the value for rotation in get_off_axis:
	v0 := v2
	i := quick_rot_for_axis
	save v0

	jump update_rotation_code_return

	# Technically we only need to like, do this, if TrZ has changed:
: update_trz_code
	# put a doubled version in vE
	vE := TrZ
	vE += TrZ

	i := long simple_axis_apply
	i += vE
	load v3

	i := simple_axis_apply_target_A
	save v3

	# put the correct value to bitflip to the opposrite side:
	vF := 0b10000
	vE ^= vF
	i := long simple_axis_apply
	i += vE
	load v3

	i := simple_axis_apply_target_B
	save v3

	# Then we must return, and, we jumped here, so
;

: trigger_pull
	# We want to strobe a pixel from crosshair_a to crosshair_b
	# We know the real positions of these crosshairs in crosshair_1_data
	# And we know the on and off axis values relative to the player

	v2 := random 0x01
	if v2 == 0 then	i := address_crosshair_1_data_memory
	if v2 == 1 then i := address_crosshair_2_data_memory
	load v1
	i := pull_trigger_internal_loop
	save v1
	if v2 == 0 then	i := apply_on_axis_flipped_memory
	if v2 == 1 then i := apply_on_axis_main_memory
	load v1
	i := pull_trigger_internal_loop_apply_memory
	save v1

	
	# Load up the on subpixels and onaxis value for crosshair 1
	i := crosshair_1_subpixels
	load v1

	# v0 = subpx of crosshair 1
	# v1 = on axis of crosshai r1

	# We could Copy subpixels into subpixel accumulating register
	# But we might not be starting from here.
	# So we don't
	# v2 := v0
	# v1 is our current on axis

	# So load up just this value from crosshair 2:
	i := crosshair_2_onaxis
	load v0
	# Add the two onaxis values together
	v1 += v0

	# Save to a register
	v6 := v1
	# And fix the remaining offset:
	v6 += -1

	# Load up the normalised rotation:
	i := rotation_normalised
	load v0

	# Look up the memory location for subpixels per frame:
	i := long tan_table
	# Step in by rotation
	i += v0
	# Load it up
	load v0
	# Store it for later!
	subpx_step := v0

	# Now, since we actually want every pixel between the two locations
	# It's more code efficient to actually math it out rather than use our tables

	vE := 0
	
	i := 0x180
	save v6

		# Our loop here:
		# v0 = cross_x
		# v1 = cross_y
		# v2 = subpixel accumulator
		# v3 = on_axis
		# v4 = off_axis
		# v5 = subpx_step
		# v6 = distance_countdown
		# v7 = check for collisions with player sweep
		# v8 = end condition
		# vE = Allows for the delay of frames

	# Draw the line
	# in theory if we hit something we're not supposed to, we need to crash out
	v7 := 1
	v8 := 0

	pull_trigger_internal_loop
	if v7 == 2 begin
		# if we hit something bad, we have to undraw the line we drew, and skip 
		# collision testing
		jump line_abort_point
	end
	
	
	q_delay

	# We now juse the graphics planes to avoid having to undraw all the enemies by just only drawing them
	# into the plane 2 where the line currently resides
	# We have to remove all enemies first and test them individually against the line
	# Turn off collisions:
	#v5 := 0
	# Remove them all:
	#sweep_enemies
	#sweep_trash
	
	# Activate collision detection
	v5 := 1
	# Test one at a time (as part of v5 being on)
	sweep_enemies
	sweep_trash

	# if v7 is 0 then we got all the trash:
	if v7 == 0 begin
		#:breakpoint level_complete
		v0 := v0
		jump game_restart
	end

	# turn off collision check
	#v5 := 0
	# And restore the enemies:
	#sweep_enemies
	#sweep_trash

	: line_abort_point
	# Then undraw the line:
	i := 0x180
	# restore how many pixels to draw
	load v6
	v7 := 0
	if v8 != v6 then pull_trigger_internal_loop

	plane 1

	jump trigger_return
	
: trigger_quick_mem
 0 0

 : sweep_trash
 	# use v6 to count in 3s
 	v6 := 0
 	# Use v5 to count linearly now:
 	v5 := 0
 	#plane 1

 	# We can also use v7 at this time:

 	v7 := 0

 	#if v5 == 1 then 
 	plane 2
 	loop
	 	i := long quick_trash
	 	i += v6
	 	load v2

	 	if v2 == -1 then jump skip_trash_sweep

	 	# At least 1 item of trash remains
	 	v7 += 1

	 	i := long furniture
	 	i += v2
	 	sprite v0 v1 8

	 	#if v5 != 0 begin
	 		vE := vF
			sprite v0 v1 8
	 		if vE != 0 begin

	 			v7 += -1
				plane 1
				sprite v0 v1 8
				


				v2 := v5
				calc_trash_ui_pos

				v0 -= 1
				v1 -= 1 
				
				i := long trash_get
				#sprite v0 v1 0
				plane 2
				sprite v0 v1 0

	 			i := long level_reset_data
	 			load v2
	 			i := long quick_trash
	 			i += v6
	 			save v2
	 		end
	 	#end

	 	: skip_trash_sweep
 		v6 += 3
 		v5 += 1

 		if v6 != 27 then
 	again

 ;

: sweep_enemies
	v6 := 0

	#plane 1
	#if v5 == 1 then
	plane 2

	loop
		i := long enemy_fast_redraw
		i += v6
		load v3

		if v3 == -1 then jump trigger_skip_empty_mob
		i := long brushable_mobs
		i += v2

		sprite v0 v1 8
		# Test vF here perhaps
		#if v5 == 1 begin
			vE := vF
			sprite v0 v1 8
			if vE == 0 begin
				# This enemy did not touch our line, we can undraw it to stop testing
				jump trigger_skip_empty_mob
			end

			plane 1
			sprite v0 v1 8
			plane 2

			# Otherwise it does collide, specifically with our line
			# If that happens, we could remove it from the game here
			# That depends on us knowing that the line is good
			# and did not collide with anything it shouldn't be allowed to

			# We can use graphics planes to acheive the above perhaps

			# But let's remove this enemy from the redraw list:
			i := long enemy_fast_wipe
			load v3
			i := long enemy_fast_redraw
			i += v6
			save v3

			# And also request that it be removed
			remove_enemy
		#end

		: trigger_skip_empty_mob
		v6 += 0x08
		if v6 != 64 then
	again
;


: pull_trigger_internal_loop	# This label is used to change
		# Plot to the starting point:						|
		i := crosshair_2_data	# <-------------------------- this command
		load v2
		cross_x += 1
		cross_y += 1

		# We know that v2 contains the subpixels achieved by the line when it hit the barrier
		# But we are going to be counting backwards
		# So let's just invert this value and call it good:

		vF := 0xFF
		v2 ^= vF
		v2 += 1

		plane 2
		
		loop
			# We can just step on 1 pixel at a time:
			on_axis := 1
			off_axis := 0
			v2 += subpx_step
			if vf != 0 then off_axis := 1
			# Easy 45 degree mode:
			if subpx_step == 0xFF then off_axis := 1
			
			# If I wanted to reverse this, I would call the other command
			# And start at the other coords
			: pull_trigger_internal_loop_apply_memory
			apply_on_axis_main

			i := line_v
			sprite cross_x cross_y 1

			if v7 == 0 then vF := 0

			if vF != 0 begin
				# We've hit something we're not allowed to
				# We have to abort this line

				on_axis := 5
				off_axis := 4

				v8 := v6

				loop
					buzzer := off_axis
					vF := 8
					f_delay
					on_axis -= 1
					if on_axis != 0 then
				again

				sprite cross_x cross_y 1
				v7 := 2
				return
			end


			vE += 0b01000000
			if vE == 0 begin
				q_delay
			end

			v6 += -1

			if v6 != v8 then
		again

		plane 1
;

: q_delay
	vf := 1
: f_delay
	delay := vf
	loop
		vf := delay
		if vf != 0 then
	again
;

# So let's do it with actual code, at run time, because we can!
: generate_tan_table
	# I want to generate a table of
	# whole px, subpx for each distance value, per angle
	# Max distance is 8 * 7, so let's assume ~63 for easy data stride
	# Angle is from (in principal) 0 to in principal (45)
	# But we start with 1 because 0 is... all 0s

	Tr := 1

	# So, this code runs over the whole rotation space and yields the off_axis value for an on_axis displacement
	# We have a 2nd table, which works in the reverse - the maximum on_axis displacement for a given off_axis (per rotation)
	# We also want access to the remainder subpixels for a given on axis displacement.
	# This allows us to pull subpixels per step from tan_table and still know where to start,
	# when drawing a line, as we define our starting point as a vague point on the line
	# (to allow for simple player control that feels good)
	# Either I can work this out on hit, or, I can form a table
	# This code here is able to generate table 1 and table 3,
	# but the process of having the correct final result for the subpixels is muddied
	# You only need this when you try to draw a line, so it's just making the 
	# hot loop slower to ensure we have these to handy
	# So, how can we change this code so that it generates the subpixel table separately?

	loop
		# Pull our incrimental subpixel value for this rotation:
		i := long tan_table
		i += Tr
		load v0

		# I have a problem.
		# I want to self modify this code:
		: tangen_address_base
		i := long quick_tan_table
		:calc code_tangen_address { tangen_address_base + 2 }
		# fortunately we modify this AFTER we have already used it, later in this loop
		# Otherwise I can't use calc?

		:monitor tangen_address_base 8

		# Register set up per pass:
		# Initial sub pixels:
		v1 := 0x80 
		v3 := 0
		# Copy subpixels to another, safe register:
		subpx_step := v0 # v5 will be subpix per step
		v0 := 0  # v0 will be total displacement

		# We will have I pointing at the correct location of this extended tan data
		# We save the 0 value to prevent complicated maths. Same reason we start with r 0

		loop
			# We will change this to v1 for a 2nd pass:
			:next generate_tan_table_value_retain
			#v0 := v2
			# Save current data (and step on)
			save v1

			# Incriment subpixels:
			v1 += subpx_step
			# If this overflows, we increase displacement in v0
			if vf != 0 then v0 += 1

			# v3 counts up:
			v3 += 1
			# Do this 63 times:
			if v3 != 64 then
		again

		i := code_tangen_address
		load v1

		# We now have the memory address of the data for quick_tan_table + r * 64 in our v0 and v1
		# Turns out we want that in our quicktan table:
		: generate_tan_table_lookup_base_address
		i := long quick_tan

		# Set vD to 180 for subpixel table
		i += vD

		# Incriment I by 2x Tr
		i += Tr
		i += Tr
		save v1
		
		# Then work out the next address:
		v2 := 0x80 # Data is 128 bytes each:
		v1 += v2
		if vf != 0 then v0 += 1

		# Then we save that into our next pass's I command so we work out the next piece of data
		i := code_tangen_address
		save v1

		# Step forward I:
		Tr += 1

		# OK I now have a mad table

		if Tr != 45 then
	again
;


	

: generate_offaxis_max_table
	# So, we also want a table that allows us to figure out the maximum value 
	# of an on_axis line if the off_axis has to be clamped to some lower value
	# We could either search through the displacement data (eg as a binary search)
	# or we can create a table that gives us the answer

	Tr := 1

	# Steal the last valid good memory address from the other function:
	i := code_tangen_address
	load v1
	i := offaxis_gen_memory_target
	save v1

	# We could use our existing table to work this out but it's actually slightly
	# easier to work from scratch
	# typical offset is quick_tan_table + 5632
	loop
		i := long tan_table
		i += Tr
		load v0
		subpx_step := v0

		# v0 as on_axis will be the maximum value that we can count to before we overflow to the next pixel.
		v0 := 0
		# off axis:
		off_axis := 0

		# This time, subpixels will be 0:
		v2 := 0x00
		
		# We will use the overflow to indicate when we've found the next 

		# i := long
		0xF0 00
		: offaxis_gen_memory_target
		00 00

		# if you want to go 0 px off axis, you can go... 0?
		save v0

		loop
			v0 += 1
			v2 += subpx_step
			if vF != 0 begin
				# the current value of on axis is the maximum value for this off axis
				save v0
				# i will step on by off_axis amount
				off_axis += 1
				end


			if v0 != 63 then
		again

		save v0
		off_axis += 1

		v0 := 0xFF
		save v0
		off_axis += 1

		i := offaxis_gen_memory_target
		load v1

		# update the table, I guesss!!!

		i := long quick_off_axis
		i += Tr
		i += Tr
		save v1

		v1 += off_axis
		v0 += vF
		i := offaxis_gen_memory_target
		save v1

		Tr += 1
		
		if Tr == 45 begin
			# the next memory address is set up correctly
			i := final_off_axis_save
			save v1
			
			i := long quick_off_axis
			i += Tr
			i += Tr
			save v1
		
			
			0xF0 00
			: final_off_axis_save
			0 0 
			
			v0 := 0
			v1 := 1
			v2 := 2
			
			save v1
			
		end

		if Tr != 45 then
	again
	
	# We also want a 1 pixel deep final value for 45 degrees
	
	

;

: service_enemy
	# v0 is the current value of frame cycle
	# which atm is a value of 0b????0000

	# v0 := Current movement type    --------- (gets moved elsewhere)
	# v1 := Current movement subframe --------- (gets moved elsewhere)
	# v2 := mob_frame : Current animation Frame
	# ------------ Easy Save separation
	# v3 := mob_x : Grid X position
	# v4 := mob_y : Grid Y position
	# v5 := mob_type : Type of enemy, useful for working out graphic and movement type
	# v6 := movement index
	# v7 := 
	# ------------------
	# v8 := infinite loop protection when deciding next movement type
	# v9 := movement subframe relocate
	# vA := mob movement type
	# vB mob_data_spacing
	# vC mob_draw_y
	# vD mob_draw_x
	# vE 

	:alias mob_frame v2
	:alias mob_x v3
	:alias mob_y v4
	# 8 bytes per mob
	:alias mob_type v5
	:alias mob_movement_index v6
	:alias mob_speeder v7

	:alias mob_infinite_loop_protection v8
	:alias mob_movement_type vA
	:alias mob_movement_subframe v9

	:alias mob_data_spacing vB
	:alias mob_draw_x vD
	:alias mob_draw_y vC

	i := frame_cycle_count
	load v0

	i := enemy_list
	i += v0
	# Keep this for a hot minute in case we need it:
	vE := v0
	load enemy_data_size

	# This will load our enemy into our registers v0 to v7?

	# If there's no mob here, we skip:
	if mob_type == -1 then jump maybe_create_enemy
	# We need to get the display position of this mob:
: enemy_created
	# Backup our registers
	i := 0x180
	save vF

	# Copy our data over to our retaining registers:
	mob_movement_type := v0
	mob_movement_subframe := v1

	# Step A: Load up the X/Y coords into mob_x mob_y

	# Now because we save the enemy position we don't need to do this:
	# calc_mob_draw_xy


	# mob_type is now a 0x8 strided list
	# load up the sprite spacing for this sprite:
	# i := mob_spacing
	# i += mob_type
	# load v0
	# mob_data_spacing := v0

	# If the mob frame is -1, then it's the first time it's ever been drawn
	# In this case we don't need to undraw it:
	if mob_frame == -1 begin
		mob_frame := 0
		mob_movement_subframe := 16
		jump mob_skip_undraw
	end

	# Step B: we also need to know the enemy's last displacement:
	# This uses movement_type and movement_subframe to load up the offsets
	# into v0 and v1
	# then we add in the base draw position of this enemy:

	# We can do this:
	#load_movement_subdata
	#v0 += mob_draw_x
	#v1 += mob_draw_y
	# But instead we can do this:
	i := long enemy_fast_redraw
	i += vE
	load v1
	# We could load v2 and get the below offset, but we already have it:

	# Point I at the sprite:
	i := brushable_mobs
	i += mob_type
	i += mob_frame

	# Undraw the enemy:
	sprite v0 v1 8

	# Iterate the frame every time we process this enemy, so that
	# it always does a little dance
	# conviniently, the sprites are strided by 0x80
	mob_frame += 0x80

	# And move it only half the time.
	# it would be cool if we could make some mobs move faster or slower:

	mob_speeder -= 1

	:const mob_speed_offset 0

	if mob_speeder == 0 begin
		i := long default_mob_datas
		i += mob_type
		v0 := mob_speed_offset
		load v0
		mob_speeder := v0
		mob_movement_subframe += 2
	end
	
	# Cycle the mob frame


	if mob_movement_subframe == 16 begin
		# We have completed our movement.
		# We marked our new cell as ours when we started moving.
		# So we must clear our current cell:

		# If it's a type of movement that actually moves:
		if mob_movement_type != 0 begin
			v0 := mob_x
			v1 := mob_y
			address_game_cell
			i := long game_grid
			i += v1
			v0 := -1
			save v0
			
			# Get single digit translation:
			mob_movement_subframe := 0
			# We pick the subframe assoicated with 1 px offset
			# But instead apply that to the grid:
			load_movement_subdata
			mob_x += v0
			mob_y += v1
			# New position marked
		end

		: mob_skip_undraw
		# We should progress to the next part of their movement at this time

		mob_infinite_loop_protection := 0
		# We need to apply the kind of movement that we hoped to achieve
		: mob_movement_jumpback
		mob_infinite_loop_protection += 1
		if mob_infinite_loop_protection == 6 then jump mob_loop_fail
		# We need to defend against infinite loops at this time
		if mob_movement_index == 16 then mob_movement_index := 0
		# mob movement index is the reference from the start of this mob's movement pattern that we're at
		i := enemy_behaviors
		i += mob_type
		i += mob_type
		i += mob_movement_index
		# There are up to 16 kinds of thing that move with this system
		# Each type of movement has 16 bytes available to it
		# Load 2 bytes associated with movement
		load v1

		# If we've reached the end:
		# Go back to the start
		if v0 == -1 begin
			mob_movement_index := 0
			jump mob_movement_jumpback
		end

		# We just loaded from memory
		# v0 is our new movement type
		# v1 is our conditional

		# we need to do some math thinking stuff here
		# so we're going to need v0 and v1 shipped somewhere else
		mob_movement_type := v0
		vE := v1

		if mob_movement_type == -2 begin
			mob_movement_type := random 0b00110000
			mob_movement_type += 16
		end

		# A non 0 movement type is obviously acceptable:
		if mob_movement_type == 0 then jump movement_auto_valid

		# we need to look up the cell associated with this new position:
		mob_movement_subframe := 0
		load_movement_subdata
		v0 += mob_x
		v1 += mob_y
		address_game_cell

		# v0 : cell data
		# v1 : cell address

		# If v0 is -1, then it's fine

		# if v0 is NOT -1, then, we can't move right now
		if v0 != -1 begin
			# What we do now depends on the value of vE
			# Progression rules:
			# We also have conditionals
			# 0: Progress regardless
			# 1: Repeat until impossible
			# 2: Retry until successful

			# Progress anyway
			if vE == 0 begin
				# Just defer movement type to 0:
				: mob_loop_fail
				# This prevents us from experiencing another result:
				vE := 0
				mob_movement_type := 0
				mob_movement_index += 2
			end

			# This movement is impossible, so we should actually progress to the next movement
			if vE == 1 begin
				# We want to progress on a step:
				mob_movement_index += 2
				# This can create an infinite loop if the enemy is unable to progress in any direction:
				jump mob_movement_jumpback
			end

			if vE == 2 begin
				# We want to do nothing for this frame, but not progress:
				mob_movement_type := 0
				# If we can't move because it's a bad coord, we'll never succeed!!
				# So progress anyway:
				if v0 == -2 then mob_movement_index += 2
			end
		end

		if v0 == -1 begin
			# Load up this enemy ID:
			i := frame_cycle_count
			load v0
			# Target the game_grid and save our ID into it:
			i := long game_grid
			i += v1
			save v0

			: movement_auto_valid
			# If we can move into this location
			# Then v1 = 0 == progress
			#      v1 = 1 == don't progress yet
			#      v1 = 2 == progress
			if vE != 1 then mob_movement_index += 2
		end

		# we need to save the whole enemy in this case

		mob_movement_subframe := 0
	end

	calc_mob_draw_xy
	load_movement_subdata
	# Re index to sprite frame:

	v0 += mob_draw_x
	v1 += mob_draw_y

	# Take a copy of exactly where we drew this enemy on the screen:
	i := temp_e_data_b
	save v1

	i := long brushable_mobs
	i += mob_type
	i += mob_frame

	# This is the exact position of where the mob is drawn
	sprite v0 v1 8

	# Right now, v0 and v1 contain the information I want about the sprite position
	# mob_type + mob_frame consitute a < 256 byte offset to the graphic

	i := frame_cycle_count
	load v0
	i := enemy_list
	i += v0

	# Keep the offset somewhere
	vE := v0

	# Save our updated enemy data
	# We move this data back into the save memory region:
	v0 := mob_movement_type
	v1 := mob_movement_subframe
	save enemy_data_size


	# Load up the X Y draw positions:
	i := temp_e_data_b
	load v1
	# For the purposes of collsion, we want to quickly undraw this enemy
	# Let's save the X Y position into a list
	# Note that mob_frame IS v2
	v2 += mob_type
	v3 := mob_type

	# Generate fast redraw info
	i := long enemy_fast_redraw
	i += vE
	save v3

	# Restore our regular gameplay registers:
	i := 0x180
	load vF
;

: temp_e_data_b
 0 0


: calc_mob_draw_xy
	i := grid_xy
	i += mob_x
	load v0
	mob_draw_x := v0

	i := grid_xy
	i += mob_y
	load v0
	mob_draw_y := v0

	# Translate over to the start of the grid:
	mob_draw_x += UL_X_plus1
	mob_draw_y += UL_Y_plus1
;

: load_movement_subdata
	v0 := 0
	v1 := 0

	if mob_movement_type == 0 then return
	# movement patterns are strided by 8 pairs of bytes
	i := long movement_patterns
	# we should store the direct access value in this register:
	i += mob_movement_type
	i += mob_movement_subframe
	# load the two small offsets
	load v1
;

: last_enemy
 -8

: maybe_create_enemy
	# vF contains the current enemy slot that is empty
	# I guess I should load an enemy from our hypothetical list of enemies:

	i := last_enemy
	load v0

	v0 += 8
	if v0 == 128 then v0 := 0

	vF := random 0b00001111
	if vF != 0 then return

	i := last_enemy
	save v0

	v2 := v0

	# enemy type is a multiple of 8
	v3 := 0
	# It also is where the current movement step is stored so it has to exist

	# I guess maybe we have to loop this till we find an empty space?
	# Note that this should be a multiple of 16 in order to work
	: retry_get_empty_position
	i := long random_mob_position
	load v0
	v0 += 2
	if v0 == 200 then v0 := 0
	i := long random_mob_position
	save v0
	i += v0
	load v1
	# next X Y coords loaded into v0 v1
	# Set the enemy to these coords
	i := enemy_template_save_target
	save v3

	# Check this cell is actaully available:
	address_game_cell 
	# If not:
	if v0 != -1 then jump retry_get_empty_position

	# If yes:
	# Register this enemy to this location:

	i := long game_grid
	i += v1
	v0 := vE
	save v0

	i := enemy_template
	load v7

	i := enemy_list
	i += vE
	save v7
	# We can now relocate enemy_template v7 to the new memory location

	jump enemy_created
;

: remove_enemy
	# v6 contains the enemy to remove as x8
	i := enemy_list
	i += v6

	# This enemy should be defaulted out
	v0 := 5
	i += v0
	v0 := -1
	save v0

	# additionally, there may be cells associated with it in game_grid
	# These need to be cleared out

	v1 := 0
	i := long game_grid
	loop
		load v0

		if v0 == v6 begin
			i := long game_grid
			i += v1
			v0 := -1
			save v0
		end
		v1 += 1
		if v1 != 49 then
	again
;



: address_game_cell
	# v0 := X pos
	# v1 := Y pos
	if v0 == 255 then jump bad_coord
	if v0 == 7 then jump bad_coord
	if v1 == 255 then jump bad_coord
	if v1 == 7 then jump bad_coord

	i := long game_grid_stride
	i += v1
	v1 := v0
	load v0
	v1 += v0
	i := long game_grid
	i += v1
	load v0
;
: bad_coord
	v0 := -2
	# v0 now has the value of this cell in it
	# v1 now has the relative index to this cell in it
;

: draw_obstacles
	v0 := 0

	i := 0x180
	save vF

	plane 2

	:alias trash_counter v7
	:alias other_trash_counter v8

	mob_y := 0
	loop
		mob_x := 0
		loop
			v0 := mob_x
			v1 := mob_y
			address_game_cell

			# v0 will be content
			# v1 will be offset from game_grid

			if v0 != -1 begin
				mob_type := 128
				mob_type += v0
				if vF == 1 begin	
					# if the item was in the region at 128 or aboutve:
					# We know it's the index of something special

					# We probably want the x8 version of this index:
					v2 <<= mob_type # x2
					v2 <<= v2 # x4
					v2 <<= v2 # x8

					# NO HIT obsticles that must not be hit:
					if mob_type < 16 begin
						plane 2
						# furniture
						calc_mob_draw_xy
						i := furniture
						i += v2

						sprite mob_draw_x mob_draw_y 8
						jump draw_obstacles_pass_trash
					end

					# Trash items which must be cleared:
					if mob_type < 32 begin
						plane 1
						calc_mob_draw_xy

						v0 := mob_draw_x
						v1 := mob_draw_y
						i := long quick_trash
						i += trash_counter
						save v2

						# Draw it because that makes things simpler:
						i := long furniture
						i += v2

						sprite mob_draw_x mob_draw_y 8

						v2 := other_trash_counter
						calc_trash_ui_pos
						sprite v0 v1 8

						trash_counter += 3
						other_trash_counter += 1
					end
				end

				: draw_obstacles_pass_trash
				vF := 8
				f_delay
			end

			mob_x += 1
			if mob_x != 7 then
		again
		mob_y += 1
		if mob_y != 7 then
	again

	plane 1

	i := 0x180
	load vF
;

: calc_trash_ui_pos
	# v2 is trash index
	v0 := 98
	v1 := 8
	if v2 == 0 then jump skip_annoying_math
	loop
		v0 += 9
		:calc what_would_it_be { 98 + 3 * 9 }
		if v0 == what_would_it_be begin
			v1 += 9
			v0 := 98
		end
		v2 -= 1
		if v2 != 0 then
	again
	: skip_annoying_math
;

: load_level
	# level is in... v0?

	# This is the stupid way of loading a level
	i := long levels_load
	# Stride in by 4x
	i += v0
	i += v0
	i += v0
	i += v0
	# Load v4 bytes
	load v3

	i := load_level_source_address
	save v3




	# we need to read 
	v9 := 0
	loop
		i := long level_reset_data
		#i += v9
		load v6
		i := game_grid
		i += v9
		save v6

		v9 += 7
		:calc g_grid_plus_trash { 49 + 4 * 7 }
		if v9 != g_grid_plus_trash then
	again
	v9 := 0

	loop
		: load_level_source_address
		i := long level_lr_1
		i += v9
		load v0

		if v0 == -1 then jump load_level_get_enemies
		v2 := v0
		load v1
		v9 += 3

		# v0 v1 x y, v2 obsticles
		address_game_cell
		i := long game_grid
		i += v1
		v0 := v2
		save v0
	again
	v9 := 0

	: load_level_get_enemies
	# Also draws trash:
	draw_obstacles
	v9 := 0
;

# Ideally these will live in low memory
: crosshair_a
0b10100000
0b00000000
0b10100000

: crosshair_b
0b11100000
0b11100000
0b11100000

:calc FREE { 4096 - HERE }
: FREE_CODE_BYTES
:byte { FREE >> 8 }
:byte { FREE }
:monitor FREE_CODE_BYTES "%2i"


# Ironically it's much easier for us to define vertical columns in memory
# I fixed it now the game grid makes sense
: game_grid_stride
0 7 14 21 28 35 42

: game_grid
-1 -1 -1 -1 -1 -1 -1
-1 -1 -1 -1 -1 -1 -1
-1 -1 -1 -1 -1 -1 -1
-1 -1 -1 -1 -1 -1 -1
-1 -1 -1 -1 -1 -1 -1
-1 -1 -1 -1 -1 -1 -1
-1 -1 -1 -1 -1 -1 -1

: quick_trash # 7 x 4 items:
0 0 0	0 0 0	0 0 0	0 0 0	0 0 0	0 0 0	0 0 0	
0 0 0   0 0 0   0

# I would waste so much memory just writing out the levels
# like this but at least I can see them and decide if they're good

# These are 4 bytes:
: levels_load
# 0
 i := long level_lr_1
 i := long level_lr_2
 i := long level_lr_3
 i := long level_lr_1

: enemies_load
 i := long level_lr_1_enemy
 i := long level_lr_2_enemy
 i := long level_lr_3_enemy
 i := long level_lr_4_enemy
 i := long level_lr_5_enemy
 i := long level_lr_6_enemy

: level_reset_data
-1		-1		-1		-1		-1		-1		-1
#-1		-1		-1		-1		-1		-1		-1
#-1		-1		-1		-1		-1		-1		-1
#-1		-1		-1		-1		-1		-1		-1
#-1		-1		-1		-1		-1		-1		-1
#-1		-1		-1		-1		-1		-1		-1
#-1		-1		-1		-1		-1		-1		-1

:macro ob x { :byte { 0x80 + x } }
#	o_cat		0
#	o_bucket	1
#	o_chair_a	2
#	o_chair_b	3
#	o_drawer	4
#	o_brolly	5
#	o_table_a	6
#	o_table_b	7
#	o_bed_a		8
#	o_bed_b		9
#	o_cot		10
#	o_book_a	11
#	o_sofa_a	12
#	o_sofa_b	13
#	o_stand		14
#	o_book_b	15

:macro tr x { :byte { 0x90 + x } }
# t_muck1 0
# t_muck2 1
# t_muck3 2
# t_cobweb 3
# t_puddle 4
# t_trash 5
# t_cutlery 6
# t_crockery 7
# ? 8 something for the cellar?
# t_books1 9
# t_books2 10
# t_books3 11
# t_shirt 12
# t_robe 13
# t_pillow 14
# t_laundry 15

: levels
# Living Room 1
: level_lr_1
ob 0	1 2
ob 6	6 5
tr 0	2 0
tr 1    5 2
tr 2	3 4
tr 3	0 5
tr 2	6 6
-1

#	 0		1		2		3		4		5		6
#	-1		-1		a		-1		-1		-1		-1	# 0
#	-1		-1		-1		-1		-1		-1		-1	# 1
#	-1		x		-1		-1		-1		a		-1	# 2
#	-1		-1		-1		-1		-1		-1		-1	# 3
#	-1		-1		-1		a		-1		-1		-1	# 4
#	a		-1		-1		-1		-1		-1		x	# 5
#	-1		-1		-1		-1		-1		-1		a	# 6

#	 0		1		2		3		4		5		6
#	-1		-1		-1		-1		-1		-1		-1	# 0
#	-1		-1		-1		-1		-1		-1		-1	# 1
#	-1		-1		-1		-1		-1		-1		-1	# 2
#	-1		-1		-1		-1		-1		-1		-1	# 3
#	-1		-1		-1		-1		-1		-1		-1	# 4
#	-1		-1		-1		-1		-1		-1		-1	# 5
#	-1		-1		-1		-1		-1		-1		-1	# 6

: level_lr_1_enemy
	8
		8 0 0 0 8 8 0 8 

: level_lr_2_enemy
	12
		8 8 16 32 24 16 24 8 16 24 32 32 

: level_lr_3_enemy
	12
		40 40 24 24 24 32 24 32 0 0 24 24 

: level_lr_4_enemy
	11
		56 32 0 56 0 0 56 32 32 32 56 

: level_lr_5_enemy
	9
		16 24 40 40 24 16 16 16 40 

: level_lr_6_enemy
	10
		64 48 64 16 16 48 48 16 64 64 

: level_lr_2
-1		-1		-1		-1		-1		-1		-1
-1		-1		-1		-1		-1		-1		-1
-1		-1		-1		-1		-1		-1		-1
-1		-1		-1		-1		-1		-1		-1
-1		-1		-1		-1		-1		-1		-1
-1		-1		-1		-1		-1		-1		-1
-1		-1		ob 12	ob 13	-1		-1		-1

: level_lr_3
-1		-1		-1		-1		-1		-1		-1
-1		-1		-1		-1		-1		-1		-1
-1		-1		-1		-1		-1		-1		-1
-1		-1		-1		ob 7	-1		-1		-1
-1		-1		-1		-1		-1		-1		-1
-1		-1		-1		-1		-1		-1		-1
-1		-1		-1		-1		-1		-1		-1

: level_lr_4
-1		-1		-1		-1		-1		-1		-1
-1		-1		-1		-1		-1		-1		-1
-1		-1		-1		-1		-1		-1		-1
-1		-1		-1		-1		-1		-1		-1
-1		-1		-1		-1		-1		-1		-1
-1		-1		-1		-1		-1		-1		-1
-1		-1		-1		-1		-1		-1		-1

: level_lr_5
-1		-1		-1		-1		-1		-1		-1
-1		-1		-1		-1		-1		-1		-1
-1		-1		-1		-1		-1		-1		-1
-1		-1		-1		-1 		-1		-1		-1
-1		-1		-1		-1		-1		-1		-1
-1		-1		-1		-1		-1		-1		-1
-1		-1		-1		-1		-1		-1		-1

: level_lr_6
-1		-1		-1		-1		-1		-1		-1
-1		-1		-1		-1		-1		-1		-1
-1		-1		-1		-1		-1		-1		-1
-1		-1		-1		-1		-1		-1		-1
-1		-1		-1		-1		-1		-1		-1
-1		-1		-1		-1		-1		-1		-1
-1		-1		-1		-1		-1		-1		-1


# Let's decide that a level is defined in memory entirely as a grid
# and we draw in obsticles with negative numbers


: simple_axis_apply
# 0000 # On axis: +X, off axis -Y
cross_x += on_axis
cross_y -= off_axis

# 0010 # On axis: +X, off axis +Y
cross_x += on_axis
cross_y += off_axis

# 0100 # On axis: +Y, off axis +X
cross_y += on_axis
cross_x += off_axis

# 0110 # On axis: +Y, off axis -X
cross_y += on_axis
cross_x -= off_axis

# 1000 # On axis: -X, off axis +Y
cross_x -= on_axis
cross_y += off_axis

# 1010 # On axis: -X, off axis -Y
cross_x -= on_axis
cross_y -= off_axis

# 1100 # On axis: -Y, off axis -X
cross_y -= on_axis
cross_x -= off_axis

# 1110 # On axis: -Y, off axis +X
cross_y -= on_axis
cross_x += off_axis

: line_h
0xFF
: line_h_2
0b11000000

: line_v
0x80 0x80 0x80 0x80 0x80 0x80 0x80 0x80

:macro fast_mob X { :byte { X * 8 } }


: player_crosshair
0x28 0x00 0x82 0x00 0x82 0x00 0x28 0x00 


: use_crosshair
0 0 0 0 0 0 0 0


: mob_spacing
: grid_xy
0x00 0x08 0x10 0x18 0x20 0x28 0x30 0x38
0x40 0x48 0x50 0x58 0x60 0x68 0x70 0x78

# 4x32 bytes = 128 bytes
: brushable_mobs
0x00 0x3C 0x70 0xB0 0x18 0x18 0x18 0x7E 0x00 0x00 0x1C 0x3E 0x2A 0x3E 0x3E 0x3E
0x00 0x2C 0x7E 0x6A 0x3C 0x7E 0x5A 0x00 0x00 0x00 0x00 0x0C 0x04 0x0C 0x1E 0x3E
0x00 0x00 0x00 0x3E 0x6B 0x7F 0x3E 0x3E 0x00 0x42 0x66 0x3C 0x18 0x00 0x00 0x00
0x00 0x00 0x00 0x10 0x38 0x3D 0x1E 0x7E 0x00 0x00 0x00 0x00 0xFC 0x56 0x7E 0x1F
0x00 0x28 0xFE 0x7C 0xD6 0x7C 0x28 0x00 0x3C 0xEB 0x7E 0xEB 0xAA 0xAA 0x6A 0x3C
0x00 0x3E 0x2A 0x3E 0x10 0x10 0x38 0x7E 0x33 0x3F 0x7F 0xFF 0xC9 0xFF 0x3F 0x0E
0x24 0x66 0xFF 0xDB 0xFF 0x66 0x24 0x00 0x00 0x18 0x18 0x18 0x18 0x18 0x3C 0x7E
0x00 0x10 0x28 0x8A 0xCB 0xFF 0xBD 0xFF 0x3C 0x24 0x24 0x24 0x24 0x7E 0x5A 0x7E

# And another 128 for their other frame:
0x00 0x3C 0x0E 0x0D 0x18 0x18 0x18 0x7E 0x00 0x1C 0x3E 0x2A 0x3E 0x22 0x22 0x3E
0x00 0x5A 0x3E 0x54 0x7E 0x3E 0x6C 0x00 0x00 0x00 0x0C 0x14 0x04 0x0E 0x1E 0x1E
0x00 0x00 0x63 0x7F 0x2A 0x3E 0x3E 0x1C 0x00 0x00 0x00 0xC3 0x7E 0x18 0x00 0x00
0x00 0x00 0x00 0x20 0x70 0x75 0x3E 0xFE 0x00 0x00 0x00 0x00 0x3E 0x6B 0xFE 0x7C
0x00 0x28 0xFE 0x7C 0xD6 0x7C 0x44 0x00 0x18 0x7E 0x6A 0x3E 0x56 0x56 0x56 0x3C
0x00 0x7C 0x54 0x7C 0x08 0x08 0x1C 0x7E 0x76 0x7E 0xFF 0xFF 0x49 0x7F 0x7E 0x38
0x3C 0x7E 0x7E 0xDB 0x7E 0x7E 0x3C 0x00 0x00 0x18 0x18 0x18 0x18 0x3C 0x7E 0x3C
0x18 0x04 0x49 0xCB 0xFF 0xBD 0xFF 0x42 0x3C 0x66 0x7E 0x7E 0x00 0x00 0x00 0x00

: furniture
0x00 0x00 0x20 0x4A 0x4E 0x7E 0x3E 0x00 0x18 0x24 0x24 0x3C 0x3C 0x3C 0x38 0x00
0x10 0x30 0x30 0x3E 0x3E 0x36 0x36 0x24 0x1E 0x12 0x12 0x3E 0x7E 0x7E 0x5A 0x48
0x3F 0x7F 0x43 0x7F 0x43 0x7F 0x43 0x7E 0x00 0x10 0x28 0x08 0x1C 0x1C 0x1C 0x18
0x3F 0x7F 0xFF 0xA5 0xA5 0xA5 0xA5 0x84 0x00 0x00 0x3F 0x7E 0x08 0x1E 0x3C 0x00
0x00 0x0F 0x1A 0x3F 0x40 0x7F 0x7F 0x7F 0x00 0xFE 0x4A 0xFE 0x06 0xFE 0xFE 0xFC
0x00 0x20 0x60 0xFF 0xFF 0xFF 0xA5 0x84 0x7F 0xA9 0xA9 0xFF 0x95 0xD5 0xFF 0xAB
0x00 0x0F 0x10 0x2F 0x5F 0x70 0x7F 0x60 0x00 0x3C 0xC2 0xFA 0xF6 0x1E 0xFE 0x0C
0x18 0x1C 0x08 0x08 0x08 0x08 0x18 0x24 0xAB 0xFF 0xA5 0xA5 0xFF 0xD5 0xD5 0xFE

: trash
0x00 0x40 0x3C 0x70 0x4E 0x1E 0x08 0x00 0x00 0x34 0x6E 0x1C 0x66 0x38 0x68 0x00
0x10 0x1C 0x36 0x74 0x6E 0x1E 0x32 0x02 0xF8 0xD7 0xAA 0xC4 0xAA 0x90 0xA8 0xC0
0x6E 0xD9 0x82 0x42 0xC3 0x81 0x52 0x2C 0x00 0x14 0x08 0x1E 0x3F 0x7F 0x7F 0x7E
0x00 0x00 0x2A 0x6E 0x64 0x24 0x24 0x00 0x00 0x06 0x09 0xAF 0xEF 0xED 0xAF 0xE6
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x38 0x4F 0x79 0x4F 0x79 0x7F 0x0E
0x00 0x78 0x5E 0x52 0x56 0x72 0x1E 0x00 0x00 0x00 0x3C 0x24 0x2C 0x24 0x3C 0x00
0x00 0x00 0x3E 0x49 0x6B 0x3A 0x2E 0x3E 0x00 0x36 0x7F 0x7F 0x3E 0x3E 0x3E 0x7F
0x00 0x81 0x7E 0x4A 0x52 0x7E 0x81 0x00 0x00 0x14 0x08 0x3C 0x42 0x42 0x42 0x3C

: trash_get # oversize 16x16 sprite because I hate work
0xC1 0x80 0xE3 0x80 0x77 0x00 0x3E 0x00 0x1C 0x00 0x3E 0x00 0x77 0x00 0xE3 0x80
0xC1 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00

: qtex_clean
0x7A 0x82 0x82 0x82 0x7B 0x0F 0x08 0x0E 0x08 0xEF 0x88 0x14 0x22 0x3E 0xA2 0x88
0xCA 0xA8 0x9A 0x88


: block_cube
0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 

:macro enemy_framework X Y T { 16 0 1 X Y T 
		:byte { T * 16 } 
		0 }

: enemy_template
16 0 -1 
	   : enemy_template_save_target
	   0 0 0 0 
	   		   1

:monitor enemy_template 8

: enemy_list_wipe
enemy_framework 0 0 -1

: enemy_fast_wipe
0 0 0 -1 0 0 0 0


: enemy_fast_redraw
 0 0 0 -1 0 0 0 0
 0 0 0 -1 0 0 0 0
 0 0 0 -1 0 0 0 0
 0 0 0 -1 0 0 0 0

 0 0 0 -1 0 0 0 0
 0 0 0 -1 0 0 0 0
 0 0 0 -1 0 0 0 0
 0 0 0 -1 0 0 0 0

: enemy_list
enemy_framework 1 5 -1
enemy_framework 1 1 -1
enemy_framework 2 1 -1
enemy_framework 3 1 -1
enemy_framework 1 2 -1
enemy_framework 2 2 -1
enemy_framework 3 2 -1
enemy_framework 1 3 -1


	: test_enemy
	# Imagine an enemy:
	# We can definitely go to 8
#   0 1   2   3 4 5   6 7 8
#   Move type
	# move frame
	0 0 # F
		  1 # X Y T
		      2 2 0
		      	  # M N
		      	    0 0

# These are the enemy behavior types that exist
# Each behavior is ?? bytes. Maybe 8

# We also have conditionals
# 0: Progress regardless
# 1: Repeat until impossible
# 2: Retry until successful


: enemy_behaviors
# 0 Wiggler
# Movement Pattern
	# Move sideways one step, then move the other way one subpx_step
	16 0 48 0 	-1 0 0 0 	0 0 0 0  0 0 0 0 
# 1 Chompo
	# move down, wait, move up, wait
	32 0 0 0 	64 0 0 0 	-1 0 0 0 0 0 0 0
# 2 Skulkulon
	# Move one way, then the other
	16 1 48 1	-1 0 0 0	0 0 0 0	 0 0 0 0
# 3 Snaker
	# Legit just does nothing
	0 0 -1 0	0 0 0 0		0 0 0 0	 0 0 0 0

# 4 Angero
	# T shape
	16 0 64 0	32 0 16 0	48 0 64 0  32 0 48 0

# 5 Batato
	# Moves randomly then stops then random again
	-2 0 0 0	-1 0 0 0		0 0 0 0	 0 0 0 0

# 6 Sneil
	# Occasionally moves sideways
	0 0 0 0	   16 0 0 0		0 0 0 0	 48 0 0 0

# 7 Limbox
	# Diagnoals
	0x50 1 0x60 1	0x70 1 0x80 1		-1 0 0 0	 0 0 0 0

# 8 Pincing
	# Sneaks down then swoops back up
	32 0 0 0	32 0 0 0		32 0 64 2	 64 2 64 2

# 9 Borkus
	# Fully Random All the time
	-2 0 -1 0	0 0 0 0		0 0 0 0	 0 0 0 0

# 10 Neck King
	# Moves up then moves down
	64 1 32 1	-1 0 0 0		0 0 0 0	 0 0 0 0

# 11 Blurbinger
	# Does a cool little diagonal dance
	0x50 0 64 0	0x60 0 64 0		-2 0 -2 0	 -1 0 0 0

# 12 Blade-o
# Moves really fast horizontally
	16 1 48 1	-1 0 0 0	0 0 0 0	 0 0 0 0

# 13 Plunge
# Fast vertical movement
	64 1 32 1	-1 0 0 0	0 0 0 0	 0 0 0 0

# 14 Catbox
	# Cross shape
	16 0 48 0   64 0 32 0	48 0 16 0 	32 0 64 0

# 15 Skulligmite
	# Goes around in circles
	64 1 48 1  32 1 16 1 	-1 0 0 0 	0 0 0 0 

: default_mob_datas
# 0 Wiggler
	1 0 0 0 0 0 0 0
# 1 Chompo
	2 0 0 0 0 0 0 0
# 2 Skulkulon
	2 0 0 0 0 0 0 0
# 3 Snaker
	2 0 0 0 0 0 0 0
# 4 Angero
	4 0 0 0 0 0 0 0
# 5 Batato
	2 0 0 0 0 0 0 0
# 6 Sneil
	4 0 0 0 0 0 0 0
# 7 Limbox
	2 0 0 0 0 0 0 0
# 8 Pincing
	1 0 0 0 0 0 0 0
# 9 Borkus
	2 0 0 0 0 0 0 0
# 10 Neck King
	2 0 0 0 0 0 0 0
# 11 Blurbinger
	3 0 0 0 0 0 0 0
# 12 Blade-o
	1 0 0 0 0 0 0 0
# 13 Plunge
	1 0 0 0 0 0 0 0
# 14 Catbox
	1 0 0 0 0 0 0 0
# 15 Skulligmite
	2 0 0 0 0 0 0 0
	


:const movement_length 16

# it's me! Using macros! Hooray!
:macro mpat_s X Y A {
	:byte { X * A }
	:byte { Y * A }
}
:macro mpat_8 X Y { 
 	mpat_s X Y 1
 	mpat_s X Y 2
 	mpat_s X Y 3
 	mpat_s X Y 4
 	mpat_s X Y 5
 	mpat_s X Y 6
 	mpat_s X Y 7
 	mpat_s X Y 8
}

# These will generate eg 1 2 3 4 5 6 7 8 X Y coords for how to move an object per frame
: movement_patterns
# 0
mpat_8  0  0

# 1
mpat_8  1  0
# 2
mpat_8  0  1
# 3
mpat_8 -1  0
# 4
mpat_8  0 -1

# 5
mpat_8  1  1
# 6
mpat_8 -1  1
# 7
mpat_8 -1 -1
# 8
mpat_8  1 -1


: random_mob_position
	0
	2 1	3 4	1 5	1 4
	4 4	1 3	3 3	4 2
	2 3	1 2	5 3	1 1
	3 2	3 5	4 3	5 5
	4 5	5 2	3 1	4 1
	2 4	2 2	5 4	2 5
	5 1	5 5	5 3	1 1
	3 4	2 2	5 1	3 2
	4 2	1 4	2 4	2 1
	2 5	1 2	4 1	4 5
	4 3	5 4	1 3	4 4
	5 2	3 3	2 3	1 5
	3 1	3 5	3 2	4 2
	4 5	2 4	4 4	5 5
	5 3	4 1	3 5	2 5
	2 2	1 1	3 1	1 3
	1 2	5 2	1 5	3 4
	2 3	5 4	2 1	3 3
	5 1	4 3	1 4	2 4
	3 5	2 1	5 1	2 2
	5 4	1 1	3 2	3 4
	5 5	1 3	1 2	1 5
	2 5	4 1	4 5	1 4
	4 2	3 3	5 3	4 4
	3 1	5 2	2 3	4 3


##################################

# Yeah ok, so I wanted to try and use macros and calc to work out things.
# But because I have to put them at the end of my rom, and I can't forward reference them
# Like I can't put a label at the end here, do a calc of that + 128, and use it earlier in the program
# I genuinely have no idea how they bahave, or what tehy're going to do
# So, I just can't use them

# This did work but I'm replacing it with a fixed data table because I don't know how it would impact the labels
# I wanted to use that would follow it:
#:macro d0     X { X X X X X }
#:macro do-45 X { d0 X d0 X d0 X d0 X d0 X d0 X d0 X d0 X d0 X }
#:macro tan-entry {
#	:byte { 256 * tan ( ( HERE - tan_table ) * PI / 180 ) }
#}
#: tan_table
#	do-45 tan-entry

: tan_table # 46 bytes that represent subpixels on the offaxis when incrimenting adjacent by 1
 0x00 0x04 0x08 0x0D 0x11 0x16 0x1A 0x1F 
 0x23 0x28 0x2D 0x31 0x36 0x3B 0x3F 0x44 
 0x49 0x4E 0x53 0x58 0x5D 0x62 0x67 0x6C 
 0x71 0x77 0x7C 0x82 0x88 0x8D 0x93 0x99 
 0x9F 0xA6 0xAC 0xB3 0xB9 0xC0 0xC8 0xCF 
 0xD6 0xDE 0xE6 0xEE 0xF7 0xFF 

: quick_tan # This will be 90 bytes of address information that will correspond with the memory address of 
			# saved off axis positions and subpixels for all rotations from 0 to 45
			# This allows us to load I with quick_tan, add r (0-45) * 2, pull the address
			# set I to that vlaue, and then I += main axis length, and get the off axis

			# Obviously we're going to generate this with code
			# So here come the 0s!
 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 # 32
 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 # 64
 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0  0 0 # 90

# Yep you guessed it:
: quick_sub
 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 # 32
 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 # 64
 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0  0 0 # 90

 : quick_off_axis
 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 # 32
 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0 # 64
 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0  0 0 # 90
 # And then two more, for 45
 0 0

: register_dump
 0 0 0 0 0 0 0 0 
 0 0 0 0 0 0 0 0 

:monitor register_dump 16
:monitor game_grid 49


: quick_tan_table
 	# This will be a ~ 5kb data structure of all our data

:calc probably_offaxis_data { quick_tan_table + 44 * 128 }
:monitor probably_offaxis_data 128
#:monitor quick_off_axis 90

:monitor crosshair_1_data 10
:monitor quick_trash 27