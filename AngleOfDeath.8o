############################################
#                                          #
#    #####          ANGLE                  #
#   #########                              #
#   ##						OF             #
#   #  #####                               #
#   # ### # #					   DEATH   #
#   #  #####							   #
############################################

# What's Missing from Angle of Death

# Title Screen
# Introduction sequence
# Ingame text
# Level Select Animations
# Correct Chapter selection
# Chapter select score record + display
# Proper Enemy Selection for the levels
# Spirit
# Spirit Reaping
# Ending

#5 dogs? 5 Areas?

#Living Room
#Dining Room
#Library
#Bed Room
#Basement

:alias Tx  vD	# target X
:alias Ty  vC	# target Y
:alias Tr  vB   # Rotation
:alias TrZ vA   # Rotation Zone
:alias frame_stepper v9
:alias next_crosshair v8
# v7


# Non critical frame to frame
:alias on_axis v3
:alias off_axis v4
# Convinience
:alias cross_x v0
:alias cross_y v1

:alias subpx_step v5

#### Enemy Handling Aliasses:

:alias mob_frame v2
:alias mob_x v3
:alias mob_y v4
# 8 bytes per mob
:alias mob_type v5
:alias mob_movement_index v6
:alias mob_speeder v7

:alias mob_infinite_loop_protection v8
:alias mob_movement_type vA
:alias mob_movement_subframe v9

:alias mob_data_spacing vB
:alias mob_draw_x vD
:alias mob_draw_y vC

## Calculate gameplay dimensions:

:calc zone { 7 * 8 }

:calc UL_X { -1 + ( 128 - zone ) / 2 }
:calc UL_Y { -1 + ( 64 -  zone ) / 2 }
:calc UL_X_plus1 { UL_X + 1 }
:calc UL_Y_plus1 { UL_Y + 1 }

:calc LL_Y { 0 + ( 64 +  zone ) / 2 }

:calc UR_X { 0 + ( 128 + zone ) / 2 }

:calc UR_Max8 { UL_X + zone }
:calc LL_Max8 { UL_Y_plus1 + zone }

:calc player_LEFT_LIMIT { UL_X + 3 }
:calc player_RIGHT_LIMIT { UR_X - 3 }

:calc player_TOP_LIMIT { UL_Y + 3 }
:calc player_LOW_LIMIT { LL_Y - 3 }

#########
#
# The big redo
#
#########
# Positive Axes:
#
#      x--->  @ = 0
#      |
#      V
#
# The signs on the axes reflect a typical 'I'm a graph' sort of layout
# with 0 pointing down the X axis
# We can set a flag based on if the effect of the angle is inverted
# We can set a flag based on if the axes are flipped
# We can set a flag on if we are the 'opposite' of the regular line
# But these flags don't help us really... pick stuff on their own
# The main axis maximum is a combation of two flags
# The off axis maximum is again, a combination
# When we flip the axes, this is an X = Y mirror
# But we could still identify the regions
#
#   -    110 | 111    -
#      -     |     -
#   100   -  |  -   001
#  --------- X ----------  0 
#   101   -  |  -   000
#      -     |     -
#   -    011 | 010    -
#
# But these don't increment naturally at all
# Unless we pick a diagonal as 0, we run into a lot of problems when
# incrementing the zones in a circle in terms of if inidividual flags mean things to us
#                          
#   -    100 | 101    -  
#      -     |     -
#   011   -  |  -   110
#  --------- X ----------
#   010   -  |  -   111
#      -     |     -
#   -    001 | 000    -
#                        0
# But this kind of works
# Bit 1 always reflects a mirroring around the on axis line
# Bit 2 always corresponds with the on axis being horizontal vs vertical
# Bit 3 always corresponds with mirroring both the off axis line and on axis, or, adding 180 degrees
# By picking which diagonal 0 is, we can pick things to line up with 'positive' axes
# And treat the first bit being 0 as being our 'backwards' tan
# Plus, we can use these in a jump table to correctly 
# If we wanted to do this
# jump [address] is a 2 byte instrunction

# We can pick the order of +ve on axis values, if we accept clockwise, so, let's go ahead and do this:
#                        0 
#   -   1100 | 1110   -  
#      -     |     -
#   1010  -  |  -   0000
#  --------- X ----------
#   1000  -  |  -   0010
#      -     |     -
#   -   0110 | 0100   -
#                        

# We need to position our crosshairs on the border of our boundry square now
# We have the current angle in Tr and the current zone in jumpable format in TrZ

# We will already have the rotation table set correctly, so, we don't need to worry about that


#### The big hopeful redo on code layout
#### Basically: I have grown too frustrated with label issues so here we are.
# We're going to interleave the code and data and have the preprocessor arrange them for us
# Apparently this will resolve most forward reference issues

# in XO-Chip we want to lay out all our graphics data
# in high RAM, and reserve low RAM for code.
# these macros allow us to interleave building up
# each segment of the program:



:calc CODE_POS { 0x200  }
:calc DATA_POS { 0x1000 }
# I genuintely don't know how these actually work. I know what they do, but
# Literally, looking at them, I have no clue:
:macro to-code { :calc DATA_POS { HERE }  :org { CODE_POS } }
:macro to-data { :calc CODE_POS { HERE }  :org { DATA_POS } }

:macro unpack_to_rom ADDRESS {
	:byte { 0xFF & ADDRESS >> 8 }
	:byte { 0xFF & ADDRESS }
}

##############################
# So I have had to impliment to-data, and to-code in order to continue working on this project
# I really genuinely dislike this
# How I've implimented it currently is that, literally all the DATA is at the head of the file now:
# And all the code is afterwards

###############################
## Data I didn't get to yet

to-data

: title_screen_text
0xFE 0x11 0x09 0x41 0x1E 0x37 0x14 0xF9 0x46 0x19 0xFE 0x23 0x18 0x14 0x00 0x5F
0x23 0xFF 

######
#[1,17]stage
#
#par
#
#last
#&
#@
#[94,17]high@
#@
#&
#
#low &
#&
#@
#####

: level_select_text
0xFE 0x01 0x11 0x5A 0x5F 0x00 0x1E 0x14 0xFE 0x01 0x1D 0x4B 0x00 0x55 0xFF 

: level_select_stats_text
0xFE 0x01 0x29 0x37 0x00 0x5A 0x5F 0xFE 0x01 0x2F 0xD7 0xFE 0x01 0x35 0xDC 0xFE
0x5E 0x11 0x23 0x28 0x1E 0x23 0xDC 0xFE 0x5E 0x17 0xDC 0xFE 0x5E 0x1D 0xD7 0xFE
0x5E 0x29 0x37 0x46 0x6E 0xF9 0xD7 0xFE 0x5E 0x2F 0xD7 0xFE 0x5E 0x35 0xDC 0xFF


# [3,29]sweep
# [3,56]&
# [95,1]clean
# [95,56]@

: in_level_text
0xFE 0x03 0x1D 0x5A 0x6E 0x14 0x14 0x4B 0xFE 0x03 0x38 0xD7 0xFE 0x5F 0x01 0x0A
0x37 0x14 0x00 0x41 0xFE 0x5F 0x38 0xDC 0xFF 

###################
# Chapter graphics

# Tutorial garden:
: chapter_art_0
0x00 0x00 0x00 0x00 0x00 0x00 0x01 0x01 0x02 0x02 0x04 0x04 0x08 0x08
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x80 0x80 0x40 0x40 0x20 0x20
0x00 0x00 0x00 0x00 0x00 0x00 0x04 0x04 0x0A 0x0A 0x11 0x11 0x20 0x20
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x80 0x80
0x01 0x02 0x02 0x02 0x02 0x02 0x01 0x03 0x02 0x02 0x1F 0x10 0x10 0x10
0x04 0x8A 0x91 0xE0 0x40 0x80 0x00 0xFF 0x00 0x00 0x80 0x80 0x80 0x8F
0x00 0x00 0xFC 0x84 0x44 0x24 0x14 0xFC 0x04 0x04 0x1F 0x10 0x10 0x10
0x0F 0x01 0x01 0xFF 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
0xE0 0x00 0x00 0xFF 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
0x3F 0x04 0x04 0xFF 0x00 0x00 0x00 0x00 0x00 0x00 0x03 0x3F 0x7E 0x7F
0x80 0x00 0x00 0xFF 0x00 0x00 0x00 0x00 0x0F 0xFF 0xF0 0x80 0x00 0x80
0x10 0x10 0x10 0xFF 0x00 0x03 0x0F 0x7F 0xF0 0x80 0x00 0x00 0x00 0x00
0x89 0x89 0x89 0xFF 0x3F 0xFC 0xE0 0x80 0x00 0x00 0x00 0x00 0x00 0x00
0x10 0x10 0x10 0xFF 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
0x00 0x00 0x00 0x00 0x08 0x14 0x22 0x7F 0x41 0x41 0x41 0x4D 0x4D 0x4D
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x3F 0xFF
0x1F 0x03 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x0F 0xFF 0xFF 0xFC
0xE0 0xFC 0xFF 0x0F 0x07 0x01 0x01 0x07 0x07 0x3F 0xFE 0xF0 0xE0 0x00
0x00 0x00 0x80 0xE0 0xF0 0xF8 0xFC 0xF8 0xF0 0xE0 0x00 0x00 0x00 0x00
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00







: chapter_art_addresses
# 0:
unpack_to_rom chapter_art_0


: sweeps_this_level
0 

: score_this_level
0 0 0

: wipey_wipe
0 0 0 0 0 0 0 0
: levely_wevelly
0 0 0 0 0 0 0 0
0 0 0b0010 0 32 64 0 0

: chapters
-1    0  1  2  3  4  5 0x81
0x80  6  7  8  9 10 11 0x82
0x81 12 13 14 15 16 17 0x83
0x82 18 19 20 21 22 23 0x84
0x83 24 25 26 27 28 29 30

: mul_5
0 5 10 15 20 25 30 35 40 45 50 55 60

: mul_6
0
6
12
18
24
30
36
42

# Level select menu:
# 0: current level
# 1: total levels unlocked
# 2: total levels competed
# 3: current chapter
: level_select_last
 1 1 0 0 0 0 0

# Last Sweeps				 Sweep Par				Player Score Max 					Player Score Min
# 				Last Score					  Player Sweeps Max				  Player Sweeps Min
:macro a_level_save X Y { 0 0 Y 0  0 0 0 0 }

# These levels really are already indexed by their level number:
: levels_saved_scores
a_level_save  0 4
a_level_save  1 4
a_level_save  2 4
a_level_save  3 4
a_level_save  4 4
a_level_save  5 4
a_level_save  6 4
a_level_save  7 4
a_level_save  8 4
a_level_save  9 4
a_level_save 10 4
a_level_save 11 4

: levels_char_position
# Comment is 'stage' number:
40 44 0 # 1
53 42 0 # 2
62 37 0 # 3
52 31 32 # 4
59 25 0 # 5
71 22 0 # 6

# Ironically it's much easier for us to define vertical columns in memory
# I fixed it now the game grid makes sense
: game_grid_stride
0 7 14 21 28 35 42

: game_grid
-1 -1 -1 -1 -1 -1 -1
-1 -1 -1 -1 -1 -1 -1
-1 -1 -1 -1 -1 -1 -1
-1 -1 -1 -1 -1 -1 -1
-1 -1 -1 -1 -1 -1 -1
-1 -1 -1 -1 -1 -1 -1
-1 -1 -1 -1 -1 -1 -1

: quick_trash # 7 x 4 items:
0 0 0	0 0 0	0 0 0	0 0 0	0 0 0	0 0 0	0 0 0	
0 0 0   0 0 0   0

:monitor quick_trash 28

# I would waste so much memory just writing out the levels
# like this but at least I can see them and decide if they're good

# These are 4 bytes:
: levels_load
# 0
 i := long level_lr_1
 i := long level_lr_2
 i := long level_lr_3
 i := long level_lr_4
 i := long level_lr_5
 i := long level_lr_6

: enemies_load
 i := long level_lr_1_enemy
 i := long level_lr_2_enemy
 i := long level_lr_3_enemy
 i := long level_lr_4_enemy
 i := long level_lr_5_enemy
 i := long level_lr_6_enemy

: level_reset_data
-1		-1		-1		-1		-1		-1		-1

:macro ob v X Y { 
	:byte { 0x80 + v } 
	:byte { Y }
	:byte { X }
}
#	o_cat		0
#	o_bucket	1
#	o_chair_a	2
#	o_chair_b	3
#	o_drawer	4
#	o_brolly	5
#	o_table_a	6
#	o_table_b	7
#	o_bed_a		8
#	o_bed_b		9
#	o_cot		10
#	o_book_a	11
#	o_sofa_a	12
#	o_sofa_b	13
#	o_stand		14
#	o_book_b	15

:macro tr v X Y {
	:byte { 0x90 + v }
	:byte { Y }
	:byte { X }
}
# t_muck1 0
# t_muck2 1
# t_muck3 2
# t_cobweb 3
# t_puddle 4
# t_trash 5
# t_cutlery 6
# t_crockery 7
# ? 8 something for the cellar?
# t_books1 9
# t_books2 10
# t_books3 11
# t_shirt 12
# t_robe 13
# t_pillow 14
# t_laundry 15

: levels
# Living Room 1
: level_lr_1
ob 0	1 2
ob 6	6 5

tr 0	2 0
tr 1    5 2
tr 2	3 4
tr 3	0 5
tr 2	6 6
-1

: level_lr_2
ob 1	1 3
ob 4	1 6
ob 5	6 4

tr 3	4 4
tr 4    1 1
tr 1	2 6
tr 5	4 2
-1

: level_lr_3
ob 0	1	5
ob 8	5	3
ob 9	6	3
ob 10	6	0
ob 10	0	2

tr 10	3	2
tr 3	0	2
tr 2	1	3
tr 13	5	4
-1

: level_lr_4
ob 7	6	5
ob 8	0	2
ob 9	1	2
ob 13	1	5

tr 3	2	5
tr 13	2	2
tr 5	4	5
tr 14	4	3
tr 4	5 	6
tr 7	3	1
-1

: level_lr_5
ob 14	1	1
ob 2	1	3
ob 12	4	6
ob 13	5	6
ob 3	6	2
ob 15	4	3

tr 7	3	3
tr 11	6	5
tr 3	1	6
-1


: level_lr_6
ob 4	5	3
ob 5	1	4
ob 10	6	6
ob 11	3	2
ob 14	4	4

tr 13	3	6
tr 7	1	0
tr 14	3	2
tr 6	6	1
tr 15	1	5
-1



#	 0		1		2		3		4		5		6
#	-1		-1		a		-1		-1		-1		-1	# 0
#	-1		-1		-1		-1		-1		-1		-1	# 1
#	-1		x		-1		-1		-1		a		-1	# 2
#	-1		-1		-1		-1		-1		-1		-1	# 3
#	-1		-1		-1		a		-1		-1		-1	# 4
#	a		-1		-1		-1		-1		-1		x	# 5
#	-1		-1		-1		-1		-1		-1		a	# 6

#	 0		1		2		3		4		5		6
#	-1		-1		-1		-1		-1		-1		-1	# 0
#	-1		-1		-1		-1		-1		-1		-1	# 1
#	-1		-1		-1		-1		-1		-1		-1	# 2
#	-1		-1		-1		-1		-1		-1		-1	# 3
#	-1		-1		-1		-1		-1		-1		-1	# 4
#	-1		-1		-1		-1		-1		-1		-1	# 5
#	-1		-1		-1		-1		-1		-1		-1	# 6

: level_lr_1_enemy
	8
		8 0 0 0 8 8 0 8 

: level_lr_2_enemy
	12
		8 8 16 32 24 16 24 8 16 24 32 32 

: level_lr_3_enemy
	12
		40 40 24 24 24 32 24 32 0 0 24 24 

: level_lr_4_enemy
	11
		56 32 0 56 0 0 56 32 32 32 56 

: level_lr_5_enemy
	9
		16 24 40 40 24 16 16 16 40 

: level_lr_6_enemy
	10
		64 48 64 16 16 48 48 16 64 64 

# Let's decide that a level is defined in memory entirely as a grid
# and we draw in obsticles with negative numbers


: simple_axis_apply
# 0000 # On axis: +X, off axis -Y
cross_x += on_axis
cross_y -= off_axis

# 0010 # On axis: +X, off axis +Y
cross_x += on_axis
cross_y += off_axis

# 0100 # On axis: +Y, off axis +X
cross_y += on_axis
cross_x += off_axis

# 0110 # On axis: +Y, off axis -X
cross_y += on_axis
cross_x -= off_axis

# 1000 # On axis: -X, off axis +Y
cross_x -= on_axis
cross_y += off_axis

# 1010 # On axis: -X, off axis -Y
cross_x -= on_axis
cross_y -= off_axis

# 1100 # On axis: -Y, off axis -X
cross_y -= on_axis
cross_x -= off_axis

# 1110 # On axis: -Y, off axis +X
cross_y -= on_axis
cross_x += off_axis

: padded_line_h
0 0 0

: line_h
0xFF
: line_h_2
0b11000000

: line_v
0x80 0x80 0x80 0x80 0x80 0x80 0x80 0x80

:macro fast_mob X { :byte { X * 8 } }


: player_crosshair
0x28 0x00 0x82 0x00 0x82 0x00 0x28 0x00 


: use_crosshair
0 0 0 0 0 0 0 0

: sublevel_arrow_start
  4
 20
 36
 52
 68
 84
100
116

: mul_8
: mob_spacing
: grid_xy
0x00 0x08 0x10 0x18 0x20 0x28 0x30 0x38
0x40 0x48 0x50 0x58 0x60 0x68 0x70 0x78

# 4x32 bytes = 128 bytes
: brushable_mobs
0x00 0x3C 0x70 0xB0 0x18 0x18 0x18 0x7E 0x00 0x00 0x1C 0x3E 0x2A 0x3E 0x3E 0x3E
0x00 0x2C 0x7E 0x6A 0x3C 0x7E 0x5A 0x00 0x00 0x00 0x00 0x0C 0x04 0x0C 0x1E 0x3E
0x00 0x00 0x00 0x3E 0x6B 0x7F 0x3E 0x3E 0x00 0x42 0x66 0x3C 0x18 0x00 0x00 0x00
0x00 0x00 0x00 0x10 0x38 0x3D 0x1E 0x7E 0x00 0x00 0x00 0x00 0xFC 0x56 0x7E 0x1F
0x00 0x28 0xFE 0x7C 0xD6 0x7C 0x28 0x00 0x3C 0xEB 0x7E 0xEB 0xAA 0xAA 0x6A 0x3C
0x00 0x3E 0x2A 0x3E 0x10 0x10 0x38 0x7E 0x33 0x3F 0x7F 0xFF 0xC9 0xFF 0x3F 0x0E
0x24 0x66 0xFF 0xDB 0xFF 0x66 0x24 0x00 0x00 0x18 0x18 0x18 0x18 0x18 0x3C 0x7E
0x00 0x10 0x28 0x8A 0xCB 0xFF 0xBD 0xFF 0x3C 0x24 0x24 0x24 0x24 0x7E 0x5A 0x7E

# And another 128 for their other frame:
0x00 0x3C 0x0E 0x0D 0x18 0x18 0x18 0x7E 0x00 0x1C 0x3E 0x2A 0x3E 0x22 0x22 0x3E
0x00 0x5A 0x3E 0x54 0x7E 0x3E 0x6C 0x00 0x00 0x00 0x0C 0x14 0x04 0x0E 0x1E 0x1E
0x00 0x00 0x63 0x7F 0x2A 0x3E 0x3E 0x1C 0x00 0x00 0x00 0xC3 0x7E 0x18 0x00 0x00
0x00 0x00 0x00 0x20 0x70 0x75 0x3E 0xFE 0x00 0x00 0x00 0x00 0x3E 0x6B 0xFE 0x7C
0x00 0x28 0xFE 0x7C 0xD6 0x7C 0x44 0x00 0x18 0x7E 0x6A 0x3E 0x56 0x56 0x56 0x3C
0x00 0x7C 0x54 0x7C 0x08 0x08 0x1C 0x7E 0x76 0x7E 0xFF 0xFF 0x49 0x7F 0x7E 0x38
0x3C 0x7E 0x7E 0xDB 0x7E 0x7E 0x3C 0x00 0x00 0x18 0x18 0x18 0x18 0x3C 0x7E 0x3C
0x18 0x04 0x49 0xCB 0xFF 0xBD 0xFF 0x42 0x3C 0x66 0x7E 0x7E 0x00 0x00 0x00 0x00

: furniture
0x00 0x00 0x20 0x4A 0x4E 0x7E 0x3E 0x00 0x18 0x24 0x24 0x3C 0x3C 0x3C 0x38 0x00
0x10 0x30 0x30 0x3E 0x3E 0x36 0x36 0x24 0x1E 0x12 0x12 0x3E 0x7E 0x7E 0x5A 0x48
0x3F 0x7F 0x43 0x7F 0x43 0x7F 0x43 0x7E 0x00 0x10 0x28 0x08 0x1C 0x1C 0x1C 0x18
0x3F 0x7F 0xFF 0xA5 0xA5 0xA5 0xA5 0x84 0x00 0x00 0x3F 0x7E 0x08 0x1E 0x3C 0x00
0x00 0x0F 0x1A 0x3F 0x40 0x7F 0x7F 0x7F 0x00 0xFE 0x4A 0xFE 0x06 0xFE 0xFE 0xFC
0x00 0x20 0x60 0xFF 0xFF 0xFF 0xA5 0x84 0x7F 0xA9 0xA9 0xFF 0x95 0xD5 0xFF 0xAB
0x00 0x0F 0x10 0x2F 0x5F 0x70 0x7F 0x60 0x00 0x3C 0xC2 0xFA 0xF6 0x1E 0xFE 0x0C
0x18 0x1C 0x08 0x08 0x08 0x08 0x18 0x24 0xAB 0xFF 0xA5 0xA5 0xFF 0xD5 0xD5 0xFE

: trash
0x00 0x40 0x3C 0x70 0x4E 0x1E 0x08 0x00 0x00 0x34 0x6E 0x1C 0x66 0x38 0x68 0x00
0x10 0x1C 0x36 0x74 0x6E 0x1E 0x32 0x02 0xF8 0xD7 0xAA 0xC4 0xAA 0x90 0xA8 0xC0
0x6E 0xD9 0x82 0x42 0xC3 0x81 0x52 0x2C 0x00 0x14 0x08 0x1E 0x3F 0x7F 0x7F 0x7E
0x00 0x00 0x2A 0x6E 0x64 0x24 0x24 0x00 0x00 0x06 0x09 0xAF 0xEF 0xED 0xAF 0xE6
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x38 0x4F 0x79 0x4F 0x79 0x7F 0x0E
0x00 0x78 0x5E 0x52 0x56 0x72 0x1E 0x00 0x00 0x00 0x3C 0x24 0x2C 0x24 0x3C 0x00
0x00 0x00 0x3E 0x49 0x6B 0x3A 0x2E 0x3E 0x00 0x36 0x7F 0x7F 0x3E 0x3E 0x3E 0x7F
0x00 0x81 0x7E 0x4A 0x52 0x7E 0x81 0x00 0x00 0x14 0x08 0x3C 0x42 0x42 0x42 0x3C

: trash_get # oversize 16x16 sprite because I hate work
0xC1 0x80 0xE3 0x80 0x77 0x00 0x3E 0x00 0x1C 0x00 0x3E 0x00 0x77 0x00 0xE3 0x80
0xC1 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00

#: qtex_clean
#0x7A 0x82 0x82 0x82 0x7B 0x0F 0x08 0x0E 0x08 0xEF 0x88 0x14 0x22 0x3E 0xA2 0x88
#0xCA 0xA8 0x9A 0x88

#: qtex_sweep
#0x7A 0x82 0x72 0x0A 0xF1 0x2F 0xA8 0xAF 0xA8 0x4F 0xBE 0x20 0x3C 0x20 0xBE 0xF0
#0x88 0xF0 0x80 0x80

#: qtex_rank
#0xF0 0x89 0xF2 0x93 0x8A 0x88 0x4C 0x2A 0xE9 0x28 0xA2 0xA4 0xB8 0xA4 0xA2 0x00
#0x00 0x00 0x00 0x00 

#: qtex_score
#0x79 0x82 0x72 0x0A 0xF1 0xE7 0x08 0x08 0x08 0xE7 0x3C 0xA2 0xBC 0xA4 0x22 0xF8
#0x80 0xF0 0x80 0xF8

: block_cube
0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 

:macro enemy_framework X Y T { 16 0 1 X Y T 
		:byte { T * 16 } 
		0 }

: enemy_template
16 0 -1 
	   : enemy_template_save_target
	   0 0 0 0 
	   		   1

:monitor enemy_template 8

: enemy_list_wipe
enemy_framework 0 0 -1

: enemy_fast_wipe
0 0 0 -1 0 0 0 0


: enemy_fast_redraw
 0 0 0 -1 0 0 0 0
 0 0 0 -1 0 0 0 0
 0 0 0 -1 0 0 0 0
 0 0 0 -1 0 0 0 0

 0 0 0 -1 0 0 0 0
 0 0 0 -1 0 0 0 0
 0 0 0 -1 0 0 0 0
 0 0 0 -1 0 0 0 0

: enemy_list
enemy_framework 1 5 -1
enemy_framework 1 1 -1
enemy_framework 2 1 -1
enemy_framework 3 1 -1
enemy_framework 1 2 -1
enemy_framework 2 2 -1
enemy_framework 3 2 -1
enemy_framework 1 3 -1


	: test_enemy
	# Imagine an enemy:
	# We can definitely go to 8
#   0 1   2   3 4 5   6 7 8
#   Move type
	# move frame
	0 0 # F
		  1 # X Y T
		      2 2 0
		      	  # M N
		      	    0 0

# These are the enemy behavior types that exist
# Each behavior is ?? bytes. Maybe 8

# We also have conditionals
# 0: Progress regardless
# 1: Repeat until impossible
# 2: Retry until successful


: enemy_behaviors
# 0 Wiggler
# Movement Pattern
	# Move sideways one step, then move the other way one subpx_step
	16 0 48 0 	-1 0 0 0 	0 0 0 0  0 0 0 0 
# 1 Chompo
	# move down, wait, move up, wait
	32 0 0 0 	64 0 0 0 	-1 0 0 0 0 0 0 0
# 2 Skulkulon
	# Move one way, then the other
	16 1 48 1	-1 0 0 0	0 0 0 0	 0 0 0 0
# 3 Snaker
	# Legit just does nothing
	0 0 -1 0	0 0 0 0		0 0 0 0	 0 0 0 0

# 4 Angero
	# T shape
	16 0 64 0	32 0 16 0	48 0 64 0  32 0 48 0

# 5 Batato
	# Moves randomly then stops then random again
	-2 0 0 0	-1 0 0 0		0 0 0 0	 0 0 0 0

# 6 Sneil
	# Occasionally moves sideways
	0 0 0 0	   16 0 0 0		0 0 0 0	 48 0 0 0

# 7 Limbox
	# Diagnoals
	0x50 1 0x60 1	0x70 1 0x80 1		-1 0 0 0	 0 0 0 0

# 8 Pincing
	# Sneaks down then swoops back up
	32 0 0 0	32 0 0 0		32 0 64 2	 64 2 64 2

# 9 Borkus
	# Fully Random All the time
	-2 0 -1 0	0 0 0 0		0 0 0 0	 0 0 0 0

# 10 Neck King
	# Moves up then moves down
	64 1 32 1	-1 0 0 0		0 0 0 0	 0 0 0 0

# 11 Blurbinger
	# Does a cool little diagonal dance
	0x50 0 64 0	0x60 0 64 0		-2 0 -2 0	 -1 0 0 0

# 12 Blade-o
# Moves really fast horizontally
	16 1 48 1	-1 0 0 0	0 0 0 0	 0 0 0 0

# 13 Plunge
# Fast vertical movement
	64 1 32 1	-1 0 0 0	0 0 0 0	 0 0 0 0

# 14 Catbox
	# Cross shape
	16 0 48 0   64 0 32 0	48 0 16 0 	32 0 64 0

# 15 Skulligmite
	# Goes around in circles
	64 1 48 1  32 1 16 1 	-1 0 0 0 	0 0 0 0 

: default_mob_datas
# 0 Wiggler
	1 0 0 0 0 0 0 0
# 1 Chompo
	2 0 0 0 0 0 0 0
# 2 Skulkulon
	2 0 0 0 0 0 0 0
# 3 Snaker
	2 0 0 0 0 0 0 0
# 4 Angero
	4 0 0 0 0 0 0 0
# 5 Batato
	2 0 0 0 0 0 0 0
# 6 Sneil
	4 0 0 0 0 0 0 0
# 7 Limbox
	2 0 0 0 0 0 0 0
# 8 Pincing
	1 0 0 0 0 0 0 0
# 9 Borkus
	2 0 0 0 0 0 0 0
# 10 Neck King
	2 0 0 0 0 0 0 0
# 11 Blurbinger
	3 0 0 0 0 0 0 0
# 12 Blade-o
	1 0 0 0 0 0 0 0
# 13 Plunge
	1 0 0 0 0 0 0 0
# 14 Catbox
	1 0 0 0 0 0 0 0
# 15 Skulligmite
	2 0 0 0 0 0 0 0
	

:const movement_length 16

# it's me! Using macros! Hooray!
:macro mpat_s X Y A {
	:byte { X * A }
	:byte { Y * A }
}
:macro mpat_8 X Y { 
 	mpat_s X Y 1
 	mpat_s X Y 2
 	mpat_s X Y 3
 	mpat_s X Y 4
 	mpat_s X Y 5
 	mpat_s X Y 6
 	mpat_s X Y 7
 	mpat_s X Y 8
}

# These will generate eg 1 2 3 4 5 6 7 8 X Y coords for how to move an object per frame
: movement_patterns
# 0
mpat_8  0  0

# 1
mpat_8  1  0
# 2
mpat_8  0  1
# 3
mpat_8 -1  0
# 4
mpat_8  0 -1

# 5
mpat_8  1  1
# 6
mpat_8 -1  1
# 7
mpat_8 -1 -1
# 8
mpat_8  1 -1


: random_mob_position
	0
	2 1	3 4	1 5	1 4
	4 4	1 3	3 3	4 2
	2 3	1 2	5 3	1 1
	3 2	3 5	4 3	5 5
	4 5	5 2	3 1	4 1
	2 4	2 2	5 4	2 5
	5 1	5 5	5 3	1 1
	3 4	2 2	5 1	3 2
	4 2	1 4	2 4	2 1
	2 5	1 2	4 1	4 5
	4 3	5 4	1 3	4 4
	5 2	3 3	2 3	1 5
	3 1	3 5	3 2	4 2
	4 5	2 4	4 4	5 5
	5 3	4 1	3 5	2 5
	2 2	1 1	3 1	1 3
	1 2	5 2	1 5	3 4
	2 3	5 4	2 1	3 3
	5 1	4 3	1 4	2 4
	3 5	2 1	5 1	2 2
	5 4	1 1	3 2	3 4
	5 5	1 3	1 2	1 5
	2 5	4 1	4 5	1 4
	4 2	3 3	5 3	4 4
	3 1	5 2	2 3	4 3


: level_select_marker
0x38 0x44 0x82 0x82 0x82 0x44 0x38 0x00
: level_select_complete
0x00 0x00 0x10 0x38 0x10 0x00 0x00 0x00
: level_select_pointer
0x10 0x38 0x7C 0x10 0x10 0x10 0x00 0x00

: level_select_marker_first
0x38 0x44 0xBA 0xBF 0xBA 0x44 0x38 0x00 

: level_select_marker_prev
0x38 0x54 0xB2 0xFE 0xB2 0x54 0x38 0x00

: level_select_marker_next
0x38 0x54 0x9A 0xFE 0x9A 0x54 0x38 0x00 

: level_select_marker_final
0x38 0x44 0xBA 0xFA 0xBA 0x44 0x38 0x00

: ringus
0x07 0xE0 0x1F 0xF8 0x3F 0xFC 0x7C 0x3E 0x70 0x0E 0xF0 0x0F 0xE0 0x07 0xE0 0x07
0xE0 0x07 0xE0 0x07 0xF0 0x0F 0x70 0x0E 0x7C 0x3E 0x3F 0xFC 0x1F 0xF8 0x07 0xE0

: sweeper_nothing_flip
0x00 0x00 0x00 0x00 0x18 0x00 0x18 0x00 0x18 0x00 0x1B 0xE0 0x1F 0xF0 0x17 0x50
0x17 0x50 0x13 0xF0 0x1F 0xE0 0x1F 0xC0 0x1F 0xE0 0x17 0xE0 0x17 0xE0 0x3F 0xF0
0x00 0x00 0x00 0x00 0x00 0x18 0x00 0x18 0x00 0x18 0x07 0xD8 0x0F 0xF8 0x0A 0xE8
0x0A 0xE8 0x0F 0xC8 0x07 0xF8 0x03 0xF8 0x07 0xF8 0x07 0xE8 0x07 0xE8 0x0F 0xFC


: sweeper_walk_broom
0x00 0x00 0xAA 0x00 0xFE 0x00 0x7C 0x00 0x10 0x00 0x13 0xE0 0x17 0xF0 0x17 0x50
0x17 0x50 0x13 0xF0 0x1F 0xE0 0x1F 0xC0 0x1F 0xE0 0x17 0xE0 0x17 0xE0 0x3F 0xF0
0xAA 0x00 0xFE 0x00 0x7C 0x00 0x10 0x00 0x10 0x00 0x13 0xE0 0x17 0xF0 0x17 0x50
0x17 0x50 0x1F 0xF0 0x1F 0xE0 0x1F 0xC0 0x17 0xE0 0x17 0xE0 0x3F 0xF0 0x1F 0xF0
0x55 0x00 0x7F 0x00 0x3E 0x00 0x08 0x00 0x08 0x00 0x09 0xF0 0x0B 0xF8 0x0B 0xA8
0x0B 0xA8 0x0F 0xF8 0x0F 0xF0 0x0F 0xE0 0x0F 0xE0 0x0F 0xF0 0x1F 0xF0 0x3F 0xF8
0x00 0x00 0x55 0x00 0x7F 0x00 0x3E 0x00 0x08 0x00 0x09 0xF0 0x0B 0xF8 0x0B 0xA8
0x0B 0xA8 0x09 0xF8 0x0F 0xF0 0x0F 0xE0 0x0F 0xE0 0x0F 0xF0 0x0F 0xF0 0x1F 0xF0

: sweeper_platform_a
0b00011111


: crosshair_reset_data
 0x5b 0x1F 
 			0x1C 
 				0 0
 0x22 0x1F
 			0x1D
 				0 0

##################################

: register_dump
 0 0 0 0 0 0 0 0 
 0 0 0 0 0 0 0 0 

:monitor register_dump 16
:monitor game_grid 49

###############################
#
# Data Sprite
#
###############################
# The idea of this is to be able to put X, Y, and sprite address info in
# memory and just say 'draw sprite 1', for any incidental sprites throughout
# the game.

: fixed_graphic_angle_a
0x04 0x00 0x04 0x00 0x08 0x00 0x08 0x00 0x10 0x00 0x1C 0x00 0x23 0x00 0x20 0x80
0x40 0x80 0x40 0x40 0x80 0x40 0xFF 0xE0 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00

: fixed_graphic_angle_d
0xF8 0x00 0x84 0x00 0xB2 0x00 0xAA 0x00 0xAA 0x00 0xAA 0x00 0xAA 0x00 0xAA 0x00
0xB2 0x00 0x84 0x00 0xF8 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00

:macro data_sprite x {
	v0 := x
	draw_data_sprite
	}

to-code
: draw_data_sprite
	# v0 will tell us what sprite to draw
	# We will need to multiply this by 4
	v0 <<= v0
	v0 <<= v0
	i := long fixed_graphic_start
	i += v0
	# Load v3
	load v3
	i := data_sprite_draw_code
	save v1

	0xF0 0x00
	: data_sprite_draw_code
	0x00 0x00
	sprite v2 v3 0
;

to-data

:macro fixed_graphic_def X Y ADDRESS {
	:byte { 0xFF & ADDRESS >> 8 }
	:byte { 0xFF & ADDRESS }
	:byte { X }
	:byte { Y }
}

: fixed_graphic_start
fixed_graphic_def 6 2 fixed_graphic_angle_a
fixed_graphic_def 27 18 fixed_graphic_angle_d



###############################
#
# EZ-Writer implimentation
#
###############################
# Options used:
# Support for X/Y control char
# Using fivewide fixed width font
# Using pre calculated offset so just need to add offset to font address

# We are already in the data section:
#to-data

: font
: fivewide_full_font # space first:
	0x20 0x50 0x88 0xF8 0x88 # a
	0xF0 0x88 0xF0 0x88 0xF0 # b
	0x78 0x80 0x80 0x80 0x78 # c
	0xF0 0x88 0x88 0x88 0xF0 # d
	0xF8 0x80 0xF0 0x80 0xF8 # e
	0xF8 0x80 0xF0 0x80 0x80 # f
	0x78 0x80 0x98 0x88 0x70 # g
	0x88 0x88 0xF8 0x88 0x88 # h
	0xF8 0x20 0x20 0x20 0xF8 # i
	0xF8 0x20 0x20 0x20 0xE0 # j
	0x88 0x90 0xE0 0x90 0x88 # k
	0x80 0x80 0x80 0x80 0xF8 # l
	0x88 0xD8 0xA8 0x88 0x88 # m
	0x88 0xC8 0xA8 0x98 0x88 # n
	0x70 0x88 0x88 0x88 0x70 # o
	0xF0 0x88 0xF0 0x80 0x80 # p
	0x70 0x88 0x88 0x98 0x78 # q
	0xF0 0x88 0xF0 0x90 0x88 # r
	0x78 0x80 0x70 0x08 0xF0 # s
	0xF8 0x20 0x20 0x20 0x20 # t
	0x88 0x88 0x88 0x88 0x70 # u
	0x88 0x88 0x50 0x50 0x20 # v
	0x88 0x88 0xA8 0xA8 0x50 # w
	0x88 0x50 0x20 0x50 0x88 # x
	0x88 0x50 0x20 0x40 0x80 # y
	0xF8 0x10 0x20 0x40 0xF8 # z
: fivewide_digits
	0x70 0x88 0x88 0x88 0x70 # 0
	0x20 0x60 0x20 0x20 0xF8 # 1
	0x70 0x88 0x30 0x40 0xF8 # 2
	0xF0 0x08 0x70 0x08 0xF0 # 3
	0x30 0x50 0x90 0xF8 0x10 # 4
	0xF8 0x80 0xF0 0x08 0xF0 # 5
	0x70 0x80 0xF0 0x88 0x70 # 6
	0xF8 0x08 0x08 0x10 0x10 # 7
	0x70 0x88 0x70 0x88 0x70 # 8
	0x78 0x88 0xF8 0x08 0x08 # 9
	0x00 0x00 0x00 0x00 0x20 # .
	0x50 0x50 0x50 0x00 0x50 # !
	0x70 0x88 0x30 0x00 0x20 # ?
	0x00 0x00 0x00 0x20 0x60 # ,
	0x20 0x20 0x00 0x00 0x00 # '
	0x00 0x00 0x70 0x00 0x00 # -
	0x50 0x50 0x00 0x00 0x00 # "
	0xA8 0xF8 0x20 0x20 0x20 # Sweeps
	0xF8 0xA8 0xF8 0x70 0x70 # Skull points
	0x00 0x00 0x00 0x00 0x00 # undefined
	0x00 0x00 0x00 0x00 0x00 # undefined
	0x00 0x00 0x00 0x00 0x00 # undefined
	0x00 0x00 0x00 0x00 0x00 # undefined
	0x00 0x00 0x00 0x00 0x00 # undefined
	0x00 0x00 0x00 0x00 0x00 # undefined
	0x00 0x00 0x00 0x00 0x00 # undefined


 : string_stash
  0 0 0 0 0 0

# I think this means that our 0x200 address will be poluted with this this code rather than going right into main?
# I don't know how to check.

to-code

:const STR_END    0xFF
:const STR_POS    0xFE
:const STR_SPACE  0xF9
:const CHAR_WIDTH  6
:const CHAR_HEIGHT 5

:alias string-offset v3
:alias cursor-x      v4
:alias cursor-y      v5

# EZ-Writer implimentation macro:
# Just this function alone requires the entire structure of the file to be different
# I just don't get it.
:macro ez_print ADDRESS {
	:calc hi { 0xFF & ADDRESS >> 8 }
	:calc lo { 0xFF & ADDRESS }
	v0 := hi
	v1 := lo
	print-string
}

: print-char
	if v0 == STR_POS begin
		string-offset += 2
		cursor-x := v1
		cursor-y := v2
		return
	end
	if v0 != STR_SPACE begin
		i  := long font
		# Only need x1 due to x5 already factored in
		i  += v0
		sprite cursor-x cursor-y CHAR_HEIGHT
	end
	cursor-x += CHAR_WIDTH
;
: print-string
	# stash registers here if you need to protect up to v5
	i := long string_stash
	save v5
	i := print-string-read
	save v1
	string-offset := 0
	# Default string X/Y coords:
	cursor-x      := 0
	cursor-y      := 0
	loop
		# this is equivalent to "i := long NNNN"
		# where NNNN is re-written outside the loop.
		# to avoid using XO-CHIP instructions,
		# you could instead use :unpack to
		# produce an indirect pointer-
		# see the Octo manual for detals:
		0xF0 0x00 : print-string-read 0x00 0x00
		i += string-offset
		load v2
		while v0 != STR_END
		string-offset += 1
		print-char
	again
	# And restoring strings here if needed
	i := long string_stash
	load v5
;

###############################
#
# Code subroutines that are only used once and have been turned into macros:
#
###############################

#: reset_sweeps
:macro reset_sweeps
{
	v0 := 0
	i := long sweeps_this_level
	save v0
	i := long score_this_level
	save v0

	draw_sweeps
	draw_score
}
#;


#: draw_game_box
:macro draw_game_box
{
	v1 := UL_Y
	v2 := LL_Y

	draw_paired_lines_h
	
	v2 := UL_Y_plus1

	draw_paired_lines_v

	ez_print in_level_text

	i := long sweeper_platform_a
	v0 := 0
	v1 := 24
	sprite v0 v1 1
	i := long line_h
	: draw_platform_repeat
	v0 += 8
	sprite v0 v1 1
	if v0 != 24 then jump draw_platform_repeat
#;
}

: draw_paired_lines_h
	v0 := UL_X
	i := long line_h

	loop
		sprite v0 v1 1
		sprite v0 v2 1

		v0 += 8
		if v0 != UR_Max8 then
	again

	i := long line_h_2
	sprite v0 v1 1
	sprite v0 v2 1
;

: draw_paired_lines_v
	v0 := UL_X
	v1 := UR_X

	i := long line_v
	loop
		sprite v0 v2 8
		sprite v1 v2 8

		v2 += 8
		if v2 != LL_Max8 then
	again
;

#: load_level
:macro load_level
{
	# level is in... v0?

	# This is the stupid way of loading a level
	i := long levels_load
	# Stride in by 4x because I haven't changed this to just fixed addresses yet:
	i += v0
	i += v0
	i += v0
	i += v0
	# Load v4 bytes
	load v3

	i := load_level_source_address
	save v3

	# We reset the 'game grid' data area here
	# Fill v0 to v6 with -1s:
	i := long level_reset_data
	load v6

	# Wipe the game grid data out with -1s and also the 'trash' data area that follows it:
	v9 := 0
	i := long game_grid
	loop
		save v6
		v9 += 7
		:calc g_grid_plus_trash { 49 + 4 * 7 }
		if v9 != g_grid_plus_trash then
	again

	# Now we target the actual level and load it into the game grid:
	v9 := 0
	loop
		# Self modifying code goes here:
		: load_level_source_address
		i := long level_lr_1
		i += v9

		# And for some reason, load it into our registers backwards:
		load v2 - v0

		# -1 in our data here signifies we've reached the end of the level data:
		if v2 == -1 then jump load_level_get_enemies

		# Format will be that X and Y pos are in v0 and v1, by using macros to ensure our data order corresponds
		# with the 'v2 - v0' read above.
		# v0 v1 x y, v2, obsticle
		# Call the address game cell function, which expects v0 X and v1 Y:
		address_game_cell
		# The I pointer is left at game_grid + v1
		# i := long game_grid
		# i += v1
		save v2 - v2

		# Step onward:
		v9 += 3
	again
	: load_level_get_enemies
	# Also draws trash:
	# draw_obstacles

	# This is only called once, why subroutine it:
#: draw_obstacles
	v0 := 0
	i := 0x180
	save vF

	plane 2

	:alias trash_counter v7
	:alias other_trash_counter v8

	mob_y := 0
	loop
		mob_x := 0
		loop
			v0 := mob_x
			v1 := mob_y
			address_game_cell

			# v0 will be content
			# v1 will be offset from game_grid

			if v0 != -1 begin
				mob_type := 128
				mob_type += v0
				# We do an overflow math check here without using vE I guess:
				if vF == 1 begin	
					# if the item was in the region at 128 or above:
					# We know it's the index of something special

					# We probably want the x8 version of this index:
					v2 <<= mob_type # x2
					v2 <<= v2 # x4
					v2 <<= v2 # x8

					# NO HIT obsticles that must not be hit:
					if mob_type < 16 begin
						plane 2
						# furniture
						calc_mob_draw_xy
						i := long furniture
						i += v2

						sprite mob_draw_x mob_draw_y 8
						jump draw_obstacles_pass_trash
					end

					# Trash items which must be cleared:
					if mob_type < 32 begin
						plane 1
						calc_mob_draw_xy

						v0 := mob_draw_x
						v1 := mob_draw_y
						i := long quick_trash
						i += trash_counter

						# This looks like it's going to save the draw X and draw Y position, as well graphic index
						save v2

						# Draw it because that makes things simpler:
						i := long furniture
						i += v2

						sprite mob_draw_x mob_draw_y 8

						v2 := other_trash_counter
						calc_trash_ui_pos
						sprite v0 v1 8

						trash_counter += 3
						other_trash_counter += 1
					end
				end

				: draw_obstacles_pass_trash
				vF := 8
				f_delay
			end

			mob_x += 1
			if mob_x != 7 then
		again
		mob_y += 1
		if mob_y != 7 then
	again

	# We want to highlight the trash items for a bit here so the player knows to get them

	# other_trash_counter contains the fixed number of trash items:

	# How many passes do we want to do:
	v4 := 10
	flash_trash

	i := 0x180
	load vF
#;

#;
}

: flash_trash
	plane 2
	# This depends on knowing the total number, rather than checking the data
	# If we check the data, we can do this any time we want, instead, including during gameplay
	loop
		v3 := 0
		loop
			i := long quick_trash
			i += v3
			load v2

			if v2 != -1 begin
				v0 += -4
				v1 += -4
				i := long ringus
				sprite v0 v1 0
			end
			v3 += 3
			if v3 != 27 then
		again
		vF := 3
		f_delay
		v4 += -1
		if v4 != 0 then
	again
	plane 1
;

:alias enemy_data_size v7
:alias enemy_data_simple_save v2


# I finally replaced this part of the program with macros
# This was only possible due to the source file reorganisation

# We always want the quick tan table to be at 'the end' of the program defined data,
# as this is the address used as an offset
# for the generated tables that are generated by code
# I can tell you right now I'm going to have to generate these and hard code them in here
# Or figure out how to macro them, because I'll need the code space.
to-data

: preset_memory_end
:macro do-5		X { X X X X X }
:macro do-10	X { do-5 X do-5 X }
:macro do-43	X { 
					do-10 X do-10 X
					do-10 X do-10 X
					X X X
				  }

:macro do-44	X { 
					do-43 X
					X
				  }

:macro do-45	X { 
					do-43 X
					X X
				  }

:macro do-64	X {
					do-44 X
					do-10 X
					do-10 X
				}


# What we want:
#: tan_table # 46 bytes that represent subpixels on the offaxis when incrimenting adjacent by 1
 #0x00 0x04 0x08 0x0D 0x11 0x16 0x1A 0x1F 
 #0x23 0x28 0x2D 0x31 0x36 0x3B 0x3F 0x44 
 #0x49 0x4E 0x53 0x58 0x5D 0x62 0x67 0x6C 
 #0x71 0x77 0x7C 0x82 0x88 0x8D 0x93 0x99 
 #0x9F 0xA6 0xAC 0xB3 0xB9 0xC0 0xC8 0xCF 
 #0xD6 0xDE 0xE6 0xEE 0xF7 0xFF 


# We have 46 bytes of 'tan table' data.
# this is our address:
:calc tan_table { HERE }

# This is how we create an entry:
:macro tan_table_entry {
	:byte { 256 * tan ( ( HERE - tan_table ) * PI / 180 ) }
}

# This is us generating our tan data:
	do-45 tan_table_entry
	# And one more:
		  tan_table_entry




# Now we can generate our table addresses:
:calc quick_tan { HERE }
:calc quick_off_axis { quick_tan + 90 }
:calc quick_tan_table { quick_off_axis + 92 }
:calc quick_off_axis_table { quick_tan_table + ( 128 * 44 ) }

# Critically though, our current memory address is still at quick_tan
# We know that quick_tan is a table of that is strided by 128 bytes each time
# Thus, we just need to store quick_tan_table + 128 * call count
:macro quick_tan_entry {
	:calc goal_address { ( quick_tan_index * 128 ) + quick_tan_table }

	:byte { 0xFF & goal_address >> 8 }
	:byte { 0xFF & goal_address }

	:calc quick_tan_index { 1 + quick_tan_index }
}

# Initialise our index:
:calc quick_tan_index { 0 }

# Then do 2 0s, and then add 44 quick_tan_entrys:
	0 0
	do-44 quick_tan_entry



# Now we want to generate the quick off axis table addresses
# These are a little harder to determine
# Effectively, this table will contain a number of entries that
# matches the largest possible off axis value at length 64

# The exact math that was used is that
# Starting from 0 offset, we count up to 63 * our subpixel value
# Each time it overflows, it will save 1 additional value into memory
# Then we save one final value at the end
# So, our data would be of the form:
# 0
# Every overflow up to 63 * sub pixels
# And then again, the last value
# And then a -1
# But here we are only calculating the address table:

:calc first_off_axis_address { ( 44 * 128 ) + quick_tan_table }
:macro quick_off_axis_entry {

	# Calculate the subpixel value forced to be an integer:
	:calc this_off_axis_tan_subpixel_value { 0xFF & ( 256 * tan ( ( quick_off_axis_index ) * PI / 180 ) ) }
	:calc this_off_axis_max { ( 63 * this_off_axis_tan_subpixel_value ) } 
	:calc this_off_axis_whole_pixels { ( this_off_axis_max >> 8 ) + 3 }

	:calc goal_address { quick_off_axis_memory_pointer }

	:byte { 0xFF & goal_address >> 8 }
	:byte { 0xFF & goal_address }
	# Used for debugging:
	#:byte { this_off_axis_tan_subpixel_value }
	#:byte { this_off_axis_whole_pixels }

	:calc quick_off_axis_index { 1 + quick_off_axis_index }
	:calc quick_off_axis_memory_pointer { quick_off_axis_memory_pointer + this_off_axis_whole_pixels }
}
:macro quick_off_axis_entry_final {
	:calc goal_address { quick_off_axis_memory_pointer }

	:byte { 0xFF & goal_address >> 8 }
	:byte { 0xFF & goal_address }
}


:calc quick_off_axis_index { 1 }
:calc quick_off_axis_memory_pointer { first_off_axis_address }

# Now we do our actual generation of our quick off axis lookup table:
	0 0
	do-44 quick_off_axis_entry
	quick_off_axis_entry_final


#################################
#
# We are now at quick_tan_table
#
# quick_tan_table is a table of data that is strided by 0x80 ( 128 ) bytes per rotation value
# The data is seperated as 
# off_axis value
# subpixel value
# The subpixel value counts upwards from 128 by the value in tan_table
# We start at rotation value 1

:calc quick_tan_table_rotation_value { 1 }

:macro quick_tan_table_entry {
	# The current large number value result will be:
	:calc table_data { 128 + ( quick_tan_table_index * quick_tan_table_subpixel_value ) }

	# This is strangely like writing an address:
	:byte { 0xFF & table_data >> 8 }
	:byte { 0xFF & table_data }

	:calc quick_tan_table_index { quick_tan_table_index + 1 }
}

:macro quick_tan_table_rotation_table {
	# Reset index to 0:
	:calc quick_tan_table_index { 0 }
	# Calculate the subpixel value for this rotation:
	:calc quick_tan_table_subpixel_value { 0xFF & ( 256 * tan ( ( quick_tan_table_rotation_value ) * PI / 180 ) ) }

	# Do 64 of them:
	do-64 quick_tan_table_entry

	# Select next rotation value:
	:calc quick_tan_table_rotation_value { quick_tan_table_rotation_value + 1 }
}

# Now generate the data:
	do-44 quick_tan_table_rotation_table




################################
#
# We are now at quick_off_axis_table, the data for which was only ever
# placed in quick_off_axis.

# The data that we should have here is:
# 0
# ... (the maximum value for an on axis value for this off axis value)
# 63
# 255

# We can calculate the correct start point for reach piece of data as we go
# This means we could write just nonsence data and then write the next piece
# of correct data

:calc quick_off_axis_table_memory_pointer { quick_off_axis_table }
:calc quick_off_axis_table_index { 0 }
:calc quick_off_axis_table_rotation_value { 1 }
:macro quick_off_axis_table_entry {
	# The largest value that we see in this table is 63, starting from 0
	# The values that we know here are
	# our value from 0-63
	# our rotation value
	# We want to know how many of (rotation value) will exceed (our value) * 256
	# I don't think we can 'stop early' or anything but we can probably use org to get back to the right place
	# As we know that the correct number of entries per table can be computed as we do this
	# for quick_off_axis_entry

	:calc goal_value { quick_off_axis_table_subpixel_value * quick_off_axis_table_index }

	:byte { 0xFF & goal_value }

	:calc quick_off_axis_table_index { quick_off_axis_table_index + 1 }
}


:macro quick_off_axis_table_rotation_table {
	# This will generate the full 64 byte entry for a given rotation, aim memory, and step on to the next correctly
	# Reset index to 0:
	:calc quick_off_axis_table_index { 0 }
	# Calculate the subpixel value for this rotation:
	:calc quick_off_axis_table_subpixel_value { 0xFF & ( 256 * tan ( ( quick_off_axis_table_rotation_value ) * PI / 180 ) ) }

	:calc this_off_axis_max { ( 63 * quick_off_axis_table_subpixel_value ) } 
	:calc this_off_axis_whole_pixels_no_offset { ( this_off_axis_max >> 8 ) }

	:org quick_off_axis_table_memory_pointer

	# First byte is always 0:
	:byte { 0 }

	# Now we have ???? many bytes of nonsence:
	do-64 quick_off_axis_table_entry

	:calc temp_quick_off_axis_table_pointer { quick_off_axis_table_memory_pointer + 1 + this_off_axis_whole_pixels_no_offset }

	:org temp_quick_off_axis_table_pointer

	# Write final bytes in correct location:
	:byte { 63 }
	:byte { 255 }


	# Select next rotation value:
	:calc quick_off_axis_table_rotation_value { quick_off_axis_table_rotation_value + 1 }

	# Select our next memory address:
	:calc quick_off_axis_table_memory_pointer { quick_off_axis_table_memory_pointer + this_off_axis_whole_pixels_no_offset + 3 }
}

# now we generate the table itself:
#	do-44 quick_off_axis_table_rotation_table


# So unforunately as of right now we can't org back over our own data and 'over write' it, the compiler doesn't allow for this:
# It rather wisely protects you from doing it
# So, I guses I'm stuck just, hard coding the data table into the rom, I guess?
# I mean I don't know what my alternative is other than having octo compute it, or, by having the table have fixed 64
# number entries. I mean I have plenty of memory, there's nothing wrong with that, but, I want to know how much
# memory I really need

 # Table starts at 1 degree:
 0 63 255
 0 32 63 255
 0 20 40 60 63 255
 0 16 31 46 61 63 255
 0 12 24 35 47 59 63 255
 0 10 20 30 40 50 60 63 255
 0 9 17 25 34 42 50 58 63 255
 0 8 15 22 30 37 44 52 59 63 255
 0 7 13 20 26 32 39 45 52 58 63 255
 0 6 12 18 23 29 35 40 46 52 57 63 63 255
 0 6 11 16 21 27 32 37 42 48 53 58 63 63 255
 0 5 10 15 19 24 29 34 38 43 48 53 57 62 63 255
 0 5 9 14 18 22 27 31 35 40 44 48 53 57 61 63 255
 0 5 9 13 17 21 25 29 33 37 41 45 49 53 57 61 63 255
 0 4 8 12 16 19 23 27 31 34 38 42 46 49 53 57 61 63 255
 0 4 8 11 15 18 22 25 29 32 36 39 43 46 50 53 57 60 63 255
 0 4 7 10 14 17 20 23 27 30 33 37 40 43 46 50 53 56 60 63 63 255
 0 4 7 10 13 16 19 22 25 28 31 34 38 41 44 47 50 53 56 59 62 63 255
 0 3 6 9 12 15 18 21 24 27 30 32 35 38 41 44 47 50 53 56 59 62 63 255
 0 3 6 9 12 14 17 20 23 25 28 31 34 36 39 42 45 47 50 53 56 58 61 63 255
 0 3 6 8 11 14 16 19 21 24 27 29 32 34 37 40 42 45 48 50 53 55 58 61 63 63 255
 0 3 5 8 10 13 15 18 20 23 25 28 30 33 35 38 40 43 45 48 50 53 55 58 60 63 63 255
 0 3 5 8 10 12 15 17 19 22 24 27 29 31 34 36 38 41 43 46 48 50 53 55 57 60 62 63 255
 0 3 5 7 10 12 14 16 19 21 23 25 28 30 32 34 37 39 41 44 46 48 50 53 55 57 59 62 63 255
 0 3 5 7 9 11 13 16 18 20 22 24 26 28 31 33 35 37 39 41 44 46 48 50 52 54 56 59 61 63 63 
	255
 0 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 34 36 38 40 42 44 46 48 50 52 54 56 58 60 62 
	63 255
 0 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52 54 56 58 60 
	62 63 255
 0 2 4 6 8 10 12 14 16 17 19 21 23 25 27 29 31 32 34 36 38 40 42 44 46 48 49 51 53 55 57 
	59 61 63 63 255
 0 2 4 6 8 10 11 13 15 17 19 20 22 24 26 28 30 31 33 35 37 39 40 42 44 46 48 50 51 53 55 
	57 59 60 62 63 255
 0 2 4 6 7 9 11 13 14 16 18 20 21 23 25 27 28 30 32 34 35 37 39 41 42 44 46 48 49 51 53 
	54 56 58 60 61 63 63 255
 0 2 4 6 7 9 11 12 14 16 17 19 21 22 24 26 27 29 31 32 34 36 37 39 41 42 44 46 47 49 51 
	52 54 56 57 59 61 62 63 255
 0 2 4 5 7 9 10 12 13 15 17 18 20 21 23 25 26 28 29 31 33 34 36 38 39 41 42 44 46 47 49 
	50 52 54 55 57 58 60 62 63 63 255
 0 2 4 5 7 8 10 11 13 14 16 17 19 21 22 24 25 27 28 30 31 33 34 36 38 39 41 42 44 45 47 
	48 50 51 53 54 56 58 59 61 62 63 255
 0 2 3 5 6 8 9 11 12 14 15 17 18 20 21 23 24 26 27 29 30 32 33 35 36 38 39 41 42 44 45 
	47 48 50 51 53 54 56 57 59 60 62 63 63 255
 0 2 3 5 6 8 9 11 12 13 15 16 18 19 21 22 23 25 26 28 29 31 32 33 35 36 38 39 41 42 43 
	45 46 48 49 51 52 53 55 56 58 59 61 62 63 63 255
 0 2 3 5 6 7 9 10 12 13 14 16 17 18 20 21 23 24 25 27 28 30 31 32 34 35 36 38 39 41 42 
	43 45 46 48 49 50 52 53 54 56 57 59 60 61 63 63 255
 0 2 3 4 6 7 8 10 11 12 14 15 16 18 19 20 22 23 24 26 27 28 30 31 32 34 35 36 38 39 40 
	42 43 44 46 47 48 50 51 52 54 55 56 58 59 60 62 63 63 255
 0 2 3 4 6 7 8 9 11 12 13 15 16 17 18 20 21 22 24 25 26 27 29 30 31 32 34 35 36 38 39 
	40 41 43 44 45 47 48 49 50 52 53 54 56 57 58 59 61 62 63 63 255
 0 2 3 4 5 7 8 9 10 12 13 14 15 17 18 19 20 22 23 24 25 26 28 29 30 31 33 34 35 36 38 
	39 40 41 43 44 45 46 47 49 50 51 52 54 55 56 57 59 60 61 62 63 255
 0 2 3 4 5 6 8 9 10 11 12 14 15 16 17 18 20 21 22 23 24 26 27 28 29 30 32 33 34 35 36 
	38 39 40 41 42 44 45 46 47 48 50 51 52 53 54 56 57 58 59 60 62 63 63 255
 0 2 3 4 5 6 7 9 10 11 12 13 14 15 17 18 19 20 21 22 24 25 26 27 28 29 30 32 33 34 35 
	36 37 39 40 41 42 43 44 45 47 48 49 50 51 52 54 55 56 57 58 59 60 62 63 63 255
 0 2 3 4 5 6 7 8 9 11 12 13 14 15 16 17 18 19 21 22 23 24 25 26 27 28 29 31 32 33 34 
	35 36 37 38 39 41 42 43 44 45 46 47 48 49 51 52 53 54 55 56 57 58 59 61 62 63 63 255
 0 2 3 4 5 6 7 8 9 10 11 12 13 14 16 17 18 19 20 21 22 23 24 25 26 27 28 30 31 32 33 
	34 35 36 37 38 39 40 41 42 44 45 46 47 48 49 50 51 52 53 54 55 56 58 59 60 61 62 63 63 255
 0 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 30 31 32 
	33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 58 59 60 61 62 63 63 255
 # 45 degree table is stupid but exists for a reason I forget (maybe it doesn't need to exist)
 0 1 255

########################################
###
## The actual start of execution:
to-code

: main

	# First we pick a 'seed'
	# pick a random start point
	v0 := random 0b01111110
	i := long random_mob_position
	save v0


	# I would like to replace these functions and have the data ready to go
	# Generate quick off_axis table
	#generate_tan_table
	#generate_offaxis_max_table

	clear

	ez_print title_screen_text

	data_sprite 0
	data_sprite 1

	v0 := key


	hires

	# This is where we jump back to after a 'gameplay' level to
	# Get the level select screen back and show progress etc
	# I guess that makes this a menu redraw or whatever?
: game_restart

	# Clean out enemy variables:
	clean_enemy_variables

	# Enter the level select loop:
	level_select_mode



	reset_for_new_game_loop

	# We are now in the 'gameplay loop'

	# Draw the main game UI
	draw_game_box
	# Reset sweeps for this level:
	reset_sweeps

	# Draw the static sweeper in place until some day I make it better:
	i := long sweeper_walk_broom
	v0 := 8
	v1 := 8
	sprite v0 v1 0

	# We will be drawing the UI a bit at a time here:
	vF := 16
	f_delay

	# This is where we make use of our level number:
	:next load_level_number
	v0 := 0
	load_level
	
	i := long crosshair_reset_data
	load v9
	i := crosshair_1_data
	save v9

	i := long levely_wevelly
	load vF

	# Loaded in from levely_wevelly:
	#Tx := 64
	#Ty := 32
	#Tr := 0
	#TrZ := 0b0010

	# 'draw in' crosshairs so we can undraw them normally, later:
	draw_crosshairs_from_memory
	# update all the fast rotation code:
	update_trz_code

	:macro calc_next_crosshair {
		next_crosshair := random 0b00001111
		next_crosshair += 4
	}
	calc_next_crosshair

	# We 'jump' into the game loop as though the player just tried rotating slightly
	# This updates everything to be hunky dory:
	v0 := TrZ
	v2 := Tr
	jump0 update_rotation_code



	loop
		# Don't really need this any more:
		#v0 := 0 if v0 key begin
		#	:breakpoint q
		#	v0 += 1
		#end

		# Let's handle input:
		# It would be handy to know if the player has not pushed any input

		:alias detect_rot v5
		:alias player_input v6

		player_input := 0
		
		v0 := 0xE if v0 key then jump trigger_pull

		v0 := 0xD if v0 key begin
			v4 := 4
			flash_trash
		end

		: cross_return

		detect_rot := Tx
		v0 := 7   if v0 key then Tx += -1 # keyboard A
		v0 := 9   if v0 key then Tx +=  1 # keyboard D
		if Tx != detect_rot then player_input += 1

		detect_rot := Ty
		v0 := 5   if v0 key then Ty += -1 # keyboard W
		v0 := 8   if v0 key then Ty +=  1 # keyboard S
		if Ty != detect_rot then player_input += 1

		# We only have to run this code if they push a button:
		if player_input == 0 then jump service_rot

		# Gate player
		if Tx == player_LEFT_LIMIT then Tx += 1 # ie, go right
		if Tx == player_RIGHT_LIMIT then Tx += -1
		if Ty == player_TOP_LIMIT then Ty += 1
		if Ty == player_LOW_LIMIT then Ty += -1

		# We will use v5 to indicate we're trying to change rotation:

		: service_rot
		detect_rot := Tr
		v0 := 4   if v0 key then Tr += -1 # keyboard Q
		v0 := 6   if v0 key then Tr +=  1 # keyboard E
		# Skip rotation update if rotation is unchanged:
		if detect_rot == Tr then jump update_rotation_code_return

		# Here, if detect_rot is 0 and player_input is 0 then we
		# don't need to update our positions

		# if player_input is 1 but detect_rot is 0 then we don't need
		# to update rot

		# if player_input is 0 but detect_rot is 1, then we still
		# need to update stuff

		# 0 0 nothing
		# 1 0 pos only
		# ? 1 both

		# begin
			# This code runs only on r change
			player_input += 1

			if Tr == 45 begin
				Tr := 0
				TrZ += 0b010
				if TrZ == 0b010000 then TrZ := 0
				update_trz_code
			end
			if Tr == -1 begin
				Tr := 44
				TrZ -= 0b010 # mm sugar
				if TrZ == 0b11111110 then TrZ := 0b001110
				update_trz_code
			end
			# Rotation must have changed for us to be here:
			# if __1_, then Tr can be used to index into the tan table normally
			# if __0_, then the correct value is 45 - Tr

			# Here's a mad solution:
			v0 := TrZ
			v2 := Tr
			jump0 update_rotation_code
		# end
		: update_rotation_code_return
			# Here, we KNOW that the player pushed something
			# Can we all directly into the update code?

		# Undraw the existing cursors:
		draw_crosshairs_from_memory

		# Perform duty cycle
		i := frame_cycle_count
		load v0 - v0
		v0 += 8
		if v0 == 64 begin
			v0 := 0
			frame_stepper += 0x80
		end
		# Use v0 - v0 to avoid I step:
		#i := frame_cycle_count
		save v0 - v0

		# If player_input is true then we must redraw
		# if it is 0 then we can use saved values
		if player_input == 0 begin
			# DONT UPDATE STUFF:
			draw_crosshairs_from_memory
			jump bypass_crosshair_update
		end

		if next_crosshair != 0 then next_crosshair += -1

		############ UPDATE STUFF
		# Calculate first:
		DoFirstCrosshair
		: apply_on_axis_main_memory
		apply_on_axis_main
		# cross_x and y are v0 and v1

		# it is INCREDIBLY helpful to retain the original axis values
		: address_crosshair_1_data_memory
		i := crosshair_1_data
		save off_axis

		i := crosshair_b
		if frame_stepper != 0 then i := crosshair_a
		sprite cross_x cross_y 3

		DoSecondCrosshair
		: apply_on_axis_flipped_memory
		apply_on_axis_flipped

		: address_crosshair_2_data_memory
		i := crosshair_2_data
		save off_axis

		i := crosshair_a
		if frame_stepper != 0 then i := crosshair_b
		sprite cross_x cross_y 3

		: bypass_crosshair_update

		# Let's service enemies in the field
		# We don't need to process them all
		# But we do need to process them at all

		## v0 is our current frame cycle value

		service_enemy

		: trigger_return

		if next_crosshair <= 6 begin
			: draw_player_crosshair
			# Draw crosshair

			i := player_crosshair_adjust
			load v1

			i := long player_crosshair
			v0 += Tx
			v1 += Ty
			#v0 -= 3
			#v1 -= 3

			sprite v0 v1 8

			# Try to delay only one 60 fps frame most of the time:
			q_delay

			# Undraw crosshair
			sprite v0 v1 8

			if next_crosshair == 0 begin
				calc_next_crosshair

				# calculate small offset to player crosshair
				i := player_crosshair_adjust
				v0 := random 0b00000011
				v0 -= 4
				if v0 == -1 then v0 := -3
				v1 := random 0b00000011
				v1 -= 4
				if v1 == -1 then v1 := -3
				save v1
			end

			jump no_next_crosshair
		end

		q_delay

		: no_next_crosshair
		next_crosshair += -1

		i := long register_dump
		save vF

	again



	jump main



: reset_for_new_game_loop
	# Clear the screen:
	plane 3
	clear
	plane 1
	# Restore registers to all 0
	i := long wipey_wipe
	load vF
;

: frame_cycle_count
  0

: player_crosshair_adjust
 0 0

: draw_crosshairs_from_memory
	i := crosshair_1_data
	load cross_y
	i := crosshair_b
	if frame_stepper != 0 then i := crosshair_a
	sprite cross_x cross_y 3

	i := crosshair_2_data
	load cross_y
	i := crosshair_a
	if frame_stepper != 0 then i := crosshair_b
	sprite cross_x cross_y 3
;

: crosshair_1_data
 0x5b 0x1F 
 			: crosshair_1_subpixels
 			0x1C 
 				: crosshair_1_onaxis
 				0 0
: crosshair_2_data
 0x22 0x1F
 			: crosshair_2_subpixels
 			0x1D
 				: crosshair_2_onaxis
 				0 0


# These are determined by our current rotation
: apply_on_axis_main
	: simple_axis_apply_target_A
	vF := vF
	vF := vF
;

: apply_on_axis_flipped
	: simple_axis_apply_target_B
	vF := vF
	vF := vF
;

: DoSecondCrosshair
	v0 := TrZ
	vF := 0b1000
	v0 ^= vF
	jump0 SetupOnAxis	# Note shared return path

: DoFirstCrosshair
	v0 := TrZ
	jump0 SetupOnAxis
	############ ->>>>>>>>>>>>

	: AxesReturnPoint
	# Store the final subpixel value into v2:
	v2 := v1

	# This is going to nuke v0 and v1
	cross_x := Tx
	cross_x -= 1
	cross_y := Ty
	cross_y -= 1
;

: SetupOnAxis
# 0000 # On axis: +X, off axis -Y
jump SetupOnPosX
# 0010 # On axis: +X, off axis +Y
jump SetupOnPosX
# 0100 # On axis: +Y, off axis +X
jump SetupOnPosY
# 0110 # On axis: +Y, off axis -X
jump SetupOnPosY
# 1000 # On axis: -X, off axis +Y
jump SetupOnNegX
# 1010 # On axis: -X, off axis -Y
jump SetupOnNegX
# 1100 # On axis: -Y, off axis -X
jump SetupOnNegY
# 1110 # On axis: -Y, off axis +X
jump SetupOnNegY

: SetupOffAxis
# 0000 # On axis: +X, off axis -Y
jump SetupOffNegY
# 0010 # On axis: +X, off axis +Y
jump SetupOffPosY
# 0100 # On axis: +Y, off axis +X
jump SetupOffPosX
# 0110 # On axis: +Y, off axis -X
jump SetupOffNegX
# 1000 # On axis: -X, off axis +Y
jump SetupOffPosY
# 1010 # On axis: -X, off axis -Y
jump SetupOffNegY
# 1100 # On axis: -Y, off axis -X
jump SetupOffNegX
# 1110 # On axis: -Y, off axis +X
jump SetupOffPosX

# 0000
		# On axis: +X, off axis -Y
: SetupOnPosX
	on_axis := UR_X
	on_axis -= Tx
	jump0 SetupOffAxis

: SetupOnNegX
	on_axis := Tx
	on_axis -= UL_X
	jump0 SetupOffAxis

: SetupOnPosY
	on_axis := LL_Y
	on_axis -= Ty
	jump0 SetupOffAxis

: SetupOnNegY
	on_axis := Ty
	on_axis -= UL_Y
	jump0 SetupOffAxis


: SetupOffPosX
	off_axis := UR_X
	off_axis -= Tx
	jump get_off_axis

: SetupOffNegX
	off_axis := Tx
	off_axis -= UL_X
	jump get_off_axis

: SetupOffPosY
	off_axis := LL_Y
	off_axis -= Ty
	jump get_off_axis

: SetupOffNegY
	off_axis := Ty
	off_axis -= UL_Y
	jump get_off_axis


: qtex
	v2 := 0
	v3 := 5
	loop
		sprite v0 v1 5
		v0 += 8
		v2 += 1
		i += v3
		if v2 != 4 then
	again
;

: get_off_axis
	# Takes:
	# on_axis: the large value of the triangle
	# off_axis: the maximun acceptable value for the triangle

	# Returns:
	# on_axis on final axis vector
	# off_axis off final axis vector
	# 

	:alias work_rot v2
	:alias WIP_off v5

	# Yep you guessed it self modifying code:
	:next quick_rot_for_axis
	work_rot := 0x00

	# if they're literally presenting a 0 degree angle, then, we have no off axis to calculate
	if work_rot == 0 begin
		off_axis := 0
		v1 := 0x80
		# Obviously, this is already the case:
		# on_axis := on_axis
		jump AxesReturnPoint
	end

	if work_rot == 45 begin
		# This case is a little more complicated, but in essence

		# if we need to remember to set v1 register to subpixels count
		# then we can do that here:
		v1 := 0x80

		# What on and off axis are is... vague
		# But if either axis is less than the other then that's the minimum

		if on_axis > off_axis then on_axis := off_axis
		if off_axis > on_axis then off_axis := on_axis
		jump validated_off_axis
		end
	
	
	# Also modify our backup plan memory read as this is the unadjusted base of the table
	# This is whe data we want to adjust:
	: offaxis_mem_read_base
	i := long quick_tan_table
	:calc offaxis_mem_read { offaxis_mem_read_base + 2 }

	i += on_axis
	i += on_axis

	load v1
	# v0 will be total off axis displacement
	# v1 will be the remaining subpixels at this point

	WIP_off := v0


	if WIP_off > off_axis begin
		# unfortunately, this exceeds our stated maximum
		# We could raycast however we can also precompute the best result
		# for every one of these, like we do for the on_axis read

		# if we do this then we lose the knowledge of what our subpixels are
		# Maybe it's best just to get our subpixels again when we need them?

		WIP_off := off_axis
		0xF0 00
		: off_axis_table_address
		0 0

		i += off_axis
		load v0

		:monitor off_axis_table_address 2
		# We must not exend on access though:
		if v0 < on_axis then on_axis := v0
	end
	# otherwise this is a perfectly find on axis length
	off_axis := WIP_off

	: validated_off_axis
	# If this off axis in excess of our maximum?
	# Who knows
	jump AxesReturnPoint


: set_i_to_offaxis
	0xF0 00
	: mem_generic_off_axis
	0 0
;



# This is a jump table
# We are going to receive one of the 8 zones here:
# Uses up code, but is in principal faster than anding out the bits.
# Maybe
# jump0 -> jumpT -> Entry
# vF := 0b10 -> vf &= TrZ -> if vf then Entry / Entry
: update_rotation_code
	jump flip_rotation
	jump leave_rotation

	jump flip_rotation
	jump leave_rotation

	jump flip_rotation
	jump leave_rotation

	jump flip_rotation
	jump leave_rotation
	# Rotation must have changed for us to be here:
	# if __0_, then the correct value is 45 - Tr
	# if __1_, then Tr can be used to index into the tan table normally

# We save a copy of the normalisd rotation into memory here
: rotation_normalised
	0
# v0 will be a safe copy of TrZ
# v2 is a copy of the rotation
: flip_rotation
	v1 := 45
	v2 =- v1
: leave_rotation
	# At this time v2 now contains our correct rotation value for our tables:
	# v2: Rotation to use for quick_tan

	# let's save this
	v0 := v2
	i := rotation_normalised
	save v0

	# We need to obtain the memory address of the pregenerated memory from quick_tan
	i := long quick_tan
	# Add rotation, twice:
	i += v2
	i += v2
	load v1
	# v0 v1 now contain the correct value for the starting memory address for this rotation

	i := offaxis_mem_read
	save v1

	i := long quick_off_axis
	i += v2
	i += v2
	load v1
	i := off_axis_table_address
	save v1
	i := mem_generic_off_axis
	save v1

	# Also, set the value for rotation in get_off_axis:
	v0 := v2
	i := quick_rot_for_axis
	save v0

	jump update_rotation_code_return

	# Technically we only need to like, do this, if TrZ has changed:
: update_trz_code
	# put a doubled version in vE
	vE := TrZ
	vE += TrZ

	i := long simple_axis_apply
	i += vE
	load v3

	i := simple_axis_apply_target_A
	save v3

	# put the correct value to bitflip to the opposrite side:
	vF := 0b10000
	vE ^= vF
	i := long simple_axis_apply
	i += vE
	load v3

	i := simple_axis_apply_target_B
	save v3

	# Then we must return, and, we jumped here, so
;

: trigger_pull
	# We want to strobe a pixel from crosshair_a to crosshair_b
	# We know the real positions of these crosshairs in crosshair_1_data
	# And we know the on and off axis values relative to the player

	# No matter what we are pulling the trigger here

	# We use up to v8 in this function, which is ok and doesn't affect normal gameplay

	v2 := random 0x01
	if v2 == 0 then	i := address_crosshair_1_data_memory
	if v2 == 1 then i := address_crosshair_2_data_memory
	load v1
	i := pull_trigger_internal_loop
	save v1
	if v2 == 0 then	i := apply_on_axis_flipped_memory
	if v2 == 1 then i := apply_on_axis_main_memory
	load v1
	i := pull_trigger_internal_loop_apply_memory
	save v1

	increase_sweeps
	
	# Load up the on subpixels and onaxis value for crosshair 1
	i := crosshair_1_subpixels
	load v1

	# v0 = subpx of crosshair 1
	# v1 = on axis of crosshai r1

	# We could Copy subpixels into subpixel accumulating register
	# But we might not be starting from here.
	# So we don't
	# v2 := v0
	# v1 is our current on axis

	# So load up just this value from crosshair 2:
	i := crosshair_2_onaxis
	load v0
	# Add the two onaxis values together
	v1 += v0

	# Save to a register
	v6 := v1
	# And fix the remaining offset:
	v6 += -1

	# Load up the normalised rotation:
	i := rotation_normalised
	load v0

	# Look up the memory location for subpixels per frame:
	i := long tan_table
	# Step in by rotation
	i += v0
	# Load it up
	load subpx_step - subpx_step
	# Store it for later!
	# subpx_step := v0

	# Now, since we actually want every pixel between the two locations
	# It's more code efficient to actually math it out rather than use our tables

	vE := 0
	
	i := 0x180
	save vF

		# Our loop here:
		# v0 = cross_x
		# v1 = cross_y
		# v2 = subpixel accumulator
		# v3 = on_axis
		# v4 = off_axis
		# v5 = subpx_step
		# v6 = distance_countdown
		# v7 = check for collisions with player sweep
		# v8 = end condition
		# vE = Allows for the delay of frames

	# Track points with this:
	Tx := 0
	# Starting points should be the current number of sweeps:
	i := long sweeps_this_level
	# Let's get XO chip finally
	load Tr - Tr
	vF := 10
	Tr =- vF

	# Draw the line
	# in theory if we hit something we're not supposed to, we need to crash out
	v7 := 1
	v8 := 0

	pull_trigger_internal_loop
	if v7 == 2 begin
		# if we hit something bad, we have to undraw the line we drew, and skip 
		# collision testing
		jump line_abort_point
	end
	
	
	q_delay

	# We now juse the graphics planes to avoid having to undraw all the enemies by just only drawing them
	# into the plane 2 where the line currently resides
	# We have to remove all enemies first and test them individually against the line
	# Turn off collisions:
	#v5 := 0
	# Remove them all:
	#sweep_enemies
	#sweep_trash
	
	# Activate collision detection
	v5 := 1
	# Test one at a time (as part of v5 being on)
	sweep_trash
	if Tx == 0 then Tr := 0
	sweep_enemies


	plane 1


	draw_score
	i := long score_this_level
	load v0 - v0
	v0 += Tx
	# Don't need with v0 - v0 leaving I static:
	# i := long score_this_level
	save v0 - v0
	draw_score

	# if v7 is 0 then we got all the trash:
	if v7 == 0 begin
		# We must have completed this level
		# But what level was this level??
		i := load_level_number
		load vA - vA
		# vA now contains the level number, I guess!

		###########
		# Can we save this score?
# 0             1            2          3                4                5                 6
# Last Sweeps				 Sweep Par				     Player Score Max 					Player Score Min
# 				Last Score				Player Sweeps Max				  Player Sweeps Min

		# All registers are available at this time!
		# We need to reload the score:
		i := long score_this_level
		# Let's load this:
		load v9 - v9
		i := long sweeps_this_level
		load v8 - v8

		i := long mul_8
		i += vA
		load v0

		i := long levels_saved_scores
		i += v0
		load v0 - v7

		# We now have the full level entry in memory

		# Set score and sweeps:
		# Last Sweeps:
		v0 := v8
		# Last Score
		v1 := v9
		
		# 3, 4 are a high SCORE record, with saved sweeps

		# 5, 6 are a lowest sweeps record, with saved score

		# fix this to match the way it should work
		# Min sweeps, in 5 6
		# if there's no saved record, this is always the new lowest!
		if v5 == 0 then v5 := v0
		# if this is a new or equal low:
		if v0 <= v5 begin
			# Save it:
			v5 := v0
			# And, is this a higher score?
			# if so, save that!
			if v1 > v6 then v6 := v1
		end


		# Max score?
		# is it a tie?
		if v1 == v4 begin
			if v3 == 0 then v3 := v0
			if v0 < v3 then v3 := v0
			jump save_score_exit
		end
		# or is it a better score?
		if v1 > v4 begin

			# Save this highest score
			v4 := v1
			# Save thie sweeps with it
			v3 := v0
		end
		: save_score_exit
		# Now resave over the same data
		save v0 - v7

		###########

		:monitor levels_saved_scores 16



		###############
		# Also we need to advence level progression:
		vA += 1
		i := long level_select_last
		load v0 - v3
		# v0: current level
		# v1: total levels unlocked
		# v2: total levels competed
		# v3: current chapter

		# We only make progress if this is higher than our current:
		if vA > v2 begin
			v2 := vA
			vA += 1
			v1 := vA
			# i := long level_select_last
			save v0 - v3
		end
		#############


		######
		# We flash the screen and nuke all registers to wait for the player to want to progress
		v0 := 4
		v1 := 2
		loop
			buzzer := v1
			vF := 10
			f_delay
			v0 -= 1
			if v0 != 0 then
		again
		v0 := key
		######

		#### EXIT AWAAAAY (this is not a subroutine)
		jump game_restart
	end

	v4 := 4
	flash_trash

	# turn off collision check
	#v5 := 0
	# And restore the enemies:
	#sweep_enemies
	#sweep_trash


	: line_abort_point
	# Then undraw the line:
	i := 0x180
	# restore how many pixels to draw
	load v6
	v7 := 0
	if v8 != v6 then pull_trigger_internal_loop

	i := 0x180
	load vF
	plane 1

	jump trigger_return
	
: trigger_quick_mem
 0 0

 : sweep_trash
 	# use v6 to count in 3s
 	v6 := 0
 	# Use v5 to count linearly now:
 	v5 := 0
 	#plane 1

 	# We can also use v7 at this time:

 	v7 := 0

 	#if v5 == 1 then 
 	plane 2
 	loop
	 	i := long quick_trash
	 	i += v6
	 	load v2

	 	if v2 == -1 then jump skip_trash_sweep

	 	# At least 1 item of trash remains
	 	v7 += 1

	 	i := long furniture
	 	i += v2
	 	sprite v0 v1 8

	 	#if v5 != 0 begin
	 		vE := vF
			sprite v0 v1 8
	 		if vE != 0 begin

	 			v7 += -1
				plane 1
				sprite v0 v1 8
				
				Tx += Tr
				if Tr != 0 then Tr += 1

				v2 := v5
				calc_trash_ui_pos

				v0 -= 1
				v1 -= 1 
				
				i := long trash_get
				#sprite v0 v1 0
				plane 2
				sprite v0 v1 0

	 			i := long level_reset_data
	 			load v2
	 			i := long quick_trash
	 			i += v6
	 			save v2
	 		end
	 	#end

	 	: skip_trash_sweep
 		v6 += 3
 		v5 += 1

 		if v6 != 27 then
 	again

 ;

: sweep_enemies
	v6 := 0

	#plane 1
	#if v5 == 1 then
	plane 2

	loop
		i := long enemy_fast_redraw
		i += v6
		load v3

		if v3 == -1 then jump trigger_skip_empty_mob
		i := long brushable_mobs
		i += v2

		sprite v0 v1 8
		# Test vF here perhaps
		#if v5 == 1 begin
			vE := vF
			sprite v0 v1 8
			if vE == 0 begin
				# This enemy did not touch our line, we can undraw it to stop testing
				jump trigger_skip_empty_mob
			end

			Tx += Tr
			if Tr != 0 then Tr += 1

			plane 1
			sprite v0 v1 8
			plane 2

			# Otherwise it does collide, specifically with our line
			# If that happens, we could remove it from the game here
			# That depends on us knowing that the line is good
			# and did not collide with anything it shouldn't be allowed to

			# We can use graphics planes to acheive the above perhaps

			# But let's remove this enemy from the redraw list:
			i := long enemy_fast_wipe
			load v3
			i := long enemy_fast_redraw
			i += v6
			save v3

			# And also request that it be removed
			remove_enemy
		#end

		: trigger_skip_empty_mob
		v6 += 0x08
		if v6 != 64 then
	again
;


: pull_trigger_internal_loop	# This label is used to change
		# Plot to the starting point:						|
		i := crosshair_2_data	# <-------------------------- this command
		load v2
		cross_x += 1
		cross_y += 1

		# We know that v2 contains the subpixels achieved by the line when it hit the barrier
		# But we are going to be counting backwards
		# So let's just invert this value and call it good:

		vF := 0xFF
		v2 ^= vF
		v2 += 1

		plane 2
		
		loop
			# We can just step on 1 pixel at a time:
			on_axis := 1
			off_axis := 0
			v2 += subpx_step
			if vf != 0 then off_axis := 1
			# Easy 45 degree mode:
			if subpx_step == 0xFF then off_axis := 1
			
			# If I wanted to reverse this, I would call the other command
			# And start at the other coords
			: pull_trigger_internal_loop_apply_memory
			apply_on_axis_main

			i := long line_v
			sprite cross_x cross_y 1

			if v7 == 0 then vF := 0

			if vF != 0 begin
				# We've hit something we're not allowed to
				# We have to abort this line

				on_axis := 5
				off_axis := 4

				v8 := v6

				plane 3
				loop
					scroll-up 1
					buzzer := off_axis
					vF := 4
					f_delay
					on_axis -= 1
					scroll-down 1
					vF := 4
					f_delay
					if on_axis != 0 then
				again
				plane 2

				sprite cross_x cross_y 1
				v7 := 2
				return
			end


			vE += 0b01000000
			if vE == 0 begin
				q_delay
			end

			v6 += -1

			if v6 != v8 then
		again

		plane 1
;

: q_delay
	vf := 1
: f_delay
	delay := vf
	loop
		vf := delay
		if vf != 0 then
	again
;

: clean_enemy_variables
	# These sure look like the same code, twice
	# Clear Vars?
	i := long enemy_fast_wipe
	load v7
	i := long enemy_fast_redraw

	v8 := 0
	
	: repeat_clear_loop
	loop
		save v7
		v8 += 1
		# Exits after the 2nd pass
		if v8 == 16 then return
		# Runs the code below after the first pass:
		if v8 != 8 then
	again

	i := long enemy_list_wipe
	load v7
	i := long enemy_list
	jump repeat_clear_loop

: service_enemy
	# v0 is the current value of frame cycle
	# which atm is a value of 0b????0000

	# v0 := Current movement type    --------- (gets moved elsewhere)
	# v1 := Current movement subframe --------- (gets moved elsewhere)
	# v2 := mob_frame : Current animation Frame
	# ------------ Easy Save separation
	# v3 := mob_x : Grid X position
	# v4 := mob_y : Grid Y position
	# v5 := mob_type : Type of enemy, useful for working out graphic and movement type
	# v6 := movement index
	# v7 := 
	# ------------------
	# v8 := infinite loop protection when deciding next movement type
	# v9 := movement subframe relocate
	# vA := mob movement type
	# vB mob_data_spacing
	# vC mob_draw_y
	# vD mob_draw_x
	# vE 

	i := frame_cycle_count
	load v0

	i := long enemy_list
	i += v0
	# Keep this for a hot minute in case we need it:
	vE := v0
	load enemy_data_size

	# This will load our enemy into our registers v0 to v7?

	# If there's no mob here, we skip:
	if mob_type == -1 then jump maybe_create_enemy
	# We need to get the display position of this mob:
: enemy_created
	# Backup our registers
	i := 0x180
	save vF

	# Copy our data over to our retaining registers:
	mob_movement_type := v0
	mob_movement_subframe := v1

	# Step A: Load up the X/Y coords into mob_x mob_y

	# Now because we save the enemy position we don't need to do this:
	# calc_mob_draw_xy


	# mob_type is now a 0x8 strided list
	# load up the sprite spacing for this sprite:
	# i := mob_spacing
	# i += mob_type
	# load v0
	# mob_data_spacing := v0

	# If the mob frame is -1, then it's the first time it's ever been drawn
	# In this case we don't need to undraw it:
	if mob_frame == -1 begin
		mob_frame := 0
		mob_movement_subframe := 16
		jump mob_skip_undraw
	end

	# Step B: we also need to know the enemy's last displacement:
	# This uses movement_type and movement_subframe to load up the offsets
	# into v0 and v1
	# then we add in the base draw position of this enemy:

	# We can do this:
	#load_movement_subdata
	#v0 += mob_draw_x
	#v1 += mob_draw_y
	# But instead we can do this:
	i := long enemy_fast_redraw
	i += vE
	load v1
	# We could load v2 and get the below offset, but we already have it:

	# Point I at the sprite:
	i := long brushable_mobs
	i += mob_type
	i += mob_frame

	# Undraw the enemy:
	sprite v0 v1 8

	# Iterate the frame every time we process this enemy, so that
	# it always does a little dance
	# conviniently, the sprites are strided by 0x80
	mob_frame += 0x80

	# And move it only half the time.
	# it would be cool if we could make some mobs move faster or slower:

	mob_speeder -= 1

	:const mob_speed_offset 0

	if mob_speeder == 0 begin
		i := long default_mob_datas
		i += mob_type
		v0 := mob_speed_offset
		load v0
		mob_speeder := v0
		mob_movement_subframe += 2
	end
	
	# Cycle the mob frame


	if mob_movement_subframe == 16 begin
		# We have completed our movement.
		# We marked our new cell as ours when we started moving.
		# So we must clear our current cell:

		# If it's a type of movement that actually moves:
		if mob_movement_type != 0 begin
			v0 := mob_x
			v1 := mob_y
			address_game_cell
			# i := long game_grid
			# i += v1
			v0 := -1
			save v0
			
			# Get single digit translation:
			mob_movement_subframe := 0
			# We pick the subframe assoicated with 1 px offset
			# But instead apply that to the grid:
			load_movement_subdata
			mob_x += v0
			mob_y += v1
			# New position marked
		end

		: mob_skip_undraw
		# We should progress to the next part of their movement at this time

		mob_infinite_loop_protection := 0
		# We need to apply the kind of movement that we hoped to achieve
		: mob_movement_jumpback
		mob_infinite_loop_protection += 1
		if mob_infinite_loop_protection == 6 then jump mob_loop_fail
		# We need to defend against infinite loops at this time
		if mob_movement_index == 16 then mob_movement_index := 0
		# mob movement index is the reference from the start of this mob's movement pattern that we're at
		i := long enemy_behaviors
		i += mob_type
		i += mob_type
		i += mob_movement_index
		# There are up to 16 kinds of thing that move with this system
		# Each type of movement has 16 bytes available to it
		# Load 2 bytes associated with movement
		load v1

		# If we've reached the end:
		# Go back to the start
		if v0 == -1 begin
			mob_movement_index := 0
			jump mob_movement_jumpback
		end

		# We just loaded from memory
		# v0 is our new movement type
		# v1 is our conditional

		# we need to do some math thinking stuff here
		# so we're going to need v0 and v1 shipped somewhere else
		mob_movement_type := v0
		vE := v1

		if mob_movement_type == -2 begin
			mob_movement_type := random 0b00110000
			mob_movement_type += 16
		end

		# A non 0 movement type is obviously acceptable:
		if mob_movement_type == 0 then jump movement_auto_valid

		# we need to look up the cell associated with this new position:
		mob_movement_subframe := 0
		load_movement_subdata
		v0 += mob_x
		v1 += mob_y
		address_game_cell

		# v0 : cell data
		# v1 : cell address

		# If v0 is -1, then it's fine

		# if v0 is NOT -1, then, we can't move right now
		if v0 != -1 begin
			# What we do now depends on the value of vE
			# Progression rules:
			# We also have conditionals
			# 0: Progress regardless
			# 1: Repeat until impossible
			# 2: Retry until successful

			# Progress anyway
			if vE == 0 begin
				# Just defer movement type to 0:
				: mob_loop_fail
				# This prevents us from experiencing another result:
				vE := 0
				mob_movement_type := 0
				mob_movement_index += 2
			end

			# This movement is impossible, so we should actually progress to the next movement
			if vE == 1 begin
				# We want to progress on a step:
				mob_movement_index += 2
				# This can create an infinite loop if the enemy is unable to progress in any direction:
				jump mob_movement_jumpback
			end

			if vE == 2 begin
				# We want to do nothing for this frame, but not progress:
				mob_movement_type := 0
				# If we can't move because it's a bad coord, we'll never succeed!!
				# So progress anyway:
				if v0 == -2 then mob_movement_index += 2
			end
		end

		if v0 == -1 begin
			# Load up this enemy ID:
			i := frame_cycle_count
			load v0
			# Target the game_grid and save our ID into it:
			i := long game_grid
			i += v1
			save v0

			: movement_auto_valid
			# If we can move into this location
			# Then v1 = 0 == progress
			#      v1 = 1 == don't progress yet
			#      v1 = 2 == progress
			if vE != 1 then mob_movement_index += 2
		end

		# we need to save the whole enemy in this case

		mob_movement_subframe := 0
	end

	calc_mob_draw_xy
	load_movement_subdata
	# Re index to sprite frame:

	v0 += mob_draw_x
	v1 += mob_draw_y

	# Take a copy of exactly where we drew this enemy on the screen:
	i := temp_e_data_b
	save v1

	i := long brushable_mobs
	i += mob_type
	i += mob_frame

	# This is the exact position of where the mob is drawn
	sprite v0 v1 8

	# Right now, v0 and v1 contain the information I want about the sprite position
	# mob_type + mob_frame consitute a < 256 byte offset to the graphic

	i := frame_cycle_count
	load v0
	i := long enemy_list
	i += v0

	# Keep the offset somewhere
	vE := v0

	# Save our updated enemy data
	# We move this data back into the save memory region:
	v0 := mob_movement_type
	v1 := mob_movement_subframe
	save enemy_data_size


	# Load up the X Y draw positions:
	i := temp_e_data_b
	load v1
	# For the purposes of collsion, we want to quickly undraw this enemy
	# Let's save the X Y position into a list
	# Note that mob_frame IS v2
	v2 += mob_type
	v3 := mob_type

	# Generate fast redraw info
	i := long enemy_fast_redraw
	i += vE
	save v3

	# Restore our regular gameplay registers:
	i := 0x180
	load vF
;

: temp_e_data_b
 0 0


: calc_mob_draw_xy
	i := long grid_xy
	i += mob_x
	load v0
	mob_draw_x := v0

	i := long grid_xy
	i += mob_y
	load v0
	mob_draw_y := v0

	# Translate over to the start of the grid:
	mob_draw_x += UL_X_plus1
	mob_draw_y += UL_Y_plus1
;

: load_movement_subdata
	v0 := 0
	v1 := 0

	if mob_movement_type == 0 then return
	# movement patterns are strided by 8 pairs of bytes
	i := long movement_patterns
	# we should store the direct access value in this register:
	i += mob_movement_type
	i += mob_movement_subframe
	# load the two small offsets
	load v1
;

: last_enemy
 -8

: maybe_create_enemy
	# vF contains the current enemy slot that is empty
	# I guess I should load an enemy from our hypothetical list of enemies:

	i := last_enemy
	load v0

	v0 += 8
	if v0 == 128 then v0 := 0

	vF := random 0b00001111
	if vF != 0 then return

	i := last_enemy
	save v0

	v2 := v0

	# enemy type is a multiple of 8
	v3 := 0
	# It also is where the current movement step is stored so it has to exist

	# I guess maybe we have to loop this till we find an empty space?
	# Note that this should be a multiple of 16 in order to work
	: retry_get_empty_position
	i := long random_mob_position
	load v0
	v0 += 2
	if v0 == 200 then v0 := 0
	i := long random_mob_position
	save v0
	i += v0
	load v1
	# next X Y coords loaded into v0 v1
	# Set the enemy to these coords
	i := long enemy_template_save_target
	save v3

	# Check this cell is actaully available:
	address_game_cell 
	# If not:
	if v0 != -1 then jump retry_get_empty_position

	# If yes:
	# Register this enemy to this location:

	i := long game_grid
	i += v1
	v0 := vE
	save v0

	i := long enemy_template
	load v7

	i := long enemy_list
	i += vE
	save v7
	# We can now relocate enemy_template v7 to the new memory location

	jump enemy_created
;

: remove_enemy
	# v6 contains the enemy to remove as x8
	i := long enemy_list
	i += v6

	# This enemy should be defaulted out
	v0 := 5
	i += v0
	v0 := -1
	save v0

	# additionally, there may be cells associated with it in game_grid
	# These need to be cleared out

	v1 := 0
	i := long game_grid
	loop
		load v0

		if v0 == v6 begin
			i := long game_grid
			i += v1
			v0 := -1
			save v0
		end
		v1 += 1
		if v1 != 49 then
	again
;



: address_game_cell
	# v0 := X pos
	# v1 := Y pos
	if v0 == 255 then jump bad_coord
	if v0 == 7 then jump bad_coord
	if v1 == 255 then jump bad_coord
	if v1 == 7 then jump bad_coord

	# Take the value in v1, the Y position
	# And effectively multiply it by 7:
	i := long game_grid_stride
	i += v1
	# v1 is done with, copy v0 into v1
	v1 := v0
	# Load the mul7 value into v0
	load v0
	# Add that value to v1
	v1 += v0

	# We also load the value of the game grid into v0 as part of this operation
	i := long game_grid
	i += v1
	# By using load v0 - v0, we prevent I from stepping onward:
	load v0 - v0
;
: bad_coord
	v0 := -2
	# v0 now has the value of this cell in it
	# v1 now has the relative index to this cell in it
;

: calc_trash_ui_pos
	# v2 is trash index
	v0 := 98
	v1 := 8
	if v2 == 0 then jump skip_annoying_math
	loop
		v0 += 9
		:calc what_would_it_be { 98 + 3 * 9 }
		if v0 == what_would_it_be begin
			v1 += 9
			v0 := 98
		end
		v2 -= 1
		if v2 != 0 then
	again
	: skip_annoying_math
;

:macro draw_chapter_art
{

	# Draw the box that surrounds the chapter art:
	v1 := 17
	v2 := LL_Y

	draw_paired_lines_h
	i := long line_v
	v0 += 1
	v1 += 1
	sprite v0 v1 2
	v0 := UL_X
	sprite v0 v1 2

	v2 := 20
	draw_paired_lines_v

	i := long chapter_art_addresses
	i += current_chapter
	i += current_chapter
	load v1

	i := draw_chapter_art_sprite_start
	save v1

	# point at sprite start:
	0xF0 0
	: draw_chapter_art_sprite_start
			0 0

	# Sprite is 7x3 8x14 sprites
	# Start is 36 18

	:calc chapter_art_start_x { 36 }
	:calc chapter_art_start_y { 18 }

	:calc chapter_art_width { 8 }
	:calc chapter_art_height { 14 }

	:calc chapter_art_end_x { chapter_art_start_x + 7 * chapter_art_width }
	:calc chapter_art_end_y { chapter_art_start_y + 3 * chapter_art_height }

	# Bytes to step I on by:
	plane 2
	v2 := 14
	v1 := chapter_art_start_y
	loop
		v0 := chapter_art_start_x
		loop
			sprite v0 v1 14
			i += v2
			v0 += chapter_art_width

			if v0 != chapter_art_end_x then
		again

		v1 += chapter_art_height
		if v1 != chapter_art_end_y then
	again
	plane 1
#;
}

: level_select_mode
	# Captures gameplay and allows the player to select a level
	reset_for_new_game_loop
	# no registers matter on entry to this area.
	# The screen also is wiped

	:alias chapter_sublevel v8
	# :alias total_levels_unlocked v9
	# :alias total_levels_complete vA
	:alias current_chapter vB
	# mob_draw_x & y are vC and vD

	i := long level_select_last
	load chapter_sublevel - current_chapter

	draw_chapter_art

	:alias chapter_offset v7
	i := long mul_8
	i += current_chapter
	# We now know where to index into chapters
	load chapter_offset - chapter_offset
	# Chapter Offset is the memory offset to the start of the chapter that we're in

	# We can reuse vB because we do not need to use current_chapter past this point
	:alias ls_maximum_right vB

	# First, draw the layout:
	mob_draw_x := 0
	mob_draw_y := 1

	# v4 and v5 become available after this first loop
	:alias completed_levels_drawn v4

	completed_levels_drawn := 0
	ls_maximum_right := 0

	# v6 will be our selection within the chapter:
	:alias ls_cur v6
	ls_cur := 0

	# This is going to draw the chapter from left to right, apparently:
	loop
		i := long chapters
		i += chapter_offset
		i += ls_cur

		load v0
		# What are we looking at here:

		# -1 is the 'beginning' of the game, marked with a dot
		if v0 == -1 begin
			mob_draw_x += 4
			i := long level_select_marker_first
			sprite mob_draw_x mob_draw_y  8
			mob_draw_x += 8
			jump lv_select_end_loop
		end

		# If v0 is in this region, then it is a chapter change button at the start or end of a chapter
		if v0 >= 0x80 begin
			# This must be at the end:
			if ls_cur == 7 begin
				# If we have not drawn 6 complete levels this chapter, we can't proceed:
				if completed_levels_drawn != 6 then	jump lv_select_end_loop

				i := long padded_line_h
				sprite mob_draw_x mob_draw_y 4
				mob_draw_x += 8
				i := long level_select_marker_next

				# We can also select this entry now:
				ls_maximum_right := ls_cur
			end
			# This must be at the start:
			if ls_cur == 0 begin
				mob_draw_x += 4
				i := long level_select_marker_prev
			end

			sprite mob_draw_x mob_draw_y  8
			mob_draw_x += 8
		end

		# Is this level number unlocked?
		# if v0 < total_levels_unlocked begin
		if v0 < v9 begin

			i := long padded_line_h
			sprite mob_draw_x mob_draw_y 4
			mob_draw_x += 8
			i := long level_select_marker
			sprite mob_draw_x mob_draw_y  8

			# Is this level also completed?
			# if v0 < total_levels_complete begin
			if v0 < vA begin
				completed_levels_drawn += 1
				i := long level_select_complete
				sprite mob_draw_x mob_draw_y  8
			end

			ls_maximum_right := ls_cur

			mob_draw_x += 8
		end

		: lv_select_end_loop
		ls_cur += 1
		if ls_cur != 8 then
	again

	# This gives us a rendered 'chapter'

	##############################################
	##############################################
	# This is our point of separation for many register fields
	# total_levels_unlocked is available
	# v9
	# total_levels_complete is available
	# vA

	:alias ls_stats_displayed_status vA
	ls_stats_displayed_status := 0

	# And we often loop back here:
	: level_select_move_select_arrow

	# We will store the 'true' number of this level somewhere, and that somewhere
	# should be below v7, because we use our high registers in draw_level_select_stats
	# However we also stash them all, so, our current values should be maintained
	:alias ls_true_level_number v5

	# Populate this value:
	i := long chapters
	i += chapter_offset
	i += chapter_sublevel
	load ls_true_level_number - ls_true_level_number

	# My goal is to persist the text if we need it still, so that
	# we don't undraw things we don't need to
	# This function requires ls_true_level_number be valid
	draw_level_select_stats_only
	draw_level_select_stats_text_only

	# Actual select loop:
	# Use chapter_sublevel 0 - 7 to select what we're looking at:

	draw_level_select_mainchar

	# Multiply our sublevel by 16:
	i := long sublevel_arrow_start
	i += chapter_sublevel
	load mob_draw_x - mob_draw_x

	#mob_draw_x := v0
	#mob_draw_x += mob_draw_x
	# And add 4, for the X offset:
	#mob_draw_x += 4
	mob_draw_y := 9
	# Draw the selection arrow:
	i := long level_select_pointer
	sprite mob_draw_x mob_draw_y 8

	# We can only go as high as v4, this gives us 5 registers to work with.
	# If we're going to draw text and such like, I think it's probably wise to stash our registers:

	# We do a simple input loop here:
	: level_select_reject_input
	# Take input into v0:
	v0 := key
	# Left
	if v0 == 7 begin
		if chapter_sublevel == 0 then jump level_select_reject_input
		sprite mob_draw_x mob_draw_y  8
		# Needs to happen before the sublevel changes?
		draw_level_select_stats_only
		draw_level_select_mainchar
		chapter_sublevel += -1

		jump level_select_move_select_arrow
	end

	# Right
	if v0 == 9 begin
		if chapter_sublevel == ls_maximum_right then jump level_select_reject_input

		sprite mob_draw_x mob_draw_y  8
		# Needs to happen before the sublevel changes?
		draw_level_select_stats_only
		draw_level_select_mainchar
		chapter_sublevel += 1
		
		jump level_select_move_select_arrow
	end

	# Pulling the trigger:
	if v0 == 0xE begin
		if ls_true_level_number == -1 then jump level_select_reject_input

		# Change chapter
		if ls_true_level_number >= 0x80 begin
			ls_true_level_number -= 0x80
			current_chapter := ls_true_level_number

			if chapter_sublevel == 0 then chapter_sublevel := 6
			if chapter_sublevel == 7 then chapter_sublevel := 1

			i := long level_select_last
			save chapter_sublevel - chapter_sublevel
			load v2
			save current_chapter - current_chapter

			# This invalidates ls_maximum_right, but, that's ok because we are
			# going to regenerate it due to chapter change:
			jump level_select_mode
		end

		# Otherwise we select this level to play
		# First we save which level in the chapter we're doing:
		i := long level_select_last
		save chapter_sublevel - chapter_sublevel

		# Save the level to play into the appropriate location:
		i := load_level_number
		save ls_true_level_number - ls_true_level_number

		return
	end
	jump level_select_reject_input

: draw_level_select_mainchar
	if chapter_sublevel == 0 then return
	if chapter_sublevel == 7 then return

	i := long levels_char_position
	i += ls_true_level_number
	i += ls_true_level_number
	i += ls_true_level_number
	load v2
	# these are now the coords
	i := long sweeper_nothing_flip
	i += v2
	sprite v0 v1 0
;

: draw_level_select_stats_text_only
	# Our normal goal is 2, and received in mob_draw_x

	if chapter_sublevel == 0 then mob_draw_x := 0
	if chapter_sublevel == 7 then mob_draw_x := 0

	#mob_draw_x := 0
	#mob_draw_y := 0
	# if we are already at our goal, then, return:
	if mob_draw_x == ls_stats_displayed_status then return

	# I did a weird truth table thing for this and it turns out there's a way 'faster' way to do this:

#	if v6 == 0 begin
#		if ls_stats_displayed_status == 2 then mob_draw_x := 1
#		mob_draw_y := 1
#	end

#	if v6 == 2 begin
#		if ls_stats_displayed_status != 1 then mob_draw_y := 1
#		mob_draw_x := 1
	#end

	#if v6 == 1 begin
	#	if ls_stats_displayed_status == 2 then mob_draw_x := 1
	#	if ls_stats_displayed_status == 0 then mob_draw_y := 1
	#end

	v6 := mob_draw_x
	mob_draw_x += ls_stats_displayed_status
	ls_stats_displayed_status := v6

	if mob_draw_x != 1 begin
		ez_print level_select_stats_text
	end

	if mob_draw_x != 3 begin
		ez_print level_select_text
	end
;

: draw_level_select_stats_only
	if chapter_sublevel == 0 then return
	if chapter_sublevel == 7 then return

	i := long register_dump
	save vB

	# Can we display the stats associated with this level
	# We need to know what actual level we are actually looking at here

	# index to score table for this level:
	# We mul_4 the true level, giving us 64 true levels:
	v0 <<= ls_true_level_number
	v0 <<= v0
	# Then we add this twice.
	# This is because we likely will have > 32 levels
	i := long levels_saved_scores
	i += v0
	i += v0

#   7           8            9                a      b                       c           d
# Last Sweeps				 Sweep Par				Player Score Max 					Player Score Min
# 				Last Score					  Player Sweeps Max				  Player Sweeps Min

	# Our regiters are stashed so we can do whatever we want now
	# we will be using v0, v1 and v2 to draw numbers
	# And we will be messing up our I pointer
	load v7 - vE

	v1 := 17
	v2 := 23
	v0 := 0
	q_dig

	# ls_true_level_number is v5:
	v0 := ls_true_level_number
	v0 += 1
	draw_bcd_v1v2

	v2 += 12
	v0 := v9
	q_dig

	# Then We only draw these if the player has completed it:

	if vB == 0 begin
		mob_draw_x := 1
		jump level_select_stats_not_complete
	end

	v2 += 12
	v0 := v7
	q_dig

	v2 += 6
	v1 -= 12
	v0 := v8
	draw_bcd_v1v2

	v1 := 110
	v2 := 23

	v0 := vB
	draw_bcd_v1v2

	v1 := 110
	v0 := vD
	v2 := 53
	draw_bcd_v1v2

	v0 := vA
	v2 := 29
	q_dig

	v0 := vC
	v2 := 47
	q_dig

	mob_draw_x := 2
	: level_select_stats_not_complete
	# Restore registers:
	i := long register_dump
	load vB
;

: increase_sweeps
	
	i := long sweeps_this_level
	load v0
	v3 := v0
	draw_sweeps
	v0 := v3
	v0 += 1
	if v0 == 11 then v0 := 10
	i := long sweeps_this_level
	save v0

	# draw_sweeps
	q_dig
;

: draw_sweeps
	v1 := 28
	v2 := 56
	q_dig
;

: draw_score
	v1 := 108
	v2 := 56
	i := long score_this_level
	load v0

: draw_bcd_v1v2

	i := simple_bcd_values
	bcd v0

	load v0
	q_dig

	i := simple_bcd_values_plus1
	load v0
	v1 += 6
	q_dig

	i := simple_bcd_values_plus2
	load v0
	v1 += 6
	q_dig
;

: q_dig
	i := long mul_5
	i += v0
	load v0
	i := long fivewide_digits
	i += v0
	sprite v1 v2 5
;

: simple_bcd_values
	0 
: simple_bcd_values_plus1
	0
: simple_bcd_values_plus2
	0





# Ideally these will live in low memory
: crosshair_a
0b10100000
0b00000000
0b10100000

: crosshair_b
0b11100000
0b11100000
0b11100000

:calc FREE { 4096 - HERE }
: FREE_CODE_BYTES
:byte { FREE >> 8 }
:byte { FREE }
:monitor FREE_CODE_BYTES "%2i"



:calc probably_offaxis_data { quick_tan_table + 44 * 128 }
#:monitor quick_off_axis 90

:monitor sweeps_this_level 2
:monitor level_select_last 4